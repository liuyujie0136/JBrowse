{"version":3,"file":"static/js/7214.c44e75c1.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/bbi/esm/bbi.js","../../../node_modules/@gmod/bbi/esm/bigbed.js","../../../node_modules/@gmod/bbi/esm/bigwig.js","../../../node_modules/@gmod/bbi/esm/blockView.js","../../../node_modules/@gmod/bbi/esm/index.js","../../../node_modules/@gmod/bbi/esm/range.js","../../../node_modules/@gmod/bbi/esm/unzip-pako.js","../../../node_modules/@gmod/bbi/esm/util.js","../../../node_modules/rxjs/src/internal/scheduler/AnimationFrameAction.ts","../../../node_modules/rxjs/src/internal/scheduler/AnimationFrameScheduler.ts","../../../node_modules/rxjs/src/internal/scheduler/animationFrame.ts","../../../node_modules/rxjs/src/internal/scheduler/VirtualTimeScheduler.ts","../../../node_modules/rxjs/src/internal/util/isObservable.ts","../../../node_modules/rxjs/src/internal/observable/bindCallback.ts","../../../node_modules/rxjs/src/internal/observable/bindNodeCallback.ts","../../../node_modules/rxjs/src/internal/observable/forkJoin.ts","../../../node_modules/rxjs/src/internal/observable/fromEventPattern.ts","../../../node_modules/rxjs/src/internal/observable/generate.ts","../../../node_modules/rxjs/src/internal/observable/iif.ts","../../../node_modules/rxjs/src/internal/observable/interval.ts","../../../node_modules/rxjs/src/internal/observable/never.ts","../../../node_modules/rxjs/src/internal/observable/onErrorResumeNext.ts","../../../node_modules/rxjs/src/internal/observable/pairs.ts","../../../node_modules/rxjs/src/internal/observable/partition.ts","../../../node_modules/rxjs/src/internal/observable/range.ts","../../../node_modules/rxjs/src/internal/observable/using.ts","../../../node_modules/rxjs/src/internal/AsyncSubject.ts","../../../node_modules/rxjs/src/internal/BehaviorSubject.ts","../../../node_modules/rxjs/src/internal/Notification.ts","../../../node_modules/rxjs/src/internal/OuterSubscriber.ts","../../../node_modules/rxjs/src/internal/ReplaySubject.ts","../../../node_modules/rxjs/src/internal/Scheduler.ts","../../../node_modules/rxjs/src/internal/Subject.ts","../../../node_modules/rxjs/src/internal/SubjectSubscription.ts","../../../node_modules/rxjs/src/internal/observable/ConnectableObservable.ts","../../../node_modules/rxjs/src/internal/observable/combineLatest.ts","../../../node_modules/rxjs/src/internal/observable/concat.ts","../../../node_modules/rxjs/src/internal/observable/defer.ts","../../../node_modules/rxjs/src/internal/observable/of.ts","../../../node_modules/rxjs/src/internal/observable/race.ts","../../../node_modules/rxjs/src/internal/observable/throwError.ts","../../../node_modules/rxjs/src/internal/observable/timer.ts","../../../node_modules/rxjs/src/internal/observable/zip.ts","../../../node_modules/rxjs/src/internal/operators/concatAll.ts","../../../node_modules/rxjs/src/internal/operators/groupBy.ts","../../../node_modules/rxjs/src/internal/operators/observeOn.ts","../../../node_modules/rxjs/src/internal/operators/refCount.ts","../../../node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","../../../node_modules/rxjs/src/internal/scheduler/Action.ts","../../../node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","../../../node_modules/rxjs/src/internal/util/Immediate.ts","../../../node_modules/rxjs/src/internal/scheduler/AsapAction.ts","../../../node_modules/rxjs/src/internal/scheduler/AsapScheduler.ts","../../../node_modules/rxjs/src/internal/scheduler/asap.ts","../../../node_modules/rxjs/src/internal/scheduler/async.ts","../../../node_modules/rxjs/src/internal/scheduler/QueueAction.ts","../../../node_modules/rxjs/src/internal/scheduler/QueueScheduler.ts","../../../node_modules/rxjs/src/internal/scheduler/queue.ts","../../../node_modules/rxjs/src/internal/util/EmptyError.ts","../../../node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../../../node_modules/rxjs/src/internal/util/TimeoutError.ts","../../../node_modules/rxjs/src/internal/util/isNumeric.ts","../../../node_modules/rxjs/src/internal/util/not.ts","../../../node_modules/rxjs/src/internal/InnerSubscriber.ts","../../../node_modules/rxjs/src/internal/util/subscribeToResult.ts","../../../node_modules/rxjs/src/internal/operators/audit.ts","../../../node_modules/rxjs/src/internal/operators/auditTime.ts","../../../node_modules/rxjs/src/internal/operators/buffer.ts","../../../node_modules/rxjs/src/internal/operators/bufferCount.ts","../../../node_modules/rxjs/src/internal/operators/bufferTime.ts","../../../node_modules/rxjs/src/internal/operators/bufferToggle.ts","../../../node_modules/rxjs/src/internal/operators/bufferWhen.ts","../../../node_modules/rxjs/src/internal/operators/catchError.ts","../../../node_modules/rxjs/src/internal/operators/combineAll.ts","../../../node_modules/rxjs/src/internal/operators/combineLatest.ts","../../../node_modules/rxjs/src/internal/operators/concat.ts","../../../node_modules/rxjs/src/internal/operators/concatMap.ts","../../../node_modules/rxjs/src/internal/operators/concatMapTo.ts","../../../node_modules/rxjs/src/internal/operators/count.ts","../../../node_modules/rxjs/src/internal/operators/debounce.ts","../../../node_modules/rxjs/src/internal/operators/debounceTime.ts","../../../node_modules/rxjs/src/internal/util/isDate.ts","../../../node_modules/rxjs/src/internal/operators/delay.ts","../../../node_modules/rxjs/src/internal/operators/delayWhen.ts","../../../node_modules/rxjs/src/internal/operators/dematerialize.ts","../../../node_modules/rxjs/src/internal/operators/distinct.ts","../../../node_modules/rxjs/src/internal/operators/distinctUntilChanged.ts","../../../node_modules/rxjs/src/internal/operators/distinctUntilKeyChanged.ts","../../../node_modules/rxjs/src/internal/operators/throwIfEmpty.ts","../../../node_modules/rxjs/src/internal/operators/take.ts","../../../node_modules/rxjs/src/internal/operators/elementAt.ts","../../../node_modules/rxjs/src/internal/operators/endWith.ts","../../../node_modules/rxjs/src/internal/operators/every.ts","../../../node_modules/rxjs/src/internal/operators/exhaust.ts","../../../node_modules/rxjs/src/internal/operators/exhaustMap.ts","../../../node_modules/rxjs/src/internal/operators/expand.ts","../../../node_modules/rxjs/src/internal/operators/finalize.ts","../../../node_modules/rxjs/src/internal/operators/find.ts","../../../node_modules/rxjs/src/internal/operators/findIndex.ts","../../../node_modules/rxjs/src/internal/operators/first.ts","../../../node_modules/rxjs/src/internal/operators/ignoreElements.ts","../../../node_modules/rxjs/src/internal/operators/isEmpty.ts","../../../node_modules/rxjs/src/internal/operators/last.ts","../../../node_modules/rxjs/src/internal/operators/mapTo.ts","../../../node_modules/rxjs/src/internal/operators/materialize.ts","../../../node_modules/rxjs/src/internal/operators/max.ts","../../../node_modules/rxjs/src/internal/operators/merge.ts","../../../node_modules/rxjs/src/internal/operators/mergeMapTo.ts","../../../node_modules/rxjs/src/internal/operators/mergeScan.ts","../../../node_modules/rxjs/src/internal/operators/min.ts","../../../node_modules/rxjs/src/internal/operators/multicast.ts","../../../node_modules/rxjs/src/internal/operators/onErrorResumeNext.ts","../../../node_modules/rxjs/src/internal/operators/pairwise.ts","../../../node_modules/rxjs/src/internal/operators/partition.ts","../../../node_modules/rxjs/src/internal/operators/pluck.ts","../../../node_modules/rxjs/src/internal/operators/publish.ts","../../../node_modules/rxjs/src/internal/operators/publishBehavior.ts","../../../node_modules/rxjs/src/internal/operators/publishLast.ts","../../../node_modules/rxjs/src/internal/operators/publishReplay.ts","../../../node_modules/rxjs/src/internal/operators/race.ts","../../../node_modules/rxjs/src/internal/operators/repeat.ts","../../../node_modules/rxjs/src/internal/operators/repeatWhen.ts","../../../node_modules/rxjs/src/internal/operators/retry.ts","../../../node_modules/rxjs/src/internal/operators/retryWhen.ts","../../../node_modules/rxjs/src/internal/operators/sample.ts","../../../node_modules/rxjs/src/internal/operators/sampleTime.ts","../../../node_modules/rxjs/src/internal/operators/sequenceEqual.ts","../../../node_modules/rxjs/src/internal/operators/share.ts","../../../node_modules/rxjs/src/internal/operators/shareReplay.ts","../../../node_modules/rxjs/src/internal/operators/single.ts","../../../node_modules/rxjs/src/internal/operators/skip.ts","../../../node_modules/rxjs/src/internal/operators/skipLast.ts","../../../node_modules/rxjs/src/internal/operators/skipUntil.ts","../../../node_modules/rxjs/src/internal/operators/skipWhile.ts","../../../node_modules/rxjs/src/internal/operators/startWith.ts","../../../node_modules/rxjs/src/internal/observable/SubscribeOnObservable.ts","../../../node_modules/rxjs/src/internal/operators/subscribeOn.ts","../../../node_modules/rxjs/src/internal/operators/switchMap.ts","../../../node_modules/rxjs/src/internal/operators/switchAll.ts","../../../node_modules/rxjs/src/internal/operators/switchMapTo.ts","../../../node_modules/rxjs/src/internal/operators/takeWhile.ts","../../../node_modules/rxjs/src/internal/operators/tap.ts","../../../node_modules/rxjs/src/internal/operators/throttle.ts","../../../node_modules/rxjs/src/internal/operators/throttleTime.ts","../../../node_modules/rxjs/src/internal/operators/timeInterval.ts","../../../node_modules/rxjs/src/internal/operators/timeoutWith.ts","../../../node_modules/rxjs/src/internal/operators/timeout.ts","../../../node_modules/rxjs/src/internal/operators/timestamp.ts","../../../node_modules/rxjs/src/internal/operators/window.ts","../../../node_modules/rxjs/src/internal/operators/windowCount.ts","../../../node_modules/rxjs/src/internal/operators/windowTime.ts","../../../node_modules/rxjs/src/internal/operators/windowToggle.ts","../../../node_modules/rxjs/src/internal/operators/windowWhen.ts","../../../node_modules/rxjs/src/internal/operators/withLatestFrom.ts","../../../node_modules/rxjs/src/internal/operators/zip.ts","../../../node_modules/rxjs/src/internal/operators/zipAll.ts"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BBI = void 0;\nconst binary_parser_1 = require(\"@gmod/binary-parser\");\nconst generic_filehandle_1 = require(\"generic-filehandle\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst abortable_promise_cache_1 = __importDefault(require(\"abortable-promise-cache\"));\nconst quick_lru_1 = __importDefault(require(\"quick-lru\"));\nconst blockView_1 = require(\"./blockView\");\nconst BIG_WIG_MAGIC = -2003829722;\nconst BIG_BED_MAGIC = -2021002517;\n/* get the compiled parsers for different sections of the bigwig file\n *\n * @param isBE - is big endian, typically false\n * @return an object with compiled parsers\n */\nfunction getParsers(isBE) {\n    const le = isBE ? 'big' : 'little';\n    const headerParser = new binary_parser_1.Parser()\n        .endianess(le)\n        .int32('magic')\n        .uint16('version')\n        .uint16('numZoomLevels')\n        .uint64('chromTreeOffset')\n        .uint64('unzoomedDataOffset')\n        .uint64('unzoomedIndexOffset')\n        .uint16('fieldCount')\n        .uint16('definedFieldCount')\n        .uint64('asOffset') // autoSql offset, used in bigbed\n        .uint64('totalSummaryOffset')\n        .uint32('uncompressBufSize')\n        .uint64('extHeaderOffset') // name index offset, used in bigbed\n        .array('zoomLevels', {\n        length: 'numZoomLevels',\n        type: new binary_parser_1.Parser()\n            .uint32('reductionLevel')\n            .uint32('reserved')\n            .uint64('dataOffset')\n            .uint64('indexOffset'),\n    });\n    const totalSummaryParser = new binary_parser_1.Parser()\n        .endianess(le)\n        .uint64('basesCovered')\n        .double('scoreMin')\n        .double('scoreMax')\n        .double('scoreSum')\n        .double('scoreSumSquares');\n    const chromTreeParser = new binary_parser_1.Parser()\n        .endianess(le)\n        .uint32('magic')\n        .uint32('blockSize')\n        .uint32('keySize')\n        .uint32('valSize')\n        .uint64('itemCount');\n    const isLeafNode = new binary_parser_1.Parser()\n        .endianess(le)\n        .uint8('isLeafNode')\n        .skip(1)\n        .uint16('cnt');\n    return {\n        chromTreeParser,\n        totalSummaryParser,\n        headerParser,\n        isLeafNode,\n    };\n}\nclass BBI {\n    /*\n     * @param filehandle - a filehandle from generic-filehandle or implementing something similar to the node10 fs.promises API\n     * @param path - a Local file path as a string\n     * @param url - a URL string\n     * @param renameRefSeqs - an optional method to rename the internal reference sequences using a mapping function\n     */\n    constructor(options = {}) {\n        this.headerCache = new abortable_promise_cache_1.default({\n            cache: new quick_lru_1.default({ maxSize: 1 }),\n            fill: async (params, signal) => {\n                return this._getHeader({ ...params, signal });\n            },\n        });\n        const { filehandle, renameRefSeqs, path, url } = options;\n        this.renameRefSeqs = renameRefSeqs || ((s) => s);\n        if (filehandle) {\n            this.bbi = filehandle;\n        }\n        else if (url) {\n            this.bbi = new generic_filehandle_1.RemoteFile(url);\n        }\n        else if (path) {\n            this.bbi = new generic_filehandle_1.LocalFile(path);\n        }\n        else {\n            throw new Error('no file given');\n        }\n    }\n    /* fetch and parse header information from a bigwig or bigbed file\n     * @param abortSignal - abort the operation, can be null\n     * @return a Header object\n     */\n    getHeader(opts = {}) {\n        const options = 'aborted' in opts ? { signal: opts } : opts;\n        return this.headerCache.get(JSON.stringify(options), options, options.signal);\n    }\n    async _getHeader(opts) {\n        const header = await this._getMainHeader(opts);\n        const chroms = await this._readChromTree(header, opts);\n        return { ...header, ...chroms };\n    }\n    async _getMainHeader(opts, requestSize = 2000) {\n        const { buffer } = await this.bbi.read(Buffer.alloc(requestSize), 0, requestSize, 0, opts);\n        const isBigEndian = this._isBigEndian(buffer);\n        const ret = getParsers(isBigEndian);\n        const header = ret.headerParser.parse(buffer).result;\n        header.fileType = header.magic === BIG_BED_MAGIC ? 'bigbed' : 'bigwig';\n        if (header.asOffset > requestSize ||\n            header.totalSummaryOffset > requestSize) {\n            return this._getMainHeader(opts, requestSize * 2);\n        }\n        if (header.asOffset) {\n            header.autoSql = buffer\n                .slice(header.asOffset, buffer.indexOf(0, header.asOffset))\n                .toString('utf8');\n        }\n        if (header.totalSummaryOffset > requestSize) {\n            return this._getMainHeader(opts, requestSize * 2);\n        }\n        if (header.totalSummaryOffset) {\n            const tail = buffer.slice(header.totalSummaryOffset);\n            header.totalSummary = ret.totalSummaryParser.parse(tail).result;\n        }\n        return { ...header, isBigEndian };\n    }\n    _isBigEndian(buffer) {\n        let ret = buffer.readInt32LE(0);\n        if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {\n            return false;\n        }\n        ret = buffer.readInt32BE(0);\n        if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {\n            return true;\n        }\n        throw new Error('not a BigWig/BigBed file');\n    }\n    // todo: add progress if long running\n    async _readChromTree(header, opts) {\n        const isBE = header.isBigEndian;\n        const le = isBE ? 'big' : 'little';\n        const refsByNumber = [];\n        const refsByName = {};\n        const { chromTreeOffset } = header;\n        let { unzoomedDataOffset } = header;\n        while (unzoomedDataOffset % 4 !== 0) {\n            unzoomedDataOffset += 1;\n        }\n        const { buffer: data } = await this.bbi.read(Buffer.alloc(unzoomedDataOffset - chromTreeOffset), 0, unzoomedDataOffset - chromTreeOffset, chromTreeOffset, opts);\n        const p = getParsers(isBE);\n        const { keySize } = p.chromTreeParser.parse(data).result;\n        const leafNodeParser = new binary_parser_1.Parser()\n            .endianess(le)\n            .string('key', { stripNull: true, length: keySize })\n            .uint32('refId')\n            .uint32('refSize');\n        const nonleafNodeParser = new binary_parser_1.Parser()\n            .endianess(le)\n            .skip(keySize)\n            .uint64('childOffset');\n        const rootNodeOffset = 32;\n        const bptReadNode = async (currentOffset) => {\n            let offset = currentOffset;\n            if (offset >= data.length) {\n                throw new Error('reading beyond end of buffer');\n            }\n            const ret = p.isLeafNode.parse(data.slice(offset));\n            const { isLeafNode, cnt } = ret.result;\n            offset += ret.offset;\n            if (isLeafNode) {\n                for (let n = 0; n < cnt; n += 1) {\n                    const leafRet = leafNodeParser.parse(data.slice(offset));\n                    offset += leafRet.offset;\n                    const { key, refId, refSize } = leafRet.result;\n                    const refRec = { name: key, id: refId, length: refSize };\n                    refsByName[this.renameRefSeqs(key)] = refId;\n                    refsByNumber[refId] = refRec;\n                }\n            }\n            else {\n                // parse index node\n                const nextNodes = [];\n                for (let n = 0; n < cnt; n += 1) {\n                    const nonleafRet = nonleafNodeParser.parse(data.slice(offset));\n                    let { childOffset } = nonleafRet.result;\n                    offset += nonleafRet.offset;\n                    childOffset -= chromTreeOffset;\n                    nextNodes.push(bptReadNode(childOffset));\n                }\n                await Promise.all(nextNodes);\n            }\n        };\n        await bptReadNode(rootNodeOffset);\n        return {\n            refsByName,\n            refsByNumber,\n        };\n    }\n    /*\n     * fetches the \"unzoomed\" view of the bigwig data. this is the default for bigbed\n     * @param abortSignal - a signal to optionally abort this operation\n     */\n    async getUnzoomedView(opts) {\n        const { unzoomedIndexOffset, zoomLevels, refsByName, uncompressBufSize, isBigEndian, fileType, } = await this.getHeader(opts);\n        const nzl = zoomLevels[0];\n        const cirLen = nzl ? nzl.dataOffset - unzoomedIndexOffset : 4000;\n        return new blockView_1.BlockView(this.bbi, refsByName, unzoomedIndexOffset, cirLen, isBigEndian, uncompressBufSize > 0, fileType);\n    }\n    /**\n     * Gets features from a BigWig file\n     *\n     * @param refName - The chromosome name\n     * @param start - The start of a region\n     * @param end - The end of a region\n     * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use\n     */\n    async getFeatureStream(refName, start, end, opts = {\n        scale: 1,\n    }) {\n        await this.getHeader(opts);\n        const chrName = this.renameRefSeqs(refName);\n        let view;\n        if (opts.basesPerSpan) {\n            view = await this.getView(1 / opts.basesPerSpan, opts);\n        }\n        else if (opts.scale) {\n            view = await this.getView(opts.scale, opts);\n        }\n        else {\n            view = await this.getView(1, opts);\n        }\n        if (!view) {\n            throw new Error('unable to get block view for data');\n        }\n        return new rxjs_1.Observable((observer) => {\n            view.readWigData(chrName, start, end, observer, opts);\n        });\n    }\n    async getFeatures(refName, start, end, opts = {\n        scale: 1,\n    }) {\n        const ob = await this.getFeatureStream(refName, start, end, opts);\n        const ret = await ob\n            .pipe((0, operators_1.reduce)((acc, curr) => acc.concat(curr)))\n            .toPromise();\n        return ret || [];\n    }\n}\nexports.BBI = BBI;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BigBed = exports.filterUndef = void 0;\nconst binary_parser_1 = require(\"@gmod/binary-parser\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst abortable_promise_cache_1 = __importDefault(require(\"abortable-promise-cache\"));\nconst quick_lru_1 = __importDefault(require(\"quick-lru\"));\nconst bbi_1 = require(\"./bbi\");\nfunction filterUndef(ts) {\n    return ts.filter((t) => !!t);\n}\nexports.filterUndef = filterUndef;\nclass BigBed extends bbi_1.BBI {\n    constructor(opts) {\n        super(opts);\n        this.readIndicesCache = new abortable_promise_cache_1.default({\n            cache: new quick_lru_1.default({ maxSize: 1 }),\n            fill: async (args, signal) => {\n                return this._readIndices({ ...args, signal });\n            },\n        });\n    }\n    readIndices(opts = {}) {\n        const options = 'aborted' in opts ? { signal: opts } : opts;\n        return this.readIndicesCache.get(JSON.stringify(options), options, options.signal);\n    }\n    /*\n     * retrieve unzoomed view for any scale\n     * @param scale - unused\n     * @param abortSignal - an optional AbortSignal to kill operation\n     * @return promise for a BlockView\n     */\n    async getView(scale, opts) {\n        return this.getUnzoomedView(opts);\n    }\n    /*\n     * parse the bigbed extraIndex fields\n     * @param abortSignal to abort operation\n     * @return a Promise for an array of Index data structure since there can be multiple extraIndexes in a bigbed, see bedToBigBed documentation\n     */\n    async _readIndices(opts) {\n        const { extHeaderOffset, isBigEndian } = await this.getHeader(opts);\n        const { buffer: data } = await this.bbi.read(Buffer.alloc(64), 0, 64, extHeaderOffset);\n        const le = isBigEndian ? 'big' : 'little';\n        const ret = new binary_parser_1.Parser()\n            .endianess(le)\n            .uint16('size')\n            .uint16('count')\n            .uint64('offset')\n            .parse(data).result;\n        const { count, offset } = ret;\n        // no extra index is defined if count==0\n        if (count === 0) {\n            return [];\n        }\n        const blocklen = 20;\n        const len = blocklen * count;\n        const { buffer } = await this.bbi.read(Buffer.alloc(len), 0, len, offset);\n        const extParser = new binary_parser_1.Parser()\n            .endianess(le)\n            .int16('type')\n            .int16('fieldcount')\n            .uint64('offset')\n            .skip(4)\n            .int16('field');\n        const indices = [];\n        for (let i = 0; i < count; i += 1) {\n            indices.push(extParser.parse(buffer.slice(i * blocklen)).result);\n        }\n        return indices;\n    }\n    /*\n     * perform a search in the bigbed extraIndex to find which blocks in the bigbed data to look for the\n     * actual feature data\n     *\n     * @param name - the name to search for\n     * @param opts - a SearchOptions argument with optional signal\n     * @return a Promise for an array of bigbed block Loc entries\n     */\n    async searchExtraIndexBlocks(name, opts = {}) {\n        const { isBigEndian } = await this.getHeader(opts);\n        const indices = await this.readIndices(opts);\n        if (!indices.length) {\n            return [];\n        }\n        const locs = indices.map(async (index) => {\n            const { offset, field } = index;\n            const { buffer: data } = await this.bbi.read(Buffer.alloc(32), 0, 32, offset, opts);\n            const p = new binary_parser_1.Parser()\n                .endianess(isBigEndian ? 'big' : 'little')\n                .int32('magic')\n                .int32('blockSize')\n                .int32('keySize')\n                .int32('valSize')\n                .uint64('itemCount');\n            const { blockSize, keySize, valSize } = p.parse(data).result;\n            const bpt = new binary_parser_1.Parser()\n                .endianess(isBigEndian ? 'big' : 'little')\n                .int8('nodeType')\n                .skip(1)\n                .int16('cnt')\n                .choice({\n                tag: 'nodeType',\n                choices: {\n                    0: new binary_parser_1.Parser().array('leafkeys', {\n                        length: 'cnt',\n                        type: new binary_parser_1.Parser()\n                            .string('key', { length: keySize, stripNull: true })\n                            .uint64('offset'),\n                    }),\n                    1: new binary_parser_1.Parser().array('keys', {\n                        length: 'cnt',\n                        type: new binary_parser_1.Parser()\n                            .string('key', { length: keySize, stripNull: true })\n                            .uint64('offset')\n                            .uint32('length')\n                            .uint32('reserved'),\n                    }),\n                },\n            });\n            const bptReadNode = async (nodeOffset) => {\n                const len = 4 + blockSize * (keySize + valSize);\n                const { buffer } = await this.bbi.read(Buffer.alloc(len), 0, len, nodeOffset, opts);\n                const node = bpt.parse(buffer).result;\n                if (node.leafkeys) {\n                    let lastOffset;\n                    for (let i = 0; i < node.leafkeys.length; i += 1) {\n                        const { key } = node.leafkeys[i];\n                        if (name.localeCompare(key) < 0 && lastOffset) {\n                            return bptReadNode(lastOffset);\n                        }\n                        lastOffset = node.leafkeys[i].offset;\n                    }\n                    return bptReadNode(lastOffset);\n                }\n                for (let i = 0; i < node.keys.length; i += 1) {\n                    if (node.keys[i].key === name) {\n                        return { ...node.keys[i], field };\n                    }\n                }\n                return undefined;\n            };\n            const rootNodeOffset = 32;\n            return bptReadNode(offset + rootNodeOffset);\n        });\n        return filterUndef(await Promise.all(locs));\n    }\n    /*\n     * retrieve the features from the bigbed data that were found through the lookup of the extraIndex\n     * note that there can be multiple extraIndex, see the BigBed specification and the -extraIndex argument to bedToBigBed\n     *\n     * @param name - the name to search for\n     * @param opts - a SearchOptions argument with optional signal\n     * @return a Promise for an array of Feature\n     */\n    async searchExtraIndex(name, opts = {}) {\n        const blocks = await this.searchExtraIndexBlocks(name, opts);\n        if (!blocks.length) {\n            return [];\n        }\n        const view = await this.getUnzoomedView(opts);\n        const res = blocks.map(block => {\n            return new rxjs_1.Observable((observer) => {\n                view.readFeatures(observer, [block], opts);\n            }).pipe((0, operators_1.reduce)((acc, curr) => acc.concat(curr)), (0, operators_1.map)(x => {\n                for (let i = 0; i < x.length; i += 1) {\n                    x[i].field = block.field;\n                }\n                return x;\n            }));\n        });\n        const ret = await (0, rxjs_1.merge)(...res).toPromise();\n        return ret.filter((f) => {\n            return f.rest.split('\\t')[f.field - 3] === name;\n        });\n    }\n}\nexports.BigBed = BigBed;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BigWig = void 0;\nconst blockView_1 = require(\"./blockView\");\nconst bbi_1 = require(\"./bbi\");\nclass BigWig extends bbi_1.BBI {\n    /**\n     * Retrieves a BlockView of a specific zoomLevel\n     *\n     * @param refName - The chromosome name\n     * @param start - The start of a region\n     * @param end - The end of a region\n     * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use\n     */\n    async getView(scale, opts) {\n        const { zoomLevels, refsByName, fileSize, isBigEndian, uncompressBufSize } = await this.getHeader(opts);\n        const basesPerPx = 1 / scale;\n        let maxLevel = zoomLevels.length;\n        if (!fileSize) {\n            // if we don't know the file size, we can't fetch the highest zoom level :-(\n            maxLevel -= 1;\n        }\n        for (let i = maxLevel; i >= 0; i -= 1) {\n            const zh = zoomLevels[i];\n            if (zh && zh.reductionLevel <= 2 * basesPerPx) {\n                const indexLength = i < zoomLevels.length - 1\n                    ? zoomLevels[i + 1].dataOffset - zh.indexOffset\n                    : fileSize - 4 - zh.indexOffset;\n                return new blockView_1.BlockView(this.bbi, refsByName, zh.indexOffset, indexLength, isBigEndian, uncompressBufSize > 0, 'summary');\n            }\n        }\n        return this.getUnzoomedView(opts);\n    }\n}\nexports.BigWig = BigWig;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlockView = void 0;\nconst binary_parser_1 = require(\"@gmod/binary-parser\");\nconst abortable_promise_cache_1 = __importDefault(require(\"abortable-promise-cache\"));\nconst unzip_1 = require(\"./unzip\");\nconst quick_lru_1 = __importDefault(require(\"quick-lru\"));\nconst range_1 = __importDefault(require(\"./range\"));\nconst util_1 = require(\"./util\");\nconst BIG_WIG_TYPE_GRAPH = 1;\nconst BIG_WIG_TYPE_VSTEP = 2;\nconst BIG_WIG_TYPE_FSTEP = 3;\nfunction getParsers(isBigEndian) {\n    const le = isBigEndian ? 'big' : 'little';\n    const summaryParser = new binary_parser_1.Parser()\n        .endianess(le)\n        .uint32('chromId')\n        .uint32('start')\n        .uint32('end')\n        .uint32('validCnt')\n        .float('minScore')\n        .float('maxScore')\n        .float('sumData')\n        .float('sumSqData');\n    const leafParser = new binary_parser_1.Parser()\n        .endianess(le)\n        .uint8('isLeaf')\n        .skip(1)\n        .uint16('cnt')\n        .choice({\n        tag: 'isLeaf',\n        choices: {\n            1: new binary_parser_1.Parser().array('blocksToFetch', {\n                length: 'cnt',\n                type: new binary_parser_1.Parser()\n                    .uint32('startChrom')\n                    .uint32('startBase')\n                    .uint32('endChrom')\n                    .uint32('endBase')\n                    .uint64('blockOffset')\n                    .uint64('blockSize'),\n            }),\n            0: new binary_parser_1.Parser().array('recurOffsets', {\n                length: 'cnt',\n                type: new binary_parser_1.Parser()\n                    .uint32('startChrom')\n                    .uint32('startBase')\n                    .uint32('endChrom')\n                    .uint32('endBase')\n                    .uint64('blockOffset'),\n            }),\n        },\n    });\n    const bigBedParser = new binary_parser_1.Parser()\n        .endianess(le)\n        .uint32('chromId')\n        .int32('start')\n        .int32('end')\n        .string('rest', {\n        zeroTerminated: true,\n    });\n    const bigWigParser = new binary_parser_1.Parser()\n        .endianess(le)\n        .skip(4)\n        .int32('blockStart')\n        .skip(4)\n        .uint32('itemStep')\n        .uint32('itemSpan')\n        .uint8('blockType')\n        .skip(1)\n        .uint16('itemCount')\n        .choice({\n        tag: 'blockType',\n        choices: {\n            [BIG_WIG_TYPE_FSTEP]: new binary_parser_1.Parser().array('items', {\n                length: 'itemCount',\n                type: new binary_parser_1.Parser().float('score'),\n            }),\n            [BIG_WIG_TYPE_VSTEP]: new binary_parser_1.Parser().array('items', {\n                length: 'itemCount',\n                type: new binary_parser_1.Parser().int32('start').float('score'),\n            }),\n            [BIG_WIG_TYPE_GRAPH]: new binary_parser_1.Parser().array('items', {\n                length: 'itemCount',\n                type: new binary_parser_1.Parser().int32('start').int32('end').float('score'),\n            }),\n        },\n    });\n    return {\n        bigWigParser,\n        bigBedParser,\n        summaryParser,\n        leafParser,\n    };\n}\n/**\n * View into a subset of the data in a BigWig file.\n *\n * Adapted by Robert Buels and Colin Diesh from bigwig.js in the Dalliance Genome\n * Explorer by Thomas Down.\n * @constructs\n */\nclass BlockView {\n    constructor(bbi, refsByName, cirTreeOffset, cirTreeLength, isBigEndian, isCompressed, blockType) {\n        this.featureCache = new abortable_promise_cache_1.default({\n            cache: new quick_lru_1.default({ maxSize: 1000 }),\n            fill: async (requestData, signal) => {\n                const { length, offset } = requestData;\n                const { buffer } = await this.bbi.read(Buffer.alloc(length), 0, length, offset, { signal });\n                return buffer;\n            },\n        });\n        if (!(cirTreeOffset >= 0)) {\n            throw new Error('invalid cirTreeOffset!');\n        }\n        if (!(cirTreeLength > 0)) {\n            throw new Error('invalid cirTreeLength!');\n        }\n        this.cirTreeOffset = cirTreeOffset;\n        this.cirTreeLength = cirTreeLength;\n        this.isCompressed = isCompressed;\n        this.refsByName = refsByName;\n        this.isBigEndian = isBigEndian;\n        this.bbi = bbi;\n        this.blockType = blockType;\n        Object.assign(this, getParsers(isBigEndian));\n    }\n    async readWigData(chrName, start, end, observer, opts) {\n        try {\n            const { refsByName, bbi, cirTreeOffset, isBigEndian } = this;\n            const { signal } = opts;\n            const chrId = refsByName[chrName];\n            if (chrId === undefined) {\n                observer.complete();\n            }\n            const request = { chrId, start, end };\n            if (!this.cirTreePromise) {\n                this.cirTreePromise = bbi.read(Buffer.alloc(48), 0, 48, cirTreeOffset, {\n                    signal,\n                });\n            }\n            const { buffer } = await this.cirTreePromise;\n            const cirBlockSize = isBigEndian\n                ? buffer.readUInt32BE(4)\n                : buffer.readUInt32LE(4);\n            let blocksToFetch = [];\n            let outstanding = 0;\n            const cirFobRecur2 = (cirBlockData, offset, level) => {\n                try {\n                    const data = cirBlockData.slice(offset);\n                    const p = this.leafParser.parse(data).result;\n                    if (p.blocksToFetch) {\n                        blocksToFetch = blocksToFetch.concat(p.blocksToFetch.filter(filterFeats).map((l) => ({\n                            offset: l.blockOffset,\n                            length: l.blockSize,\n                        })));\n                    }\n                    if (p.recurOffsets) {\n                        const recurOffsets = p.recurOffsets\n                            .filter(filterFeats)\n                            .map((l) => l.blockOffset);\n                        if (recurOffsets.length > 0) {\n                            cirFobRecur(recurOffsets, level + 1);\n                        }\n                    }\n                }\n                catch (e) {\n                    observer.error(e);\n                }\n            };\n            const filterFeats = (b) => {\n                const { startChrom, startBase, endChrom, endBase } = b;\n                return ((startChrom < chrId || (startChrom === chrId && startBase <= end)) &&\n                    (endChrom > chrId || (endChrom === chrId && endBase >= start)));\n            };\n            const cirFobStartFetch = async (off, fr, level) => {\n                try {\n                    const length = fr.max() - fr.min();\n                    const offset = fr.min();\n                    const resultBuffer = await this.featureCache.get(`${length}_${offset}`, { length, offset }, signal);\n                    for (let i = 0; i < off.length; i += 1) {\n                        if (fr.contains(off[i])) {\n                            cirFobRecur2(resultBuffer, off[i] - offset, level);\n                            outstanding -= 1;\n                            if (outstanding === 0) {\n                                this.readFeatures(observer, blocksToFetch, { ...opts, request });\n                            }\n                        }\n                    }\n                }\n                catch (e) {\n                    observer.error(e);\n                }\n            };\n            const cirFobRecur = (offset, level) => {\n                try {\n                    outstanding += offset.length;\n                    const maxCirBlockSpan = 4 + cirBlockSize * 32; // Upper bound on size, based on a completely full leaf node.\n                    let spans = new range_1.default(offset[0], offset[0] + maxCirBlockSpan);\n                    for (let i = 1; i < offset.length; i += 1) {\n                        const blockSpan = new range_1.default(offset[i], offset[i] + maxCirBlockSpan);\n                        spans = spans.union(blockSpan);\n                    }\n                    spans.getRanges().map(fr => cirFobStartFetch(offset, fr, level));\n                }\n                catch (e) {\n                    observer.error(e);\n                }\n            };\n            return cirFobRecur([cirTreeOffset + 48], 1);\n        }\n        catch (e) {\n            observer.error(e);\n        }\n    }\n    parseSummaryBlock(data, startOffset, request) {\n        const features = [];\n        let currOffset = startOffset;\n        while (currOffset < data.byteLength) {\n            const res = this.summaryParser.parse(data.slice(currOffset));\n            features.push(res.result);\n            currOffset += res.offset;\n        }\n        let items = features;\n        if (request) {\n            items = items.filter(elt => elt.chromId === request.chrId);\n        }\n        const feats = items.map((elt) => ({\n            start: elt.start,\n            end: elt.end,\n            maxScore: elt.maxScore,\n            minScore: elt.minScore,\n            score: elt.sumData / (elt.validCnt || 1),\n            summary: true,\n        }));\n        return request\n            ? feats.filter(f => BlockView.coordFilter(f, request))\n            : feats;\n    }\n    parseBigBedBlock(data, startOffset, offset, request) {\n        const items = [];\n        let currOffset = startOffset;\n        while (currOffset < data.byteLength) {\n            const res = this.bigBedParser.parse(data.slice(currOffset));\n            res.result.uniqueId = `bb-${offset + currOffset}`;\n            items.push(res.result);\n            currOffset += res.offset;\n        }\n        return request\n            ? items.filter((f) => BlockView.coordFilter(f, request))\n            : items;\n    }\n    parseBigWigBlock(bytes, startOffset, request) {\n        const data = bytes.slice(startOffset);\n        const results = this.bigWigParser.parse(data).result;\n        const { items, itemSpan, itemStep, blockStart, blockType } = results;\n        if (blockType === BIG_WIG_TYPE_FSTEP) {\n            for (let i = 0; i < items.length; i++) {\n                items[i].start = blockStart + i * itemStep;\n                items[i].end = blockStart + i * itemStep + itemSpan;\n            }\n        }\n        else if (blockType === BIG_WIG_TYPE_VSTEP) {\n            for (let i = 0; i < items.length; i++) {\n                items[i].end = items[i].start + itemSpan;\n            }\n        }\n        return request\n            ? items.filter((f) => BlockView.coordFilter(f, request))\n            : items;\n    }\n    static coordFilter(f, range) {\n        return f.start < range.end && f.end >= range.start;\n    }\n    async readFeatures(observer, blocks, opts = {}) {\n        try {\n            const { blockType, isCompressed } = this;\n            const { signal, request } = opts;\n            const blockGroupsToFetch = (0, util_1.groupBlocks)(blocks);\n            (0, util_1.checkAbortSignal)(signal);\n            await Promise.all(blockGroupsToFetch.map(async (blockGroup) => {\n                (0, util_1.checkAbortSignal)(signal);\n                const { length, offset } = blockGroup;\n                const data = await this.featureCache.get(`${length}_${offset}`, blockGroup, signal);\n                blockGroup.blocks.forEach((block) => {\n                    (0, util_1.checkAbortSignal)(signal);\n                    let blockOffset = block.offset - blockGroup.offset;\n                    let resultData = data;\n                    if (isCompressed) {\n                        resultData = (0, unzip_1.unzip)(data.slice(blockOffset));\n                        blockOffset = 0;\n                    }\n                    (0, util_1.checkAbortSignal)(signal);\n                    switch (blockType) {\n                        case 'summary':\n                            observer.next(this.parseSummaryBlock(resultData, blockOffset, request));\n                            break;\n                        case 'bigwig':\n                            observer.next(this.parseBigWigBlock(resultData, blockOffset, request));\n                            break;\n                        case 'bigbed':\n                            observer.next(this.parseBigBedBlock(resultData, blockOffset, \n                            // eslint-disable-next-line no-bitwise\n                            block.offset * (1 << 8), request));\n                            break;\n                        default:\n                            console.warn(`Don't know what to do with ${blockType}`);\n                    }\n                });\n            }));\n            observer.complete();\n        }\n        catch (e) {\n            observer.error(e);\n        }\n    }\n}\nexports.BlockView = BlockView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BigBed = exports.BigWig = void 0;\nvar bigwig_1 = require(\"./bigwig\");\nObject.defineProperty(exports, \"BigWig\", { enumerable: true, get: function () { return bigwig_1.BigWig; } });\nvar bigbed_1 = require(\"./bigbed\");\nObject.defineProperty(exports, \"BigBed\", { enumerable: true, get: function () { return bigbed_1.BigBed; } });\n","\"use strict\";\n/* eslint prefer-rest-params:0, no-nested-ternary:0 */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Adapted from a combination of Range and _Compound in the\n * Dalliance Genome Explorer, (c) Thomas Down 2006-2010.\n */\nclass Range {\n    constructor(arg1, arg2) {\n        this.ranges =\n            arguments.length === 2\n                ? [{ min: arg1, max: arg2 }]\n                : 0 in arg1\n                    ? Object.assign({}, arg1)\n                    : [arg1];\n    }\n    min() {\n        return this.ranges[0].min;\n    }\n    max() {\n        return this.ranges[this.ranges.length - 1].max;\n    }\n    contains(pos) {\n        for (let s = 0; s < this.ranges.length; s += 1) {\n            const r = this.ranges[s];\n            if (r.min <= pos && r.max >= pos) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isContiguous() {\n        return this.ranges.length > 1;\n    }\n    getRanges() {\n        return this.ranges.map((r) => new Range(r.min, r.max));\n    }\n    toString() {\n        return this.ranges.map((r) => `[${r.min}-${r.max}]`).join(',');\n    }\n    union(s1) {\n        const ranges = this.getRanges().concat(s1.getRanges()).sort(this.rangeOrder);\n        const oranges = [];\n        let current = ranges[0];\n        for (let i = 1; i < ranges.length; i += 1) {\n            const nxt = ranges[i];\n            if (nxt.min() > current.max() + 1) {\n                oranges.push(current);\n                current = nxt;\n            }\n            else if (nxt.max() > current.max()) {\n                current = new Range(current.min(), nxt.max());\n            }\n        }\n        oranges.push(current);\n        if (oranges.length === 1) {\n            return oranges[0];\n        }\n        return new Range(oranges);\n    }\n    intersection(arg) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let s0 = this;\n        let s1 = arg;\n        const r0 = this.ranges();\n        const r1 = s1.ranges();\n        const l0 = r0.length;\n        const l1 = r1.length;\n        let i0 = 0;\n        let i1 = 0;\n        const or = [];\n        while (i0 < l0 && i1 < l1) {\n            s0 = r0[i0];\n            s1 = r1[i1];\n            const lapMin = Math.max(s0.min(), s1.min());\n            const lapMax = Math.min(s0.max(), s1.max());\n            if (lapMax >= lapMin) {\n                or.push(new Range(lapMin, lapMax));\n            }\n            if (s0.max() > s1.max()) {\n                i1 += 1;\n            }\n            else {\n                i0 += 1;\n            }\n        }\n        if (or.length === 0) {\n            throw new Error('found range of length 0');\n        }\n        if (or.length === 1) {\n            return or[0];\n        }\n        return new Range(or);\n    }\n    coverage() {\n        let tot = 0;\n        const rl = this.ranges();\n        for (let ri = 0; ri < rl.length; ri += 1) {\n            const r = rl[ri];\n            tot += r.max() - r.min() + 1;\n        }\n        return tot;\n    }\n    rangeOrder(tmpa, tmpb) {\n        let a = tmpa;\n        let b = tmpb;\n        if (arguments.length < 2) {\n            b = a;\n            a = this;\n        }\n        if (a.min() < b.min()) {\n            return -1;\n        }\n        if (a.min() > b.min()) {\n            return 1;\n        }\n        if (a.max() < b.max()) {\n            return -1;\n        }\n        if (b.max() > a.max()) {\n            return 1;\n        }\n        return 0;\n    }\n}\nexports.default = Range;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unzip = void 0;\nconst pako_1 = require(\"pako\");\nfunction unzip(input) {\n    return Buffer.from((0, pako_1.inflate)(input));\n}\nexports.unzip = unzip;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.abortBreakPoint = exports.checkAbortSignal = exports.groupBlocks = exports.AbortError = void 0;\n/* eslint no-bitwise: [\"error\", { \"allow\": [\"|\"] }] */\nclass AbortError extends Error {\n    constructor(message) {\n        super(message);\n        this.code = 'ERR_ABORTED';\n    }\n}\nexports.AbortError = AbortError;\n// sort blocks by file offset and\n// group blocks that are within 2KB of eachother\nfunction groupBlocks(blocks) {\n    blocks.sort((b0, b1) => (b0.offset | 0) - (b1.offset | 0));\n    const blockGroups = [];\n    let lastBlock;\n    let lastBlockEnd;\n    for (let i = 0; i < blocks.length; i += 1) {\n        if (lastBlock && blocks[i].offset - lastBlockEnd <= 2000) {\n            lastBlock.length += blocks[i].length - lastBlockEnd + blocks[i].offset;\n            lastBlock.blocks.push(blocks[i]);\n        }\n        else {\n            blockGroups.push((lastBlock = {\n                blocks: [blocks[i]],\n                length: blocks[i].length,\n                offset: blocks[i].offset,\n            }));\n        }\n        lastBlockEnd = lastBlock.offset + lastBlock.length;\n    }\n    return blockGroups;\n}\nexports.groupBlocks = groupBlocks;\n/**\n * Properly check if the given AbortSignal is aborted.\n * Per the standard, if the signal reads as aborted,\n * this function throws either a DOMException AbortError, or a regular error\n * with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nfunction checkAbortSignal(signal) {\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        // console.log('bam aborted!')\n        if (typeof DOMException !== 'undefined') {\n            throw new DOMException('aborted', 'AbortError');\n        }\n        else {\n            const e = new AbortError('aborted');\n            e.code = 'ERR_ABORTED';\n            throw e;\n        }\n    }\n}\nexports.checkAbortSignal = checkAbortSignal;\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nasync function abortBreakPoint(signal) {\n    await Promise.resolve();\n    checkAbortSignal(signal);\n}\nexports.abortBreakPoint = abortBreakPoint;\n","import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n\n  constructor(protected scheduler: AnimationFrameScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay: number = 0): any {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(\n      () => scheduler.flush(null)));\n  }\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue is empty, cancel the requested animation frame and\n    // set the scheduled flag to undefined so the next AnimationFrameAction will\n    // request its own.\n    if (scheduler.actions.length === 0) {\n      cancelAnimationFrame(id);\n      scheduler.scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n\n    this.active = true;\n    this.scheduled = undefined;\n\n    const {actions} = this;\n    let error: any;\n    let index: number = -1;\n    let count: number = actions.length;\n    action = action || actions.shift();\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (++index < count && (action = actions.shift()));\n\n    this.active = false;\n\n    if (error) {\n      while (++index < count && (action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n/**\n * @deprecated renamed. Use {@link animationFrameScheduler}\n */\nexport const animationFrame = animationFrameScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n\n  protected static frameTimeFactor: number = 10;\n\n  public frame: number = 0;\n  public index: number = -1;\n\n  constructor(SchedulerAction: typeof AsyncAction = VirtualAction as any,\n              public maxFrames: number = Number.POSITIVE_INFINITY) {\n    super(SchedulerAction, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   * @return {void}\n   */\n  public flush(): void {\n\n    const {actions, maxFrames} = this;\n    let error: any, action: AsyncAction<any>;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    }\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @nodoc\n */\nexport class VirtualAction<T> extends AsyncAction<T> {\n\n  protected active: boolean = true;\n\n  constructor(protected scheduler: VirtualTimeScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void,\n              protected index: number = scheduler.index += 1) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (!this.id) {\n      return super.schedule(state, delay);\n    }\n    this.active = false;\n    // If an action is rescheduled, we save allocations by mutating its state,\n    // pushing it to the end of the scheduler queue, and recycling the action.\n    // But since the VirtualTimeScheduler is used for testing, VirtualActions\n    // must be immutable so they can be inspected later.\n    const action = new VirtualAction(this.scheduler, this.work);\n    this.add(action);\n    return action.schedule(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\n    this.delay = scheduler.frame + delay;\n    const {actions} = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return true;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  public static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\n\n/**\n * Tests to see if the object is an RxJS {@link Observable}\n * @param obj the object to test\n */\nexport function isObservable<T>(obj: any): obj is Observable<T> {\n  return !!obj && (obj instanceof Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));\n}\n","import { SchedulerLike, SchedulerAction } from '../types';\nimport { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { Subscriber } from '../Subscriber';\nimport { map } from '../operators/map';\nimport { canReportError } from '../util/canReportError';\nimport { isArray } from '../util/isArray';\nimport { isScheduler } from '../util/isScheduler';\n\n// tslint:disable:max-line-length\n/** @deprecated resultSelector is no longer supported, use a mapping function. */\nexport function bindCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;\n\nexport function bindCallback<R1, R2, R3, R4>(callbackFunc: (callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): () => Observable<any[]>;\nexport function bindCallback<R1, R2, R3>(callbackFunc: (callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;\nexport function bindCallback<R1, R2>(callbackFunc: (callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;\nexport function bindCallback<R1>(callbackFunc: (callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;\nexport function bindCallback(callbackFunc: (callback: () => any) => any, scheduler?: SchedulerLike): () => Observable<void>;\n\nexport function bindCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<any[]>;\nexport function bindCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;\nexport function bindCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;\nexport function bindCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;\nexport function bindCallback<A1>(callbackFunc: (arg1: A1, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;\n\nexport function bindCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<any[]>;\nexport function bindCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;\nexport function bindCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;\nexport function bindCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;\nexport function bindCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;\n\nexport function bindCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<any[]>;\nexport function bindCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;\nexport function bindCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;\nexport function bindCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;\nexport function bindCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;\n\nexport function bindCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<any[]>;\nexport function bindCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;\nexport function bindCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;\nexport function bindCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;\nexport function bindCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;\n\nexport function bindCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<any[]>;\nexport function bindCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;\nexport function bindCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;\nexport function bindCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;\nexport function bindCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>;\n\nexport function bindCallback<A, R>(callbackFunc: (...args: Array<A | ((result: R) => any)>) => any, scheduler?: SchedulerLike): (...args: A[]) => Observable<R>;\nexport function bindCallback<A, R>(callbackFunc: (...args: Array<A | ((...results: R[]) => any)>) => any, scheduler?: SchedulerLike): (...args: A[]) => Observable<R[]>;\n\nexport function bindCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;\n\n// tslint:enable:max-line-length\n\n/**\n * Converts a callback API to a function that returns an Observable.\n *\n * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n * it will return a function `g` that when called as `g(x)` will output an\n * Observable.</span>\n *\n * `bindCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters. The\n * last parameter must be a callback function that `func` calls when it is\n * done.\n *\n * The output of `bindCallback` is a function that takes the same parameters\n * as `func`, except the last one (the callback). When the output function\n * is called with arguments it will return an Observable. If function `func`\n * calls its callback with one argument, the Observable will emit that value.\n * If on the other hand the callback is called with multiple values the resulting\n * Observable will emit an array with said values as arguments.\n *\n * It is **very important** to remember that input function `func` is not called\n * when the output function is, but rather when the Observable returned by the output\n * function is subscribed. This means if `func` makes an AJAX request, that request\n * will be made every time someone subscribes to the resulting Observable, but not before.\n *\n * The last optional parameter - `scheduler` - can be used to control when the call\n * to `func` happens after someone subscribes to Observable, as well as when results\n * passed to callback will be emitted. By default, the subscription to an Observable calls `func`\n * synchronously, but using {@link asyncScheduler} as the last parameter will defer the call to `func`,\n * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you were to use the async Scheduler\n * and call `subscribe` on the output Observable, all function calls that are currently executing\n * will end before `func` is invoked.\n *\n * By default, results passed to the callback are emitted immediately after `func` invokes the callback.\n * In particular, if the callback is called synchronously, then the subscription of the resulting Observable\n * will call the `next` function synchronously as well.  If you want to defer that call,\n * you may use {@link asyncScheduler} just as before.  This means that by using `Scheduler.async` you can\n * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n *\n * Note that the Observable created by the output function will always emit a single value\n * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n * calls will not appear in the stream. If you need to listen for multiple calls,\n *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n *\n * If `func` depends on some context (`this` property) and is not already bound, the context of `func`\n * will be the context that the output function has at call time. In particular, if `func`\n * is called as a method of some objec and if `func` is not already bound, in order to preserve the context\n * it is recommended that the context of the output function is set to that object as well.\n *\n * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n * provides convenient error handling and probably is a better choice.\n * `bindCallback` will treat such functions the same as any other and error parameters\n * (whether passed or not) will always be interpreted as regular callback argument.\n *\n * ## Examples\n *\n * ### Convert jQuery's getJSON to an Observable API\n * ```ts\n * import { bindCallback } from 'rxjs';\n * import * as jQuery from 'jquery';\n *\n * // Suppose we have jQuery.getJSON('/my/url', callback)\n * const getJSONAsObservable = bindCallback(jQuery.getJSON);\n * const result = getJSONAsObservable('/my/url');\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```\n *\n * ### Receive an array of arguments passed to a callback\n * ```ts\n * import { bindCallback } from 'rxjs';\n *\n * const someFunction = (a, b, c) => {\n *   console.log(a); // 5\n *   console.log(b); // 'some string'\n *   console.log(c); // {someProperty: 'someValue'}\n * };\n *\n * const boundSomeFunction = bindCallback(someFunction);\n * boundSomeFunction().subscribe(values => {\n *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\n * });\n * ```\n *\n * ### Compare behaviour with and without async Scheduler\n * ```ts\n * import { bindCallback } from 'rxjs';\n *\n * function iCallMyCallbackSynchronously(cb) {\n *   cb();\n * }\n *\n * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);\n * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n *\n * boundSyncFn().subscribe(() => console.log('I was sync!'));\n * boundAsyncFn().subscribe(() => console.log('I was async!'));\n * console.log('This happened...');\n *\n * // Logs:\n * // I was sync!\n * // This happened...\n * // I was async!\n * ```\n *\n * ### Use bindCallback on an object method\n * ```ts\n * import { bindCallback } from 'rxjs';\n *\n * const boundMethod = bindCallback(someObject.methodWithCallback);\n * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n * .subscribe(subscriber);\n * ```\n *\n * @see {@link bindNodeCallback}\n * @see {@link from}\n *\n * @param {function} func A function with a callback as the last parameter.\n * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the\n * callbacks.\n * @return {function(...params: *): Observable} A function which returns the\n * Observable that delivers the same values the callback would deliver.\n * @name bindCallback\n */\nexport function bindCallback<T>(\n  callbackFunc: Function,\n  resultSelector?: Function|SchedulerLike,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<T> {\n  if (resultSelector) {\n    if (isScheduler(resultSelector)) {\n      scheduler = resultSelector;\n    } else {\n      // DEPRECATED PATH\n      return (...args: any[]) => bindCallback(callbackFunc, scheduler)(...args).pipe(\n        map((args) => isArray(args) ? resultSelector(...args) : resultSelector(args)),\n      );\n    }\n  }\n\n  return function (this: any, ...args: any[]): Observable<T> {\n    const context = this;\n    let subject: AsyncSubject<T>;\n    const params = {\n      context,\n      subject,\n      callbackFunc,\n      scheduler,\n    };\n    return new Observable<T>(subscriber => {\n      if (!scheduler) {\n        if (!subject) {\n          subject = new AsyncSubject<T>();\n          const handler = (...innerArgs: any[]) => {\n            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n            subject.complete();\n          };\n\n          try {\n            callbackFunc.apply(context, [...args, handler]);\n          } catch (err) {\n            if (canReportError(subject)) {\n              subject.error(err);\n            } else {\n              console.warn(err);\n            }\n          }\n        }\n        return subject.subscribe(subscriber);\n      } else {\n        const state: DispatchState<T> = {\n          args, subscriber, params,\n        };\n        return scheduler.schedule<DispatchState<T>>(dispatch, 0, state);\n      }\n    });\n  };\n}\n\ninterface DispatchState<T> {\n  args: any[];\n  subscriber: Subscriber<T>;\n  params: ParamsContext<T>;\n}\n\ninterface ParamsContext<T> {\n  callbackFunc: Function;\n  scheduler: SchedulerLike;\n  context: any;\n  subject: AsyncSubject<T>;\n}\n\nfunction dispatch<T>(this: SchedulerAction<DispatchState<T>>, state: DispatchState<T>) {\n  const self = this;\n  const { args, subscriber, params } = state;\n  const { callbackFunc, context, scheduler } = params;\n  let { subject } = params;\n  if (!subject) {\n    subject = params.subject = new AsyncSubject<T>();\n\n    const handler = (...innerArgs: any[]) => {\n      const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n      this.add(scheduler.schedule<NextState<T>>(dispatchNext, 0, { value, subject }));\n    };\n\n    try {\n      callbackFunc.apply(context, [...args, handler]);\n    } catch (err) {\n      subject.error(err);\n    }\n  }\n\n  this.add(subject.subscribe(subscriber));\n}\n\ninterface NextState<T> {\n  subject: AsyncSubject<T>;\n  value: T;\n}\n\nfunction dispatchNext<T>(this: SchedulerAction<NextState<T>>, state: NextState<T>) {\n  const { value, subject } = state;\n  subject.next(value);\n  subject.complete();\n}\n\ninterface ErrorState<T> {\n  subject: AsyncSubject<T>;\n  err: any;\n}\n\nfunction dispatchError<T>(this: SchedulerAction<ErrorState<T>>, state: ErrorState<T>) {\n  const { err, subject } = state;\n  subject.error(err);\n}\n","import { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { Subscriber } from '../Subscriber';\nimport { SchedulerAction, SchedulerLike } from '../types';\nimport { map } from '../operators/map';\nimport { canReportError } from '../util/canReportError';\nimport { isScheduler } from '../util/isScheduler';\nimport { isArray } from '../util/isArray';\n\n/* tslint:disable:max-line-length */\n/** @deprecated resultSelector is deprecated, pipe to map instead */\nexport function bindNodeCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;\n\nexport function bindNodeCallback<R1, R2, R3, R4>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport function bindNodeCallback<R1, R2, R3>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;\nexport function bindNodeCallback<R1, R2>(callbackFunc: (callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;\nexport function bindNodeCallback<R1>(callbackFunc: (callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;\nexport function bindNodeCallback(callbackFunc: (callback: (err: any) => any) => any, scheduler?: SchedulerLike): () => Observable<void>;\n\nexport function bindNodeCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport function bindNodeCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;\nexport function bindNodeCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;\nexport function bindNodeCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;\nexport function bindNodeCallback<A1>(callbackFunc: (arg1: A1, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;\n\nexport function bindNodeCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport function bindNodeCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;\nexport function bindNodeCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;\nexport function bindNodeCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;\nexport function bindNodeCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;\n\nexport function bindNodeCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport function bindNodeCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;\nexport function bindNodeCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;\nexport function bindNodeCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;\nexport function bindNodeCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;\n\nexport function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;\nexport function bindNodeCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;\nexport function bindNodeCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;\nexport function bindNodeCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;\n\nexport function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;\nexport function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;\nexport function bindNodeCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;\nexport function bindNodeCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>; /* tslint:enable:max-line-length */\n\nexport function bindNodeCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\n/**\n * Converts a Node.js-style callback API to a function that returns an\n * Observable.\n *\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\n * callback is expected to be of type `callback(error, result)`.</span>\n *\n * `bindNodeCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters, but the\n * last parameter must be a callback function that `func` calls when it is\n * done. The callback function is expected to follow Node.js conventions,\n * where the first argument to the callback is an error object, signaling\n * whether call was successful. If that object is passed to callback, it means\n * something went wrong.\n *\n * The output of `bindNodeCallback` is a function that takes the same\n * parameters as `func`, except the last one (the callback). When the output\n * function is called with arguments, it will return an Observable.\n * If `func` calls its callback with error parameter present, Observable will\n * error with that value as well. If error parameter is not passed, Observable will emit\n * second parameter. If there are more parameters (third and so on),\n * Observable will emit an array with all arguments, except first error argument.\n *\n * Note that `func` will not be called at the same time output function is,\n * but rather whenever resulting Observable is subscribed. By default call to\n * `func` will happen synchronously after subscription, but that can be changed\n * with proper `scheduler` provided as optional third parameter. {@link SchedulerLike}\n * can also control when values from callback will be emitted by Observable.\n * To find out more, check out documentation for {@link bindCallback}, where\n * {@link SchedulerLike} works exactly the same.\n *\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n * of returned function, when it is called.\n *\n * After Observable emits value, it will complete immediately. This means\n * even if `func` calls callback again, values from second and consecutive\n * calls will never appear on the stream. If you need to handle functions\n * that call callbacks multiple times, check out {@link fromEvent} or\n * {@link fromEventPattern} instead.\n *\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n * \"Node.js-style\" callbacks are just a convention, so if you write for\n * browsers or any other environment and API you use implements that callback style,\n * `bindNodeCallback` can be safely used on that API functions as well.\n *\n * Remember that Error object passed to callback does not have to be an instance\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n * Error parameter of callback function is interpreted as \"present\", when value\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n * string or boolean `true`. In all of these cases resulting Observable would error\n * with that value. This means usually regular style callbacks will fail very often when\n * `bindNodeCallback` is used. If your Observable errors much more often then you\n * would expect, check if callback really is called in Node.js-style and, if not,\n * switch to {@link bindCallback} instead.\n *\n * Note that even if error parameter is technically present in callback, but its value\n * is falsy, it still won't appear in array emitted by Observable.\n *\n * ## Examples\n * ###  Read a file from the filesystem and get the data as an Observable\n * ```ts\n * import * as fs from 'fs';\n * const readFileAsObservable = bindNodeCallback(fs.readFile);\n * const result = readFileAsObservable('./roadNames.txt', 'utf8');\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```\n *\n * ### Use on function calling callback with multiple arguments\n * ```ts\n * someFunction((err, a, b) => {\n *   console.log(err); // null\n *   console.log(a); // 5\n *   console.log(b); // \"some string\"\n * });\n * const boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(value => {\n *   console.log(value); // [5, \"some string\"]\n * });\n * ```\n *\n * ### Use on function calling callback in regular style\n * ```ts\n * someFunction(a => {\n *   console.log(a); // 5\n * });\n * const boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(\n *   value => {}             // never gets called\n *   err => console.log(err) // 5\n * );\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link from}\n *\n * @param {function} func Function with a Node.js-style callback as the last parameter.\n * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the\n * callbacks.\n * @return {function(...params: *): Observable} A function which returns the\n * Observable that delivers the same values the Node.js callback would\n * deliver.\n * @name bindNodeCallback\n */\nexport function bindNodeCallback<T>(\n  callbackFunc: Function,\n  resultSelector: Function|SchedulerLike,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<T> {\n\n  if (resultSelector) {\n    if (isScheduler(resultSelector)) {\n      scheduler = resultSelector;\n    } else {\n      // DEPRECATED PATH\n      return (...args: any[]) => bindNodeCallback(callbackFunc, scheduler)(...args).pipe(\n        map(args => isArray(args) ? resultSelector(...args) : resultSelector(args))\n      );\n    }\n  }\n\n  return function(this: any, ...args: any[]): Observable<T> {\n    const params: ParamsState<T> = {\n      subject: undefined,\n      args,\n      callbackFunc,\n      scheduler,\n      context: this,\n    };\n    return new Observable<T>(subscriber => {\n      const { context } = params;\n      let { subject } = params;\n      if (!scheduler) {\n        if (!subject) {\n          subject = params.subject = new AsyncSubject<T>();\n          const handler = (...innerArgs: any[]) => {\n            const err = innerArgs.shift();\n\n            if (err) {\n              subject.error(err);\n              return;\n            }\n\n            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n            subject.complete();\n          };\n\n          try {\n            callbackFunc.apply(context, [...args, handler]);\n          } catch (err) {\n            if (canReportError(subject)) {\n              subject.error(err);\n            } else {\n              console.warn(err);\n            }\n          }\n        }\n        return subject.subscribe(subscriber);\n      } else {\n        return scheduler.schedule<DispatchState<T>>(dispatch, 0, { params, subscriber, context });\n      }\n    });\n  };\n}\n\ninterface DispatchState<T> {\n  subscriber: Subscriber<T>;\n  context: any;\n  params: ParamsState<T>;\n}\n\ninterface ParamsState<T> {\n  callbackFunc: Function;\n  args: any[];\n  scheduler: SchedulerLike;\n  subject: AsyncSubject<T>;\n  context: any;\n}\n\nfunction dispatch<T>(this: SchedulerAction<DispatchState<T>>, state: DispatchState<T>) {\n  const { params, subscriber, context } = state;\n  const { callbackFunc, args, scheduler } = params;\n  let subject = params.subject;\n\n  if (!subject) {\n    subject = params.subject = new AsyncSubject<T>();\n\n    const handler = (...innerArgs: any[]) => {\n      const err = innerArgs.shift();\n      if (err) {\n        this.add(scheduler.schedule<DispatchErrorArg<T>>(dispatchError, 0, { err, subject }));\n      } else {\n        const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n        this.add(scheduler.schedule<DispatchNextArg<T>>(dispatchNext, 0, { value, subject }));\n      }\n    };\n\n    try {\n      callbackFunc.apply(context, [...args, handler]);\n    } catch (err) {\n      this.add(scheduler.schedule<DispatchErrorArg<T>>(dispatchError, 0, { err, subject }));\n    }\n  }\n\n  this.add(subject.subscribe(subscriber));\n}\n\ninterface DispatchNextArg<T> {\n  subject: AsyncSubject<T>;\n  value: T;\n}\n\nfunction dispatchNext<T>(arg: DispatchNextArg<T>) {\n  const { value, subject } = arg;\n  subject.next(value);\n  subject.complete();\n}\n\ninterface DispatchErrorArg<T> {\n  subject: AsyncSubject<T>;\n  err: any;\n}\n\nfunction dispatchError<T>(arg: DispatchErrorArg<T>) {\n  const { err, subject } = arg;\n  subject.error(err);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, ObservedValuesFromArray, ObservedValueOf, SubscribableOrPromise } from '../types';\nimport { isArray } from '../util/isArray';\nimport { map } from '../operators/map';\nimport { isObject } from '../util/isObject';\nimport { isObservable } from '../util/isObservable';\nimport { from } from './from';\n\n/* tslint:disable:max-line-length */\n\n// forkJoin(a$, b$, c$)\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T>(v1: SubscribableOrPromise<T>): Observable<[T]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n\n// forkJoin([a$, b$, c$]);\n// TODO(benlesh): Uncomment for TS 3.0\n// export function forkJoin(sources: []): Observable<never>;\nexport function forkJoin<A>(sources: [ObservableInput<A>]): Observable<[A]>;\nexport function forkJoin<A, B>(sources: [ObservableInput<A>, ObservableInput<B>]): Observable<[A, B]>;\nexport function forkJoin<A, B, C>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>]): Observable<[A, B, C]>;\nexport function forkJoin<A, B, C, D>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>]): Observable<[A, B, C, D]>;\nexport function forkJoin<A, B, C, D, E>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>, ObservableInput<E>]): Observable<[A, B, C, D, E]>;\nexport function forkJoin<A, B, C, D, E, F>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>, ObservableInput<E>, ObservableInput<F>]): Observable<[A, B, C, D, E, F]>;\nexport function forkJoin<A extends ObservableInput<any>[]>(sources: A): Observable<ObservedValuesFromArray<A>[]>;\n\n// forkJoin({})\nexport function forkJoin(sourcesObject: {}): Observable<never>;\nexport function forkJoin<T, K extends keyof T>(sourcesObject: T): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/** @deprecated resultSelector is deprecated, pipe to map instead */\nexport function forkJoin(...args: Array<ObservableInput<any>|Function>): Observable<any>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T>(...sources: ObservableInput<T>[]): Observable<T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Accepts an `Array` of {@link ObservableInput} or a dictionary `Object` of {@link ObservableInput} and returns\n * an {@link Observable} that emits either an array of values in the exact same order as the passed array,\n * or a dictionary of values in the same shape as the passed dictionary.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n *\n * ![](forkJoin.png)\n *\n * `forkJoin` is an operator that takes any number of input observables which can be passed either as an array\n * or a dictionary of input observables. If no input observables are provided, resulting stream will complete\n * immediately.\n *\n * `forkJoin` will wait for all passed observables to complete and then it will emit an array or an object with last\n * values from corresponding observables.\n *\n * If you pass an array of `n` observables to the operator, resulting\n * array will have `n` values, where first value is the last thing emitted by the first observable,\n * second value is the last thing emitted by the second observable and so on.\n *\n * If you pass a dictionary of observables to the operator, resulting\n * objects will have the same keys as the dictionary passed, with their last values they've emitted\n * located at the corresponding key.\n *\n * That means `forkJoin` will not emit more than once and it will complete after that. If you need to emit combined\n * values not only at the end of lifecycle of passed observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for resulting array to have the same length as the number of input observables, whenever any of\n * that observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other observables.\n * Conversely, if there is an observable that never completes, `forkJoin` will never complete as well,\n * unless at any point some other observable completes without emitting value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all observables passed as arguments\n * have to emit something at least once and complete.\n *\n * If any input observable errors at some point, `forkJoin` will error as well and all other observables\n * will be immediately unsubscribed.\n *\n * Optionally `forkJoin` accepts project function, that will be called with values which normally\n * would land in emitted array. Whatever is returned by project function, will appear in output\n * observable instead. This means that default project can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that project function will be called only\n * when output observable is supposed to emit a result.\n *\n * ## Examples\n *\n * ### Use forkJoin with a dictionary of observable inputs\n * ```ts\n * import { forkJoin, of, timer } from 'rxjs';\n *\n * const observable = forkJoin({\n *   foo: of(1, 2, 3, 4),\n *   bar: Promise.resolve(8),\n *   baz: timer(4000),\n * });\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // { foo: 4, bar: 8, baz: 0 } after 4 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * ### Use forkJoin with an array of observable inputs\n * ```ts\n * import { forkJoin, of } from 'rxjs';\n *\n * const observable = forkJoin([\n *   of(1, 2, 3, 4),\n *   Promise.resolve(8),\n *   timer(4000),\n * ]);\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // [4, 8, 0] after 4 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments\n * passed directly to the operator.\n * @param {function} [project] Function that takes values emitted by input Observables and returns value\n * that will appear in resulting Observable instead of default array.\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\nexport function forkJoin(\n  ...sources: any[]\n): Observable<any> {\n  if (sources.length === 1) {\n    const first = sources[0];\n    if (isArray(first)) {\n      return forkJoinInternal(first, null);\n    }\n    // TODO(benlesh): isObservable check will not be necessary when deprecated path is removed.\n    if (isObject(first) && Object.getPrototypeOf(first) === Object.prototype) {\n      const keys = Object.keys(first);\n      return forkJoinInternal(keys.map(key => first[key]), keys);\n    }\n  }\n\n  // DEPRECATED PATHS BELOW HERE\n  if (typeof sources[sources.length - 1] === 'function') {\n    const resultSelector = sources.pop() as Function;\n    sources = (sources.length === 1 && isArray(sources[0])) ? sources[0] : sources;\n    return forkJoinInternal(sources, null).pipe(\n      map((args: any[]) => resultSelector(...args))\n    );\n  }\n\n  return forkJoinInternal(sources, null);\n}\n\nfunction forkJoinInternal(sources: ObservableInput<any>[], keys: string[] | null): Observable<any> {\n  return new Observable(subscriber => {\n    const len = sources.length;\n    if (len === 0) {\n      subscriber.complete();\n      return;\n    }\n    const values = new Array(len);\n    let completed = 0;\n    let emitted = 0;\n    for (let i = 0; i < len; i++) {\n      const source = from(sources[i]);\n      let hasValue = false;\n      subscriber.add(source.subscribe({\n        next: value => {\n          if (!hasValue) {\n            hasValue = true;\n            emitted++;\n          }\n          values[i] = value;\n        },\n        error: err => subscriber.error(err),\n        complete: () => {\n          completed++;\n          if (completed === len || !hasValue) {\n            if (emitted === len) {\n              subscriber.next(keys ?\n                keys.reduce((result, key, i) => (result[key] = values[i], result), {}) :\n                values);\n            }\n            subscriber.complete();\n          }\n        }\n      }));\n    }\n  });\n}\n","import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { isFunction } from '../util/isFunction';\nimport { NodeEventHandler } from './fromEvent';\nimport { map } from '../operators/map';\n\n/* tslint:disable:max-line-length */\nexport function fromEventPattern<T>(addHandler: (handler: NodeEventHandler) => any, removeHandler?: (handler: NodeEventHandler, signal?: any) => void): Observable<T>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function fromEventPattern<T>(addHandler: (handler: NodeEventHandler) => any, removeHandler?: (handler: NodeEventHandler, signal?: any) => void, resultSelector?: (...args: any[]) => T): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an Observable from an arbitrary API for registering event handlers.\n *\n * <span class=\"informal\">When that method for adding event handler was something {@link fromEvent}\n * was not prepared for.</span>\n *\n * ![](fromEventPattern.png)\n *\n * `fromEventPattern` allows you to convert into an Observable any API that supports registering handler functions\n * for events. It is similar to {@link fromEvent}, but far\n * more flexible. In fact, all use cases of {@link fromEvent} could be easily handled by\n * `fromEventPattern` (although in slightly more verbose way).\n *\n * This operator accepts as a first argument an `addHandler` function, which will be injected with\n * handler parameter. That handler is actually an event handler function that you now can pass\n * to API expecting it. `addHandler` will be called whenever Observable\n * returned by the operator is subscribed, so registering handler in API will not\n * necessarily happen when `fromEventPattern` is called.\n *\n * After registration, every time an event that we listen to happens,\n * Observable returned by `fromEventPattern` will emit value that event handler\n * function was called with. Note that if event handler was called with more\n * then one argument, second and following arguments will not appear in the Observable.\n *\n * If API you are using allows to unregister event handlers as well, you can pass to `fromEventPattern`\n * another function - `removeHandler` - as a second parameter. It will be injected\n * with the same handler function as before, which now you can use to unregister\n * it from the API. `removeHandler` will be called when consumer of resulting Observable\n * unsubscribes from it.\n *\n * In some APIs unregistering is actually handled differently. Method registering an event handler\n * returns some kind of token, which is later used to identify which function should\n * be unregistered or it itself has method that unregisters event handler.\n * If that is the case with your API, make sure token returned\n * by registering method is returned by `addHandler`. Then it will be passed\n * as a second argument to `removeHandler`, where you will be able to use it.\n *\n * If you need access to all event handler parameters (not only the first one),\n * or you need to transform them in any way, you can call `fromEventPattern` with optional\n * third parameter - project function which will accept all arguments passed to\n * event handler when it is called. Whatever is returned from project function will appear on\n * resulting stream instead of usual event handlers first argument. This means\n * that default project can be thought of as function that takes its first parameter\n * and ignores the rest.\n *\n * ## Example\n * ### Emits clicks happening on the DOM document\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * function addClickHandler(handler) {\n *   document.addEventListener('click', handler);\n * }\n *\n * function removeClickHandler(handler) {\n *   document.removeEventListener('click', handler);\n * }\n *\n * const clicks = fromEventPattern(\n *   addClickHandler,\n *   removeClickHandler\n * );\n * clicks.subscribe(x => console.log(x));\n *\n * // Whenever you click anywhere in the browser, DOM MouseEvent\n * // object will be logged.\n * ```\n *\n * ## Example\n * ### Use with API that returns cancellation token\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * const token = someAPI.registerEventHandler(function() {});\n * someAPI.unregisterEventHandler(token); // this APIs cancellation method accepts\n *                                        // not handler itself, but special token.\n *\n * const someAPIObservable = fromEventPattern(\n *   function(handler) { return someAPI.registerEventHandler(handler); }, // Note that we return the token here...\n *   function(handler, token) { someAPI.unregisterEventHandler(token); }  // ...to then use it here.\n * );\n * ```\n *\n * ## Example\n * ### Use with project function\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * someAPI.registerEventHandler((eventType, eventMessage) => {\n *   console.log(eventType, eventMessage); // Logs \"EVENT_TYPE\" \"EVENT_MESSAGE\" to console.\n * });\n *\n * const someAPIObservable = fromEventPattern(\n *   handler => someAPI.registerEventHandler(handler),\n *   handler => someAPI.unregisterEventHandler(handler)\n *   (eventType, eventMessage) => eventType + \" --- \" + eventMessage // without that function only \"EVENT_TYPE\"\n * );                                                                // would be emitted by the Observable\n *\n * someAPIObservable.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"EVENT_TYPE --- EVENT_MESSAGE\"\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n *\n * @param {function(handler: Function): any} addHandler A function that takes\n * a `handler` function as argument and attaches it somehow to the actual\n * source of events.\n * @param {function(handler: Function, token?: any): void} [removeHandler] A function that\n * takes a `handler` function as an argument and removes it from the event source. If `addHandler`\n * returns some kind of token, `removeHandler` function will have it as a second parameter.\n * @param {function(...args: any): T} [project] A function to\n * transform results. It takes the arguments from the event handler and\n * should return a single value.\n * @return {Observable<T>} Observable which, when an event happens, emits first parameter\n * passed to registered event handler. Alternatively it emits whatever project function returns\n * at that moment.\n * @static true\n * @name fromEventPattern\n * @owner Observable\n */\n\nexport function fromEventPattern<T>(addHandler: (handler: NodeEventHandler) => any,\n                                    removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\n                                    resultSelector?: (...args: any[]) => T): Observable<T | T[]> {\n\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return fromEventPattern<T>(addHandler, removeHandler).pipe(\n      map(args => isArray(args) ? resultSelector(...args) : resultSelector(args))\n    );\n  }\n\n  return new Observable<T | T[]>(subscriber => {\n    const handler = (...e: T[]) => subscriber.next(e.length === 1 ? e[0] : e);\n\n    let retValue: any;\n    try {\n      retValue = addHandler(handler);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n\n    if (!isFunction(removeHandler)) {\n      return undefined;\n    }\n\n    return () => removeHandler(handler, retValue) ;\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { identity } from '../util/identity';\nimport { SchedulerAction, SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\n\nexport type ConditionFunc<S> = (state: S) => boolean;\nexport type IterateFunc<S> = (state: S) => S;\nexport type ResultFunc<S, T> = (state: S) => T;\n\ninterface SchedulerState<T, S> {\n  needIterate?: boolean;\n  state: S;\n  subscriber: Subscriber<T>;\n  condition?: ConditionFunc<S>;\n  iterate: IterateFunc<S>;\n  resultSelector: ResultFunc<S, T>;\n}\n\nexport interface GenerateBaseOptions<S> {\n  /**\n   * Initial state.\n   */\n  initialState: S;\n  /**\n   * Condition function that accepts state and returns boolean.\n   * When it returns false, the generator stops.\n   * If not specified, a generator never stops.\n   */\n  condition?: ConditionFunc<S>;\n  /**\n   * Iterate function that accepts state and returns new state.\n   */\n  iterate: IterateFunc<S>;\n  /**\n   * SchedulerLike to use for generation process.\n   * By default, a generator starts immediately.\n   */\n  scheduler?: SchedulerLike;\n}\n\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\n  /**\n   * Result selection function that accepts state and returns a value to emit.\n   */\n  resultSelector: ResultFunc<S, T>;\n}\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate(0, x => x < 10, x => x + 1, x => x);\n *\n * @example <caption>Using asap scheduler, produces sequence of 2, 3, 5, then completes.</caption>\n * const res = generate(1, x => x < 5, x => x * 2, x => x + 1, asap);\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence. (deprecated)\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} on which to run the generator loop. If not provided, defaults to emit immediately.\n * @returns {Observable<T>} The generated sequence.\n */\n  export function generate<T, S>(initialState: S,\n                                 condition: ConditionFunc<S>,\n                                 iterate: IterateFunc<S>,\n                                 resultSelector: ResultFunc<S, T>,\n                                 scheduler?: SchedulerLike): Observable<T>;\n\n/**\n * Generates an Observable by running a state-driven loop\n * that emits an element on each iteration.\n *\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\n *\n * <img src=\"./img/generate.png\" width=\"100%\">\n *\n * `generate` allows you to create stream of values generated with a loop very similar to\n * traditional for loop. First argument of `generate` is a beginning value. Second argument\n * is a function that accepts this value and tests if some condition still holds. If it does,\n * loop continues, if not, it stops. Third value is a function which takes previously defined\n * value and modifies it in some way on each iteration. Note how these three parameters\n * are direct equivalents of three expressions in regular for loop: first expression\n * initializes some state (for example numeric index), second tests if loop can make next\n * iteration (for example if index is lower than 10) and third states how defined value\n * will be modified on every step (index will be incremented by one).\n *\n * Return value of a `generate` operator is an Observable that on each loop iteration\n * emits a value. First, condition function is ran. If it returned true, Observable\n * emits currently stored value (initial value at the first iteration) and then updates\n * that value with iterate function. If at some point condition returned false, Observable\n * completes at that moment.\n *\n * Optionally you can pass fourth parameter to `generate` - a result selector function which allows you\n * to immediately map value that would normally be emitted by an Observable.\n *\n * If you find three anonymous functions in `generate` call hard to read, you can provide\n * single object to the operator instead. That object has properties: `initialState`,\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\n * condition always holds, so output Observable will never complete.\n *\n * Both forms of `generate` can optionally accept a scheduler. In case of multi-parameter call,\n * scheduler simply comes as a last argument (no matter if there is resultSelector\n * function or not). In case of single-parameter call, you can provide it as a\n * `scheduler` property on object passed to the operator. In both cases scheduler decides when\n * next iteration of the loop will happen and therefore when next value will be emitted\n * by the Observable. For example to ensure that each value is pushed to the observer\n * on separate task in event loop, you could use `async` scheduler. Note that\n * by default (when no scheduler is passed) values are simply emitted synchronously.\n *\n *\n * @example <caption>Use with condition and iterate functions.</caption>\n * const generated = generate(0, x => x < 3, x => x + 1);\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // \"Yo!\"\n *\n *\n * @example <caption>Use with condition, iterate and resultSelector functions.</caption>\n * const generated = generate(0, x => x < 3, x => x + 1, x => x * 1000);\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // \"Yo!\"\n *\n *\n * @example <caption>Use with options object.</caption>\n * const generated = generate({\n *   initialState: 0,\n *   condition(value) { return value < 3; },\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // \"Yo!\"\n *\n * @example <caption>Use options object without condition function.</caption>\n * const generated = generate({\n *   initialState: 0,\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!') // This will never run.\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 3000\n * // ...and never stops.\n *\n *\n * @see {@link from}\n * @see {@link index/Observable.create}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence.\n * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emitting immediately.\n * @return {Observable<T>} The generated sequence.\n */\nexport function generate<S>(initialState: S,\n                            condition: ConditionFunc<S>,\n                            iterate: IterateFunc<S>,\n                            scheduler?: SchedulerLike): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition and scheduler.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate({\n *   initialState: 0,\n *   condition: x => x < 10,\n *   iterate: x => x + 1,\n * });\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.\n * @returns {Observable<S>} The generated sequence.\n */\nexport function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition, result selector and scheduler.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate({\n *   initialState: 0,\n *   condition: x => x < 10,\n *   iterate: x => x + 1,\n *   resultSelector: x => x,\n * });\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\n * @returns {Observable<T>} The generated sequence.\n */\nexport function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\n\nexport function generate<T, S>(initialStateOrOptions: S | GenerateOptions<T, S>,\n                               condition?: ConditionFunc<S>,\n                               iterate?: IterateFunc<S>,\n                               resultSelectorOrObservable?: (ResultFunc<S, T>) | SchedulerLike,\n                               scheduler?: SchedulerLike): Observable<T> {\n\n  let resultSelector: ResultFunc<S, T>;\n  let initialState: S;\n\n  if (arguments.length == 1) {\n    const options = initialStateOrOptions as GenerateOptions<T, S>;\n    initialState = options.initialState;\n    condition = options.condition;\n    iterate = options.iterate;\n    resultSelector = options.resultSelector || identity as ResultFunc<S, T>;\n    scheduler = options.scheduler;\n  } else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n    initialState = initialStateOrOptions as S;\n    resultSelector = identity as ResultFunc<S, T>;\n    scheduler = resultSelectorOrObservable as SchedulerLike;\n  } else {\n    initialState = initialStateOrOptions as S;\n    resultSelector = resultSelectorOrObservable as ResultFunc<S, T>;\n  }\n\n  return new Observable<T>(subscriber => {\n    let state = initialState;\n    if (scheduler) {\n      return scheduler.schedule<SchedulerState<T, S>>(dispatch, 0, {\n        subscriber,\n        iterate,\n        condition,\n        resultSelector,\n        state\n      });\n    }\n\n    do {\n      if (condition) {\n        let conditionResult: boolean;\n        try {\n          conditionResult = condition(state);\n        } catch (err) {\n          subscriber.error(err);\n          return undefined;\n        }\n        if (!conditionResult) {\n          subscriber.complete();\n          break;\n        }\n      }\n      let value: T;\n      try {\n        value = resultSelector(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n      subscriber.next(value);\n      if (subscriber.closed) {\n        break;\n      }\n      try {\n        state = iterate(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n    } while (true);\n\n    return undefined;\n  });\n}\n\nfunction dispatch<T, S>(this: SchedulerAction<SchedulerState<T, S>>, state: SchedulerState<T, S>) {\n  const { subscriber, condition } = state;\n  if (subscriber.closed) {\n    return undefined;\n  }\n  if (state.needIterate) {\n    try {\n      state.state = state.iterate(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n  } else {\n    state.needIterate = true;\n  }\n  if (condition) {\n    let conditionResult: boolean;\n    try {\n      conditionResult = condition(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n    if (!conditionResult) {\n      subscriber.complete();\n      return undefined;\n    }\n    if (subscriber.closed) {\n      return undefined;\n    }\n  }\n  let value: T;\n  try {\n    value = state.resultSelector(state.state);\n  } catch (err) {\n    subscriber.error(err);\n    return undefined;\n  }\n  if (subscriber.closed) {\n    return undefined;\n  }\n  subscriber.next(value);\n  if (subscriber.closed) {\n    return undefined;\n  }\n  return this.schedule(state);\n}\n","import { Observable } from '../Observable';\nimport { defer } from './defer';\nimport { EMPTY } from './empty';\nimport { SubscribableOrPromise } from '../types';\n\n/**\n * Decides at subscription time which Observable will actually be subscribed.\n *\n * <span class=\"informal\">`If` statement for Observables.</span>\n *\n * `iif` accepts a condition function and two Observables. When\n * an Observable returned by the operator is subscribed, condition function will be called.\n * Based on what boolean it returns at that moment, consumer will subscribe either to\n * the first Observable (if condition was true) or to the second (if condition was false). Condition\n * function may also not return anything - in that case condition will be evaluated as false and\n * second Observable will be subscribed.\n *\n * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that\n * was left undefined, resulting stream will simply complete immediately. That allows you to, rather\n * than controlling which Observable will be subscribed, decide at runtime if consumer should have access\n * to given Observable or not.\n *\n * If you have more complex logic that requires decision between more than two Observables, {@link defer}\n * will probably be a better choice. Actually `iif` can be easily implemented with {@link defer}\n * and exists only for convenience and readability reasons.\n *\n *\n * ## Examples\n * ### Change at runtime which Observable will be subscribed\n * ```ts\n * import { iif, of } from 'rxjs';\n *\n * let subscribeToFirst;\n * const firstOrSecond = iif(\n *   () => subscribeToFirst,\n *   of('first'),\n *   of('second'),\n * );\n *\n * subscribeToFirst = true;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"first\"\n *\n * subscribeToFirst = false;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"second\"\n *\n * ```\n *\n * ### Control an access to an Observable\n * ```ts\n * let accessGranted;\n * const observableIfYouHaveAccess = iif(\n *   () => accessGranted,\n *   of('It seems you have an access...'), // Note that only one Observable is passed to the operator.\n * );\n *\n * accessGranted = true;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end'),\n * );\n *\n * // Logs:\n * // \"It seems you have an access...\"\n * // \"The end\"\n *\n * accessGranted = false;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end'),\n * );\n *\n * // Logs:\n * // \"The end\"\n * ```\n *\n * @see {@link defer}\n *\n * @param {function(): boolean} condition Condition which Observable should be chosen.\n * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.\n * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.\n * @return {Observable} Either first or second Observable, depending on condition.\n * @static true\n * @name iif\n * @owner Observable\n*/\nexport function iif<T = never, F = never>(\n  condition: () => boolean,\n  trueResult: SubscribableOrPromise<T> = EMPTY,\n  falseResult: SubscribableOrPromise<F> = EMPTY\n): Observable<T|F> {\n  return defer(() => condition() ? trueResult : falseResult);\n}\n","import { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { SchedulerAction, SchedulerLike } from '../types';\nimport { isNumeric } from '../util/isNumeric';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * Creates an Observable that emits sequential numbers every specified\n * interval of time, on a specified {@link SchedulerLike}.\n *\n * <span class=\"informal\">Emits incremental numbers periodically in time.\n * </span>\n *\n * ![](interval.png)\n *\n * `interval` returns an Observable that emits an infinite sequence of\n * ascending integers, with a constant interval of time of your choosing\n * between those emissions. The first emission is not sent immediately, but\n * only after the first period has passed. By default, this operator uses the\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\n * {@link SchedulerLike} to it.\n *\n * ## Example\n * Emits ascending numbers, one every second (1000ms) up to the number 3\n * ```ts\n * import { interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const numbers = interval(1000);\n *\n * const takeFourNumbers = numbers.pipe(take(4));\n *\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\n *\n * // Logs:\n * // Next: 0\n * // Next: 1\n * // Next: 2\n * // Next: 3\n * ```\n *\n * @see {@link timer}\n * @see {@link delay}\n *\n * @param {number} [period=0] The interval size in milliseconds (by default)\n * or the time unit determined by the scheduler's clock.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a sequential number each time\n * interval.\n * @static true\n * @name interval\n * @owner Observable\n */\nexport function interval(period = 0,\n                         scheduler: SchedulerLike = async): Observable<number> {\n  if (!isNumeric(period) || period < 0) {\n    period = 0;\n  }\n\n  if (!scheduler || typeof scheduler.schedule !== 'function') {\n    scheduler = async;\n  }\n\n  return new Observable<number>(subscriber => {\n    subscriber.add(\n      scheduler.schedule(dispatch, period, { subscriber, counter: 0, period })\n    );\n    return subscriber;\n  });\n}\n\nfunction dispatch(this: SchedulerAction<IntervalState>, state: IntervalState) {\n  const { subscriber, counter, period } = state;\n  subscriber.next(counter);\n  this.schedule({ subscriber, counter: counter + 1, period }, period);\n}\n\ninterface IntervalState {\n  subscriber: Subscriber<number>;\n  counter: number;\n  period: number;\n}\n","import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n * ### Emit the number 7, then never emit anything else (not even complete)\n * ```ts\n * import { NEVER } from 'rxjs';\n * import { startWith } from 'rxjs/operators';\n *\n * function info() {\n *   console.log('Will not be called');\n * }\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe(x => console.log(x), info, info);\n *\n * ```\n *\n * @see {@link Observable}\n * @see {@link index/EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Deprecated in favor of using {@link NEVER} constant.\n */\nexport function never () {\n  return NEVER;\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\nimport { from } from './from';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNext<R>(v: ObservableInput<R>): Observable<R>;\nexport function onErrorResumeNext<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\nexport function onErrorResumeNext<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\nexport function onErrorResumeNext<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\nexport function onErrorResumeNext<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\n\nexport function onErrorResumeNext<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport function onErrorResumeNext<R>(array: ObservableInput<any>[]): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` Will subscribe to each observable source it is provided, in order.\n * If the source it's subscribed to emits an error or completes, it will move to the next source\n * without error.\n *\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link index/EMPTY}.\n *\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\n * sources emits an error.\n *\n * Note that there is no way to handle any errors thrown by sources via the result of\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\n *\n * ## Example\n * Subscribe to the next Observable after map fails</caption>\n * ```ts\n * import { onErrorResumeNext, of } from 'rxjs';\n * import { map } from 'rxjs/operators';\n *\n * onErrorResumeNext(\n *  of(1, 2, 3, 0).pipe(\n *    map(x => {\n *      if (x === 0) throw Error();\n *      return 10 / x;\n *    })\n *  ),\n *  of(1, 2, 3),\n * )\n * .subscribe(\n *   val => console.log(val),\n *   err => console.log(err),          // Will never be called.\n *   () => console.log('done'),\n * );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"done\"\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.\n * @return {Observable} An Observable that concatenates all sources, one after the other,\n * ignoring all errors, such that any error causes it to move on to the next source.\n */\nexport function onErrorResumeNext<T, R>(...sources: Array<ObservableInput<any> |\n                                                              Array<ObservableInput<any>> |\n                                                              ((...values: Array<any>) => R)>): Observable<R> {\n\n  if (sources.length === 0) {\n    return EMPTY;\n  }\n\n  const [ first, ...remainder ] = sources;\n\n  if (sources.length === 1 && isArray(first)) {\n    return onErrorResumeNext(...first);\n  }\n\n  return new Observable(subscriber => {\n    const subNext = () => subscriber.add(\n      onErrorResumeNext(...remainder).subscribe(subscriber)\n    );\n\n    return from(first).subscribe({\n      next(value) { subscriber.next(value); },\n      error: subNext,\n      complete: subNext,\n    });\n  });\n}\n","import { Observable } from '../Observable';\nimport { SchedulerAction, SchedulerLike } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n\n/**\n * Convert an object into an Observable of `[key, value]` pairs.\n *\n * <span class=\"informal\">Turn entries of an object into a stream.</span>\n *\n * <img src=\"./img/pairs.png\" width=\"100%\">\n *\n * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each\n * emitted array has exactly two elements - the first is a key from the object\n * and the second is a value corresponding to that key. Keys are extracted from\n * an object via `Object.keys` function, which means that they will be only\n * enumerable keys that are present on an object directly - not ones inherited\n * via prototype chain.\n *\n * By default these arrays are emitted synchronously. To change that you can\n * pass a {@link SchedulerLike} as a second argument to `pairs`.\n *\n * @example <caption>Converts a javascript object to an Observable</caption>\n * ```ts\n * import { pairs } from 'rxjs';\n *\n * const obj = {\n *   foo: 42,\n *   bar: 56,\n *   baz: 78\n * };\n *\n * pairs(obj)\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n *\n * // Logs:\n * // [\"foo\", 42],\n * // [\"bar\", 56],\n * // [\"baz\", 78],\n * // \"the end!\"\n * ```\n *\n * @param {Object} obj The object to inspect and turn into an\n * Observable sequence.\n * @param {Scheduler} [scheduler] An optional IScheduler to schedule\n * when resulting Observable will emit values.\n * @returns {(Observable<Array<string|T>>)} An observable sequence of\n * [key, value] pairs from the object.\n */\nexport function pairs<T>(obj: Object, scheduler?: SchedulerLike): Observable<[string, T]> {\n  if (!scheduler) {\n    return new Observable<[string, T]>(subscriber => {\n      const keys = Object.keys(obj);\n      for (let i = 0; i < keys.length && !subscriber.closed; i++) {\n        const key = keys[i];\n        if (obj.hasOwnProperty(key)) {\n          subscriber.next([key, obj[key]]);\n        }\n      }\n      subscriber.complete();\n    });\n  } else {\n    return new Observable<[string, T]>(subscriber => {\n      const keys = Object.keys(obj);\n      const subscription = new Subscription();\n      subscription.add(\n        scheduler.schedule<{ keys: string[], index: number, subscriber: Subscriber<[string, T]>, subscription: Subscription, obj: Object }>\n          (dispatch, 0, { keys, index: 0, subscriber, subscription, obj }));\n      return subscription;\n    });\n  }\n}\n\n/** @internal */\nexport function dispatch<T>(this: SchedulerAction<any>,\n                            state: { keys: string[], index: number, subscriber: Subscriber<[string, T]>, subscription: Subscription, obj: Object }) {\n  const { keys, index, subscriber, subscription, obj } = state;\n  if (!subscriber.closed) {\n    if (index < keys.length) {\n      const key = keys[index];\n      subscriber.next([key, obj[key]]);\n      subscription.add(this.schedule({ keys, index: index + 1, subscriber, subscription, obj }));\n    } else {\n      subscriber.complete();\n    }\n  }\n}\n","import { not } from '../util/not';\nimport { subscribeTo } from '../util/subscribeTo';\nimport { filter } from '../operators/filter';\nimport { ObservableInput } from '../types';\nimport { Observable } from '../Observable';\n\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * ![](partition.png)\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * ## Example\n * Partition a set of numbers into odds and evens observables\n * ```ts\n * import { of, partition } from 'rxjs';\n *\n * const observableValues = of(1, 2, 3, 4, 5, 6);\n * const [evens$, odds$] = partition(observableValues, (value, index) => value % 2 === 0);\n *\n * odds$.subscribe(x => console.log('odds', x));\n * evens$.subscribe(x => console.log('evens', x));\n *\n * // Logs:\n * // odds 1\n * // odds 3\n * // odds 5\n * // evens 2\n * // evens 4\n * // evens 6\n * ```\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n */\nexport function partition<T>(\n  source: ObservableInput<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): [Observable<T>, Observable<T>] {\n  return [\n    filter(predicate, thisArg)(new Observable<T>(subscribeTo(source))),\n    filter(not(predicate, thisArg) as any)(new Observable<T>(subscribeTo(source)))\n  ] as [Observable<T>, Observable<T>];\n}\n","import { SchedulerAction, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\n\n/**\n * Creates an Observable that emits a sequence of numbers within a specified\n * range.\n *\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n *\n * ![](range.png)\n *\n * `range` operator emits a range of sequential integers, in order, where you\n * select the `start` of the range and its `length`. By default, uses no\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\n * an optional {@link SchedulerLike} to regulate those deliveries.\n *\n * ## Example\n * Emits the numbers 1 to 10</caption>\n * ```ts\n * import { range } from 'rxjs';\n *\n * const numbers = range(1, 10);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link timer}\n * @see {@link index/interval}\n *\n * @param {number} [start=0] The value of the first integer in the sequence.\n * @param {number} count The number of sequential integers to generate.\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emissions of the notifications.\n * @return {Observable} An Observable of numbers that emits a finite range of\n * sequential integers.\n * @static true\n * @name range\n * @owner Observable\n */\nexport function range(start: number = 0,\n                      count?: number,\n                      scheduler?: SchedulerLike): Observable<number> {\n  return new Observable<number>(subscriber => {\n    if (count === undefined) {\n      count = start;\n      start = 0;\n    }\n\n    let index = 0;\n    let current = start;\n\n    if (scheduler) {\n      return scheduler.schedule(dispatch, 0, {\n        index, count, start, subscriber\n      });\n    } else {\n      do {\n        if (index++ >= count) {\n          subscriber.complete();\n          break;\n        }\n        subscriber.next(current++);\n        if (subscriber.closed) {\n          break;\n        }\n      } while (true);\n    }\n\n    return undefined;\n  });\n}\n\n/** @internal */\nexport function dispatch(this: SchedulerAction<any>, state: any) {\n  const { start, index, count, subscriber } = state;\n\n  if (index >= count) {\n    subscriber.complete();\n    return;\n  }\n\n  subscriber.next(start);\n\n  if (subscriber.closed) {\n    return;\n  }\n\n  state.index = index + 1;\n  state.start = start + 1;\n\n  this.schedule(state);\n}\n","import { Observable } from '../Observable';\nimport { Unsubscribable, ObservableInput } from '../types';\nimport { from } from './from'; // from from from! LAWL\nimport { EMPTY } from './empty';\n\n/**\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\n *\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\n *\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\n * that object and should return an Observable. That Observable can use resource object during its execution.\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\n * resource object will be shared in any way between subscriptions.\n *\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\n *\n * @see {@link defer}\n *\n * @param {function(): ISubscription} resourceFactory A function which creates any resource object\n * that implements `unsubscribe` method.\n * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which\n * creates an Observable, that can use injected resource object.\n * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\n */\nexport function using<T>(resourceFactory: () => Unsubscribable | void,\n                         observableFactory: (resource: Unsubscribable | void) => ObservableInput<T> | void): Observable<T> {\n  return new Observable<T>(subscriber => {\n    let resource: Unsubscribable | void;\n\n    try {\n      resource = resourceFactory();\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n\n    let result: ObservableInput<T> | void;\n    try {\n      result = observableFactory(resource);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n\n    const source = result ? from(result) : EMPTY;\n    const subscription = source.subscribe(subscriber);\n    return () => {\n      subscription.unsubscribe();\n      if (resource) {\n        resource.unsubscribe();\n      }\n    };\n  });\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n *\n * @class AsyncSubject<T>\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private value: T = null;\n  private hasNext: boolean = false;\n  private hasCompleted: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): Subscription {\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.hasCompleted && this.hasNext) {\n      subscriber.next(this.value);\n      subscriber.complete();\n      return Subscription.EMPTY;\n    }\n    return super._subscribe(subscriber);\n  }\n\n  next(value: T): void {\n    if (!this.hasCompleted) {\n      this.value = value;\n      this.hasNext = true;\n    }\n  }\n\n  error(error: any): void {\n    if (!this.hasCompleted) {\n      super.error(error);\n    }\n  }\n\n  complete(): void {\n    this.hasCompleted = true;\n    if (this.hasNext) {\n      super.next(this.value);\n    }\n    super.complete();\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { SubscriptionLike } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n *\n * @class BehaviorSubject<T>\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    if (subscription && !(<SubscriptionLike>subscription).closed) {\n      subscriber.next(this._value);\n    }\n    return subscription;\n  }\n\n  getValue(): T {\n    if (this.hasError) {\n      throw this.thrownError;\n    } else if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return this._value;\n    }\n  }\n\n  next(value: T): void {\n    super.next(this._value = value);\n  }\n}\n","import { PartialObserver } from './types';\nimport { Observable } from './Observable';\nimport { empty } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nimport { deprecate } from 'util';\n\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\n/**\n * @deprecated NotificationKind is deprecated as const enums are not compatible with isolated modules. Use a string literal instead.\n */\nexport enum NotificationKind {\n  NEXT = 'N',\n  ERROR = 'E',\n  COMPLETE = 'C',\n}\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nexport class Notification<T> {\n  hasValue: boolean;\n\n  constructor(public kind: 'N' | 'E' | 'C', public value?: T, public error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Delivers to the given `observer` the value wrapped by this Notification.\n   * @param {Observer} observer\n   * @return\n   */\n  observe(observer: PartialObserver<T>): any {\n    switch (this.kind) {\n      case 'N':\n        return observer.next && observer.next(this.value);\n      case 'E':\n        return observer.error && observer.error(this.error);\n      case 'C':\n        return observer.complete && observer.complete();\n    }\n  }\n\n  /**\n   * Given some {@link Observer} callbacks, deliver the value represented by the\n   * current Notification to the correctly corresponding callback.\n   * @param {function(value: T): void} next An Observer `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return next && next(this.value);\n      case 'E':\n        return error && error(this.error);\n      case 'C':\n        return complete && complete();\n    }\n  }\n\n  /**\n   * Takes an Observer or its individual callback functions, and calls `observe`\n   * or `do` methods accordingly.\n   * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n   * the `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    if (nextOrObserver && typeof (<PartialObserver<T>>nextOrObserver).next === 'function') {\n      return this.observe(<PartialObserver<T>>nextOrObserver);\n    } else {\n      return this.do(<(value: T) => void>nextOrObserver, error, complete);\n    }\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   * @return {any}\n   */\n  toObservable(): Observable<T> {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return of(this.value);\n      case 'E':\n        return throwError(this.error);\n      case 'C':\n        return empty();\n    }\n    throw new Error('unexpected notification kind value');\n  }\n\n  private static completeNotification: Notification<any> = new Notification('C');\n  private static undefinedValueNotification: Notification<any> = new Notification('N', undefined);\n\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   * @nocollapse\n   */\n  static createNext<T>(value: T): Notification<T> {\n    if (typeof value !== 'undefined') {\n      return new Notification('N', value);\n    }\n    return Notification.undefinedValueNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   * @nocollapse\n   */\n  static createError<T>(err?: any): Notification<T> {\n    return new Notification('E', undefined, err);\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   * @nocollapse\n   */\n  static createComplete(): Notification<any> {\n    return Notification.completeNotification;\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class OuterSubscriber<T, R> extends Subscriber<T> {\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this.destination.error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n","import { Subject } from './Subject';\nimport { SchedulerLike } from './types';\nimport { queue } from './scheduler/queue';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n/**\n * A variant of Subject that \"replays\" or emits old values to new subscribers.\n * It buffers a set number of values and will emit those values immediately to\n * any new subscribers in addition to emitting new values to existing subscribers.\n *\n * @class ReplaySubject<T>\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _events: (ReplayEvent<T> | T)[] = [];\n  private _bufferSize: number;\n  private _windowTime: number;\n  private _infiniteTimeWindow: boolean = false;\n\n  constructor(bufferSize: number = Number.POSITIVE_INFINITY,\n              windowTime: number = Number.POSITIVE_INFINITY,\n              private scheduler?: SchedulerLike) {\n    super();\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      this._infiniteTimeWindow = true;\n      this.next = this.nextInfiniteTimeWindow;\n    } else {\n      this.next = this.nextTimeWindow;\n    }\n  }\n\n  private nextInfiniteTimeWindow(value: T): void {\n    if (!this.isStopped) {\n      const _events = this._events;\n      _events.push(value);\n      // Since this method is invoked in every next() call than the buffer\n      // can overgrow the max size only by one item\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n    super.next(value);\n  }\n\n  private nextTimeWindow(value: T): void {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n      this._trimBufferThenGetEvents();\n    }\n    super.next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    // When `_infiniteTimeWindow === true` then the buffer is already trimmed\n    const _infiniteTimeWindow = this._infiniteTimeWindow;\n    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    const scheduler = this.scheduler;\n    const len = _events.length;\n    let subscription: Subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber<T>(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(<T>_events[i]);\n      }\n    } else {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next((<ReplayEvent<T>>_events[i]).value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  }\n\n  _getNow(): number {\n    return (this.scheduler || queue).now();\n  }\n\n  private _trimBufferThenGetEvents(): ReplayEvent<T>[] {\n    const now = this._getNow();\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = <ReplayEvent<T>[]>this._events;\n\n    const eventsCount = _events.length;\n    let spliceCount = 0;\n\n    // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n    while (spliceCount < eventsCount) {\n      if ((now - _events[spliceCount].time) < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  }\n\n}\n\nclass ReplayEvent<T> {\n  constructor(public time: number, public value: T) {\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}\n */\nexport class Scheduler implements SchedulerLike {\n\n  /**\n   * Note: the extra arrow function wrapper is to make testing by overriding\n   * Date.now easier.\n   * @nocollapse\n   */\n  public static now: () => number = () => Date.now();\n\n  constructor(private SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.SchedulerAction<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\n\n/**\n * @class SubjectSubscriber<T>\n */\nexport class SubjectSubscriber<T> extends Subscriber<T> {\n  constructor(protected destination: Subject<T>) {\n    super(destination);\n  }\n}\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n *\n * @class Subject<T>\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n\n  [rxSubscriberSymbol]() {\n    return new SubjectSubscriber(this);\n  }\n\n  observers: Observer<T>[] = [];\n\n  closed = false;\n\n  isStopped = false;\n\n  hasError = false;\n\n  thrownError: any = null;\n\n  constructor() {\n    super();\n  }\n\n  /**@nocollapse\n   * @deprecated use new Subject() instead\n  */\n  static create: Function = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  }\n\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = <any>operator;\n    return <any>subject;\n  }\n\n  next(value?: T) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (!this.isStopped) {\n      const { observers } = this;\n      const len = observers.length;\n      const copy = observers.slice();\n      for (let i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n    this.observers.length = 0;\n  }\n\n  complete() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n    this.observers.length = 0;\n  }\n\n  unsubscribe() {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return super._trySubscribe(subscriber);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create customize Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable = new Observable<T>();\n    (<any>observable).source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(protected destination?: Observer<T>, source?: Observable<T>) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    const { destination } = this;\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  }\n\n  error(err: any) {\n    const { destination } = this;\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  }\n\n  complete() {\n    const { destination } = this;\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n}\n","import { Subject } from './Subject';\nimport { Observer } from './types';\nimport { Subscription } from './Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SubjectSubscription<T> extends Subscription {\n  closed: boolean = false;\n\n  constructor(public subject: Subject<T>, public subscriber: Observer<T>) {\n    super();\n  }\n\n  unsubscribe() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const subject = this.subject;\n    const observers = subject.observers;\n\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    const subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  }\n}\n","import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic } from '../types';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  protected _subject: Subject<T>;\n  protected _refCount: number = 0;\n  protected _connection: Subscription;\n  /** @internal */\n  _isComplete = false;\n\n  constructor(public source: Observable<T>,\n              protected subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = (() => {\n  const connectableProto = <any>ConnectableObservable.prototype;\n  return {\n    operator: { value: null as null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null as null, writable: true },\n    _connection: { value: null as null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n  };\n})();\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  protected _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // ).subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { isScheduler  } from '../util/isScheduler';\nimport { isArray  } from '../util/isArray';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { Operator } from '../Operator';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { fromArray } from './fromArray';\n\nconst NONE = {};\n\n/* tslint:disable:max-line-length */\n\n// If called with a single array, it \"auto-spreads\" the array, with result selector\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, R>(sources: [O1], resultSelector: (v1: ObservedValueOf<O1>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, R>(sources: [O1, O2], resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, R>(sources: [O1, O2, O3], resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, R>(sources: [O1, O2, O3, O4], resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, R>(sources: [O1, O2, O3, O4, O5], resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>, R>(sources: [O1, O2, O3, O4, O5, O6], resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>, v6: ObservedValueOf<O6>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O extends ObservableInput<any>, R>(sources: O[], resultSelector: (...args: ObservedValueOf<O>[]) => R, scheduler?: SchedulerLike): Observable<R>;\n\n// standard call, but with a result selector\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, R>(v1: O1, resultSelector: (v1: ObservedValueOf<O1>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, R>(v1: O1, v2: O2, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>, v6: ObservedValueOf<O6>) => R, scheduler?: SchedulerLike): Observable<R>;\n\n// With a scheduler (deprecated)\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport function combineLatest<O1 extends ObservableInput<any>>(sources: [O1], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(sources: [O1, O2], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(sources: [O1, O2, O3], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(sources: [O1, O2, O3, O4], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(sources: [O1, O2, O3, O4, O5], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(sources: [O1, O2, O3, O4, O5, O6], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport function combineLatest<O extends ObservableInput<any>>(sources: O[], scheduler: SchedulerLike): Observable<ObservedValueOf<O>[]>;\n\n// Best case\nexport function combineLatest<O1 extends ObservableInput<any>>(sources: [O1]): Observable<[ObservedValueOf<O1>]>;\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(sources: [O1, O2]): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>]>;\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(sources: [O1, O2, O3]): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(sources: [O1, O2, O3, O4]): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(sources: [O1, O2, O3, O4, O5]): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(sources: [O1, O2, O3, O4, O5, O6]): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\nexport function combineLatest<O extends ObservableInput<any>>(sources: O[]): Observable<ObservedValueOf<O>[]>;\n\n// Standard calls\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport function combineLatest<O1 extends ObservableInput<any>>(v1: O1, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(v1: O1, v2: O2, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\n\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport function combineLatest<O extends ObservableInput<any>>(...observables: O[]): Observable<any[]>;\n\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport function combineLatest<O extends ObservableInput<any>, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\n\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<O extends ObservableInput<any>, R>(array: O[], resultSelector: (...values: ObservedValueOf<O>[]) => R, scheduler?: SchedulerLike): Observable<R>;\n\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport function combineLatest<O extends ObservableInput<any>>(...observables: Array<O | SchedulerLike>): Observable<any[]>;\n\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport function combineLatest<O extends ObservableInput<any>, R>(...observables: Array<O | ((...values: ObservedValueOf<O>[]) => R) | SchedulerLike>): Observable<R>;\n\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport function combineLatest<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R) | SchedulerLike>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * ![](combineLatest.png)\n *\n * `combineLatest` combines the values from all the Observables passed as\n * arguments. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to operator,\n * returned Observable will always emit an array of `n` values, in order\n * corresponding to order of passed Observables (value from the first Observable\n * on the first place and so on).\n *\n * Static version of `combineLatest` accepts either an array of Observables\n * or each Observable can be put directly as an argument. Note that array of\n * Observables is good choice, if you don't know beforehand how many Observables\n * you will combine. Passing empty array will result in Observable that\n * completes immediately.\n *\n * To ensure output array has always the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all these values but the last\n * will be lost. On the other hand, if some Observable does not emit a value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will be now impossible to include value from\n * completed Observable in resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * `combineLatest` accepts as optional parameter `project` function, which takes\n * as arguments all values that would normally be emitted by resulting Observable.\n * `project` can return any kind of value, which will be then emitted by Observable\n * instead of default array. Note that `project` does not take as argument that array\n * of values, but values themselves. That means default `project` can be imagined\n * as function that takes all its arguments and puts them into an array.\n *\n * ## Examples\n * ### Combine two timer Observables\n * ```ts\n * import { combineLatest, timer } from 'rxjs';\n *\n * const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = combineLatest(firstTimer, secondTimer);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n * ```\n *\n * ### Combine an array of Observables\n * ```ts\n * import { combineLatest, of } from 'rxjs';\n * import { delay, starWith } from 'rxjs/operators';\n *\n * const observables = [1, 5, 10].map(\n *   n => of(n).pipe(\n *     delay(n * 1000),   // emit 0 and then emit n after n seconds\n *     startWith(0),\n *   )\n * );\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n * ```\n *\n *\n * ### Use project function to dynamically calculate the Body-Mass Index\n * ```ts\n * import { combineLatest, of } from 'rxjs';\n * import { map } from 'rxjs/operators';\n *\n * const weight = of(70, 72, 76, 79, 75);\n * const height = of(1.76, 1.77, 1.78);\n * const bmi = combineLatest(weight, height).pipe(\n *   map(([w, h]) => w / (h * h)),\n * );\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n * ```\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\n * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\n * More than one input Observables may be given as arguments\n * or an array of Observables may be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n */\nexport function combineLatest<O extends ObservableInput<any>, R>(\n  ...observables: (O | ((...values: ObservedValueOf<O>[]) => R) | SchedulerLike)[]\n): Observable<R> {\n  let resultSelector: ((...values: Array<any>) => R) | undefined =  undefined;\n  let scheduler: SchedulerLike|undefined = undefined;\n\n  if (isScheduler(observables[observables.length - 1])) {\n    scheduler = observables.pop() as SchedulerLike;\n  }\n\n  if (typeof observables[observables.length - 1] === 'function') {\n    resultSelector = observables.pop() as (...values: Array<any>) => R;\n  }\n\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], resultSelector)`\n  if (observables.length === 1 && isArray(observables[0])) {\n    observables = observables[0] as any;\n  }\n\n  return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));\n}\n\nexport class CombineLatestOperator<T, R> implements Operator<T, R> {\n  constructor(private resultSelector?: (...values: Array<any>) => R) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private active: number = 0;\n  private values: any[] = [];\n  private observables: any[] = [];\n  private toRespond?: number;\n\n  constructor(destination: Subscriber<R>, private resultSelector?: (...values: Array<any>) => R) {\n    super(destination);\n  }\n\n  protected _next(observable: any) {\n    this.values.push(NONE);\n    this.observables.push(observable);\n  }\n\n  protected _complete() {\n    const observables = this.observables;\n    const len = observables.length;\n    if (len === 0) {\n      this.destination.complete!();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n      for (let i = 0; i < len; i++) {\n        const observable = observables[i];\n        this.add(subscribeToResult(this, observable, undefined, i));\n      }\n    }\n  }\n\n  notifyComplete(unused: Subscriber<R>): void {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete!();\n    }\n  }\n\n  notifyNext(_outerValue: T, innerValue: R,\n             outerIndex: number): void {\n    const values = this.values;\n    const oldVal = values[outerIndex];\n    const toRespond = !this.toRespond\n      ? 0\n      : oldVal === NONE ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n\n    if (toRespond === 0) {\n      if (this.resultSelector) {\n        this._tryResultSelector(values);\n      } else {\n        this.destination.next!(values.slice());\n      }\n    }\n  }\n\n  private _tryResultSelector(values: any[]) {\n    let result: any;\n    try {\n      result = this.resultSelector!.apply(this, values);\n    } catch (err) {\n      this.destination.error!(err);\n      return;\n    }\n    this.destination.next!(result);\n  }\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { of } from './of';\nimport { from } from './from';\nimport { concatAll } from '../operators/concatAll';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport function concat<O1 extends ObservableInput<any>>(v1: O1, scheduler: SchedulerLike): Observable<ObservedValueOf<O1>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(v1: O1, v2: O2, scheduler: SchedulerLike): Observable<ObservedValueOf<O1> | ObservedValueOf<O2>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, scheduler: SchedulerLike): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, scheduler: SchedulerLike): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, scheduler: SchedulerLike): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4> | ObservedValueOf<O5>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, scheduler: SchedulerLike): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4> | ObservedValueOf<O5> | ObservedValueOf<O6>>;\n\nexport function concat<O1 extends ObservableInput<any>>(v1: O1): Observable<ObservedValueOf<O1>>;\nexport function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(v1: O1, v2: O2): Observable<ObservedValueOf<O1> | ObservedValueOf<O2>>;\nexport function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3>>;\nexport function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4>>;\nexport function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4> | ObservedValueOf<O5>>;\nexport function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4> | ObservedValueOf<O5> | ObservedValueOf<O6>>;\nexport function concat<O extends ObservableInput<any>>(...observables: O[]): Observable<ObservedValueOf<O>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport function concat<O extends ObservableInput<any>>(...observables: (O | SchedulerLike)[]): Observable<ObservedValueOf<O>>;\nexport function concat<R>(...observables: ObservableInput<any>[]): Observable<R>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport function concat<R>(...observables: (ObservableInput<any> | SchedulerLike)[]): Observable<R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * ![](concat.png)\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * ## Examples\n * ### Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10\n * ```ts\n * import { concat, interval, range } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const timer = interval(1000).pipe(take(4));\n * const sequence = range(1, 10);\n * const result = concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n * ```\n *\n * ### Concatenate 3 Observables\n * ```ts\n * import { concat, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const result = concat(timer1, timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n * ```\n *\n * ### Concatenate the same Observable to repeat it\n * ```ts\n * import { concat, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const timer = interval(1000).pipe(take(2));\n *\n * concat(timer, timer) // concatenating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n * ```\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link startWith}\n * @see {@link endWith}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {SchedulerLike} [scheduler=null] An optional {@link SchedulerLike} to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nexport function concat<O extends ObservableInput<any>, R>(...observables: Array<O | SchedulerLike>): Observable<ObservedValueOf<O> | R> {\n  return concatAll<R>()(of(...observables));\n}\n","import { Observable } from '../Observable';\nimport { SubscribableOrPromise, ObservedValueOf, ObservableInput } from '../types';\nimport { from } from './from'; // lol\nimport { empty } from './empty';\n\n/**\n * Creates an Observable that, on subscribe, calls an Observable factory to\n * make an Observable for each new Observer.\n *\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n * is subscribed.\n * </span>\n *\n * ![](defer.png)\n *\n * `defer` allows you to create the Observable only when the Observer\n * subscribes, and create a fresh Observable for each Observer. It waits until\n * an Observer subscribes to it, and then it generates an Observable,\n * typically with an Observable factory function. It does this afresh for each\n * subscriber, so although each subscriber may think it is subscribing to the\n * same Observable, in fact each subscriber gets its own individual\n * Observable.\n *\n * ## Example\n * ### Subscribe to either an Observable of clicks or an Observable of interval, at random\n * ```ts\n * import { defer, fromEvent, interval } from 'rxjs';\n *\n * const clicksOrInterval = defer(function () {\n *   return Math.random() > 0.5\n *     ? fromEvent(document, 'click')\n *     : interval(1000);\n * });\n * clicksOrInterval.subscribe(x => console.log(x));\n *\n * // Results in the following behavior:\n * // If the result of Math.random() is greater than 0.5 it will listen\n * // for clicks anywhere on the \"document\"; when document is clicked it\n * // will log a MouseEvent object to the console. If the result is less\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n * ```\n *\n * @see {@link Observable}\n *\n * @param {function(): SubscribableOrPromise} observableFactory The Observable\n * factory function to invoke for each Observer that subscribes to the output\n * Observable. May also return a Promise, which will be converted on the fly\n * to an Observable.\n * @return {Observable} An Observable whose Observers' subscriptions trigger\n * an invocation of the given Observable factory function.\n * @static true\n * @name defer\n * @owner Observable\n */\nexport function defer<R extends ObservableInput<any> | void>(observableFactory: () => R): Observable<ObservedValueOf<R>> {\n  return new Observable<ObservedValueOf<R>>(subscriber => {\n    let input: R | void;\n    try {\n      input = observableFactory();\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n    const source = input ? from(input as ObservableInput<ObservedValueOf<R>>) : empty();\n    return source.subscribe(subscriber);\n  });\n}\n","import { SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { fromArray } from './fromArray';\nimport { Observable } from '../Observable';\nimport { scheduleArray } from '../scheduled/scheduleArray';\n\n/* tslint:disable:max-line-length */\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport function of<T>(a: T, scheduler: SchedulerLike): Observable<T>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport function of<T, T2>(a: T, b: T2, scheduler: SchedulerLike): Observable<T | T2>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport function of<T, T2, T3>(a: T, b: T2, c: T3, scheduler: SchedulerLike): Observable<T | T2 | T3>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, scheduler: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, scheduler: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9, scheduler: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\nexport function of<T>(...args: (T | SchedulerLike)[]): Observable<T>;\n\n// TODO(benlesh): Update the typings for this when we can switch to TS 3.x\nexport function of<T>(a: T): Observable<T>;\nexport function of<T, T2>(a: T, b: T2): Observable<T | T2>;\nexport function of<T, T2, T3>(a: T, b: T2, c: T3): Observable<T | T2 | T3>;\nexport function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4): Observable<T | T2 | T3 | T4>;\nexport function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5): Observable<T | T2 | T3 | T4 | T5>;\nexport function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7>;\nexport function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\nexport function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\nexport function of<T>(...args: T[]): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of(10, 20, 30)\n * .subscribe(\n *   next => console.log('next:', next),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'next: 10'\n * // 'next: 20'\n * // 'next: 30'\n *\n * ```\n *\n * Emit the array `[1,2,3]`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of([1,2,3])\n * .subscribe(\n *   next => console.log('next:', next),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'next: [1,2,3]'\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param {...T} values A comma separated list of arguments you want to be emitted\n * @return {Observable} An Observable that emits the arguments\n * described above and then completes.\n * @method of\n * @owner Observable\n */\n\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  let scheduler = args[args.length - 1] as SchedulerLike;\n  if (isScheduler(scheduler)) {\n    args.pop();\n    return scheduleArray(args as T[], scheduler);\n  } else {\n    return fromArray(args as T[]);\n  }\n}\n","import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { fromArray } from './fromArray';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic, ObservableInput } from '../types';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\n// tslint:disable:max-line-length\nexport function race<A>(arg: [ObservableInput<A>]): Observable<A>;\nexport function race<A, B>(arg: [ObservableInput<A>, ObservableInput<B>]): Observable<A | B>;\nexport function race<A, B, C>(arg: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>]): Observable<A | B | C>;\nexport function race<A, B, C, D>(arg: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>]): Observable<A | B | C | D>;\nexport function race<A, B, C, D, E>(arg: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>, ObservableInput<E>]): Observable<A | B | C | D | E>;\nexport function race<T>(arg: ObservableInput<T>[]): Observable<T>;\nexport function race(arg: ObservableInput<any>[]): Observable<{}>;\n\nexport function race<A>(a: ObservableInput<A>): Observable<A>;\nexport function race<A, B>(a: ObservableInput<A>, b: ObservableInput<B>): Observable<A | B>;\nexport function race<A, B, C>(a: ObservableInput<A>, b: ObservableInput<B>, c: ObservableInput<C>): Observable<A | B | C>;\nexport function race<A, B, C, D>(a: ObservableInput<A>, b: ObservableInput<B>, c: ObservableInput<C>, d: ObservableInput<D>): Observable<A | B | C | D>;\nexport function race<A, B, C, D, E>(a: ObservableInput<A>, b: ObservableInput<B>, c: ObservableInput<C>, d: ObservableInput<D>, e: ObservableInput<E>): Observable<A | B | C | D | E>;\n// tslint:enable:max-line-length\n\nexport function race<T>(observables: ObservableInput<T>[]): Observable<T>;\nexport function race(observables: ObservableInput<any>[]): Observable<{}>;\nexport function race<T>(...observables: ObservableInput<T>[]): Observable<T>;\nexport function race(...observables: ObservableInput<any>[]): Observable<{}>;\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item.\n *\n * ## Example\n * ### Subscribes to the observable that was the first to start emitting.\n *\n * ```ts\n * import { race, interval } from 'rxjs';\n * import { mapTo } from 'rxjs/operators';\n *\n * const obs1 = interval(1000).pipe(mapTo('fast one'));\n * const obs2 = interval(3000).pipe(mapTo('medium one'));\n * const obs3 = interval(5000).pipe(mapTo('slow one'));\n *\n * race(obs3, obs1, obs2)\n * .subscribe(\n *   winner => console.log(winner)\n * );\n *\n * // result:\n * // a series of 'fast one'\n * ```\n *\n * @param {...Observables} ...observables sources used to race for which Observable emits first.\n * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.\n * @static true\n * @name race\n * @owner Observable\n */\nexport function race<T>(...observables: ObservableInput<any>[]): Observable<T> {\n  // if the only argument is an array, it was most likely called with\n  // `race([obs1, obs2, ...])`\n  if (observables.length === 1) {\n    if (isArray(observables[0])) {\n      observables = observables[0] as Observable<any>[];\n    } else {\n      return observables[0] as Observable<T>;\n    }\n  }\n\n  return fromArray(observables, undefined).lift(new RaceOperator<T>());\n}\n\nexport class RaceOperator<T> implements Operator<T, T> {\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RaceSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class RaceSubscriber<T> extends OuterSubscriber<T, T> {\n  private hasFirst: boolean = false;\n  private observables: Observable<any>[] = [];\n  private subscriptions: Subscription[] = [];\n\n  constructor(destination: Subscriber<T>) {\n    super(destination);\n  }\n\n  protected _next(observable: any): void {\n    this.observables.push(observable);\n  }\n\n  protected _complete() {\n    const observables = this.observables;\n    const len = observables.length;\n\n    if (len === 0) {\n      this.destination.complete!();\n    } else {\n      for (let i = 0; i < len && !this.hasFirst; i++) {\n        const observable = observables[i];\n        const subscription = subscribeToResult(this, observable, undefined, i)!;\n\n        if (this.subscriptions) {\n          this.subscriptions.push(subscription);\n        }\n        this.add(subscription);\n      }\n      this.observables = null!;\n    }\n  }\n\n  notifyNext(_outerValue: T, innerValue: T,\n             outerIndex: number): void {\n    if (!this.hasFirst) {\n      this.hasFirst = true;\n\n      for (let i = 0; i < this.subscriptions.length; i++) {\n        if (i !== outerIndex) {\n          let subscription = this.subscriptions[i];\n\n          subscription.unsubscribe();\n          this.remove(subscription);\n        }\n      }\n\n      this.subscriptions = null!;\n    }\n\n    this.destination.next!(innerValue);\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits an error notification.\n *\n * <span class=\"informal\">Just emits 'error', and nothing else.\n * </span>\n *\n * ![](throw.png)\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the error notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then emit an error\n * ```ts\n * import { throwError, concat, of } from 'rxjs';\n *\n * const result = concat(of(7), throwError(new Error('oops!')));\n * result.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Logs:\n * // 7\n * // Error: oops!\n * ```\n *\n * ---\n *\n * ### Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 2\n * ```ts\n * import { throwError, interval, of } from 'rxjs';\n * import { mergeMap } from 'rxjs/operators';\n *\n * interval(1000).pipe(\n *   mergeMap(x => x === 2\n *     ? throwError('Twos are bad')\n *     : of('a', 'b', 'c')\n *   ),\n * ).subscribe(x => console.log(x), e => console.error(e));\n *\n * // Logs:\n * // a\n * // b\n * // c\n * // a\n * // b\n * // c\n * // Twos are bad\n * ```\n *\n * @see {@link Observable}\n * @see {@link empty}\n * @see {@link never}\n * @see {@link of}\n *\n * @param {any} error The particular Error to pass to the error notification.\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emission of the error notification.\n * @return {Observable} An error Observable: emits only the error notification\n * using the given error argument.\n * @static true\n * @name throwError\n * @owner Observable\n */\nexport function throwError(error: any, scheduler?: SchedulerLike): Observable<never> {\n  if (!scheduler) {\n    return new Observable(subscriber => subscriber.error(error));\n  } else {\n    return new Observable(subscriber => scheduler.schedule(dispatch, 0, { error, subscriber }));\n  }\n}\n\ninterface DispatchArg {\n  error: any;\n  subscriber: Subscriber<any>;\n}\n\nfunction dispatch({ error, subscriber }: DispatchArg) {\n  subscriber.error(error);\n}\n","import { Observable } from '../Observable';\nimport { SchedulerAction, SchedulerLike } from '../types';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * Creates an Observable that starts emitting after an `dueTime` and\n * emits ever increasing numbers after each `period` of time thereafter.\n *\n * <span class=\"informal\">Its like {@link index/interval}, but you can specify when\n * should the emissions start.</span>\n *\n * ![](timer.png)\n *\n * `timer` returns an Observable that emits an infinite sequence of ascending\n * integers, with a constant interval of time, `period` of your choosing\n * between those emissions. The first emission happens after the specified\n * `dueTime`. The initial delay may be a `Date`. By default, this\n * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you\n * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output\n * Observable emits only one value, `0`. Otherwise, it emits an infinite\n * sequence.\n *\n * ## Examples\n * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds\n * ```ts\n * import { timer } from 'rxjs';\n *\n * const numbers = timer(3000, 1000);\n * numbers.subscribe(x => console.log(x));\n * ```\n *\n * ### Emits one number after five seconds\n * ```ts\n * import { timer } from 'rxjs';\n *\n * const numbers = timer(5000);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link index/interval}\n * @see {@link delay}\n *\n * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting\n * milliseconds to wait before emitting the first value of 0`.\n * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the\n * subsequent numbers.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a `0` after the\n * `dueTime` and ever increasing numbers after each `period` of time\n * thereafter.\n * @static true\n * @name timer\n * @owner Observable\n */\nexport function timer(dueTime: number | Date = 0,\n                      periodOrScheduler?: number | SchedulerLike,\n                      scheduler?: SchedulerLike): Observable<number> {\n  let period = -1;\n  if (isNumeric(periodOrScheduler)) {\n    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\n  } else if (isScheduler(periodOrScheduler)) {\n    scheduler = periodOrScheduler as any;\n  }\n\n  if (!isScheduler(scheduler)) {\n    scheduler = async;\n  }\n\n  return new Observable(subscriber => {\n    const due = isNumeric(dueTime)\n      ? (dueTime as number)\n      : (+dueTime - scheduler.now());\n\n    return scheduler.schedule(dispatch, due, {\n      index: 0, period, subscriber\n    });\n  });\n}\n\ninterface TimerState {\n  index: number;\n  period: number;\n  subscriber: Subscriber<number>;\n}\n\nfunction dispatch(this: SchedulerAction<TimerState>, state: TimerState) {\n  const { index, period, subscriber } = state;\n  subscriber.next(index);\n\n  if (subscriber.closed) {\n    return;\n  } else if (period === -1) {\n    return subscriber.complete();\n  }\n\n  state.index = index + 1;\n  this.schedule(state, period);\n}\n","import { Observable } from '../Observable';\nimport { fromArray } from './fromArray';\nimport { isArray } from '../util/isArray';\nimport { Operator } from '../Operator';\nimport { ObservableInput, PartialObserver, ObservedValueOf } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { iterator as Symbol_iterator } from '../../internal/symbol/iterator';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, R>(v1: O1, resultSelector: (v1: ObservedValueOf<O1>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, R>(v1: O1, v2: O2, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>, v6: ObservedValueOf<O6>) => R): Observable<R>;\n\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(v1: O1, v2: O2): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\n\nexport function zip<O extends ObservableInput<any>>(array: O[]): Observable<ObservedValueOf<O>[]>;\nexport function zip<R>(array: ObservableInput<any>[]): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O extends ObservableInput<any>, R>(array: O[], resultSelector: (...values: ObservedValueOf<O>[]) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<R>(array: ObservableInput<any>[], resultSelector: (...values: any[]) => R): Observable<R>;\n\nexport function zip<O extends ObservableInput<any>>(...observables: O[]): Observable<ObservedValueOf<O>[]>;\nexport function zip<O extends ObservableInput<any>, R>(...observables: Array<O | ((...values: ObservedValueOf<O>[]) => R)>): Observable<R>;\nexport function zip<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the last parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * ## Example\n * Combine age and name from different sources\n * ```ts\n * import { zip, of } from 'rxjs';\n * import { map } from 'rxjs/operators';\n *\n * let age$ = of<number>(27, 25, 29);\n * let name$ = of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = of<boolean>(true, true, false);\n *\n * zip(age$, name$, isDev$).pipe(\n *   map(([age, name, isDev]) => ({ age, name, isDev })),\n * )\n * .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n * ```\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nexport function zip<O extends ObservableInput<any>, R>(\n  ...observables: Array<O | ((...values: ObservedValueOf<O>[]) => R)>\n): Observable<ObservedValueOf<O>[]|R> {\n  const resultSelector = <((...ys: Array<any>) => R)> observables[observables.length - 1];\n  if (typeof resultSelector === 'function') {\n    observables.pop();\n  }\n  return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));\n}\n\nexport class ZipOperator<T, R> implements Operator<T, R> {\n\n  resultSelector?: (...values: Array<any>) => R;\n\n  constructor(resultSelector?: (...values: Array<any>) => R) {\n    this.resultSelector = resultSelector;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ZipSubscriber<T, R> extends Subscriber<T> {\n  private iterators: LookAheadIterator<any>[] = [];\n  private active = 0;\n\n  constructor(destination: Subscriber<R>,\n              private resultSelector?: (...values: Array<any>) => R,\n              values: any = Object.create(null)) {\n    super(destination);\n    this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : undefined;\n  }\n\n  protected _next(value: any) {\n    const iterators = this.iterators;\n    if (isArray(value)) {\n      iterators.push(new StaticArrayIterator(value));\n    } else if (typeof value[Symbol_iterator] === 'function') {\n      iterators.push(new StaticIterator(value[Symbol_iterator]()));\n    } else {\n      iterators.push(new ZipBufferIterator(this.destination, this, value));\n    }\n  }\n\n  protected _complete() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n\n    this.unsubscribe();\n\n    if (len === 0) {\n      this.destination.complete!();\n      return;\n    }\n\n    this.active = len;\n    for (let i = 0; i < len; i++) {\n      let iterator: ZipBufferIterator<any, any> = <any>iterators[i];\n      if (iterator.stillUnsubscribed) {\n        const destination = this.destination as Subscription;\n        destination.add(iterator.subscribe());\n      } else {\n        this.active--; // not an observable\n      }\n    }\n  }\n\n  notifyInactive() {\n    this.active--;\n    if (this.active === 0) {\n      this.destination.complete!();\n    }\n  }\n\n  checkIterators() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n    const destination = this.destination;\n\n    // abort if not all of them have values\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n        return;\n      }\n    }\n\n    let shouldComplete = false;\n    const args: any[] = [];\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      let result = iterator.next();\n\n      // check to see if it's completed now that you've gotten\n      // the next value.\n      if (iterator.hasCompleted()) {\n        shouldComplete = true;\n      }\n\n      if (result.done) {\n        destination.complete!();\n        return;\n      }\n\n      args.push(result.value);\n    }\n\n    if (this.resultSelector) {\n      this._tryresultSelector(args);\n    } else {\n      destination.next!(args);\n    }\n\n    if (shouldComplete) {\n      destination.complete!();\n    }\n  }\n\n  protected _tryresultSelector(args: any[]) {\n    let result: any;\n    try {\n      result = this.resultSelector!.apply(this, args);\n    } catch (err) {\n      this.destination.error!(err);\n      return;\n    }\n    this.destination.next!(result);\n  }\n}\n\ninterface LookAheadIterator<T> extends Iterator<T> {\n  hasValue(): boolean;\n  hasCompleted(): boolean;\n}\n\nclass StaticIterator<T> implements LookAheadIterator<T> {\n  private nextResult: IteratorResult<T>;\n\n  constructor(private iterator: Iterator<T>) {\n    this.nextResult = iterator.next();\n  }\n\n  hasValue() {\n    return true;\n  }\n\n  next(): IteratorResult<T> {\n    const result = this.nextResult;\n    this.nextResult = this.iterator.next();\n    return result;\n  }\n\n  hasCompleted(): boolean {\n    const nextResult = this.nextResult;\n    return Boolean(nextResult && nextResult.done);\n  }\n}\n\nclass StaticArrayIterator<T> implements LookAheadIterator<T> {\n  private index = 0;\n  private length = 0;\n\n  constructor(private array: T[]) {\n    this.length = array.length;\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  next(value?: any): IteratorResult<T> {\n    const i = this.index++;\n    const array = this.array;\n    return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n  }\n\n  hasValue() {\n    return this.array.length > this.index;\n  }\n\n  hasCompleted() {\n    return this.array.length === this.index;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ZipBufferIterator<T, R> extends SimpleOuterSubscriber<T, R> implements LookAheadIterator<T> {\n  stillUnsubscribed = true;\n  buffer: T[] = [];\n  isComplete = false;\n\n  constructor(destination: PartialObserver<T>,\n              private parent: ZipSubscriber<T, R>,\n              private observable: Observable<T>) {\n    super(destination);\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n  //    this is legit because `next()` will never be called by a subscription in this case.\n  next(): IteratorResult<T> {\n    const buffer = this.buffer;\n    if (buffer.length === 0 && this.isComplete) {\n      return { value: null, done: true };\n    } else {\n      return { value: buffer.shift()!, done: false };\n    }\n  }\n\n  hasValue() {\n    return this.buffer.length > 0;\n  }\n\n  hasCompleted() {\n    return this.buffer.length === 0 && this.isComplete;\n  }\n\n  notifyComplete() {\n    if (this.buffer.length > 0) {\n      this.isComplete = true;\n      this.parent.notifyInactive();\n    } else {\n      this.destination.complete!();\n    }\n  }\n\n  notifyNext(innerValue: any): void {\n    this.buffer.push(innerValue);\n    this.parent.checkIterators();\n  }\n\n  subscribe() {\n    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));\n  }\n}\n","\nimport { mergeAll } from './mergeAll';\nimport { OperatorFunction, ObservableInput } from '../types';\n\nexport function concatAll<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport function concatAll<R>(): OperatorFunction<any, R>;\n\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * ![](concatAll.png)\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { map, take, concatAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(ev => interval(1000).pipe(take(4))),\n * );\n * const firstOrder = higherOrder.pipe(concatAll());\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nexport function concatAll<T>(): OperatorFunction<ObservableInput<T>, T> {\n  return mergeAll<T>(1);\n}\n","import { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function groupBy<T, K>(keySelector: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\nexport function groupBy<T, K>(keySelector: (value: T) => K, elementSelector: void, durationSelector: (grouped: GroupedObservable<K, T>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, T>>;\nexport function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, R>>;\nexport function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>, subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * ![](groupBy.png)\n *\n * When the Observable emits an item, a key is computed for this item with the keySelector function.\n *\n * If a {@link GroupedObservable} for this key exists, this {@link GroupedObservable} emits. Elsewhere, a new\n * {@link GroupedObservable} for this key is created and emits.\n *\n * A {@link GroupedObservable} represents values belonging to the same group represented by a common key. The common\n * key is available as the key field of a {@link GroupedObservable} instance.\n *\n * The elements emitted by {@link GroupedObservable}s are by default the items emitted by the Observable, or elements\n * returned by the elementSelector function.\n *\n * ## Examples\n *\n * ### Group objects by id and return as array\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { mergeMap, groupBy, reduce } from 'rxjs/operators';\n *\n * of(\n *   {id: 1, name: 'JavaScript'},\n *   {id: 2, name: 'Parcel'},\n *   {id: 2, name: 'webpack'},\n *   {id: 1, name: 'TypeScript'},\n *   {id: 3, name: 'TSLint'}\n * ).pipe(\n *   groupBy(p => p.id),\n *   mergeMap((group$) => group$.pipe(reduce((acc, cur) => [...acc, cur], []))),\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'JavaScript'},\n * //   { id: 1, name: 'TypeScript'} ]\n * //\n * // [ { id: 2, name: 'Parcel'},\n * //   { id: 2, name: 'webpack'} ]\n * //\n * // [ { id: 3, name: 'TSLint'} ]\n * ```\n *\n * ### Pivot data on the id field\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { groupBy, map, mergeMap, reduce } from 'rxjs/operators';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * )\n *   .pipe(\n *     groupBy(p => p.id, p => p.name),\n *     mergeMap(group$ =>\n *       group$.pipe(reduce((acc, cur) => [...acc, cur], [`${group$.key}`]))\n *     ),\n *     map(arr => ({ id: parseInt(arr[0], 10), values: arr.slice(1) }))\n *  )\n *  .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'JavaScript', 'TypeScript' ] }\n * // { id: 2, values: [ 'Parcel', 'webpack' ] }\n * // { id: 3, values: [ 'TSLint' ] }\n * ```\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nexport function groupBy<T, K, R>(keySelector: (value: T) => K,\n                                 elementSelector?: ((value: T) => R) | void,\n                                 durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n                                 subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>> {\n  return (source: Observable<T>) =>\n    source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n}\n\nexport interface RefCountSubscription {\n  count: number;\n  unsubscribe: () => void;\n  closed: boolean;\n  attemptedToUnsubscribe: boolean;\n}\n\nclass GroupByOperator<T, K, R> implements Operator<T, GroupedObservable<K, R>> {\n  constructor(private keySelector: (value: T) => K,\n              private elementSelector?: ((value: T) => R) | void,\n              private durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n              private subjectSelector?: () => Subject<R>) {\n  }\n\n  call(subscriber: Subscriber<GroupedObservable<K, R>>, source: any): any {\n    return source.subscribe(new GroupBySubscriber(\n      subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass GroupBySubscriber<T, K, R> extends Subscriber<T> implements RefCountSubscription {\n  private groups: Map<K, Subject<T | R>> = null;\n  public attemptedToUnsubscribe: boolean = false;\n  public count: number = 0;\n\n  constructor(destination: Subscriber<GroupedObservable<K, R>>,\n              private keySelector: (value: T) => K,\n              private elementSelector?: ((value: T) => R) | void,\n              private durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n              private subjectSelector?: () => Subject<R>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    let key: K;\n    try {\n      key = this.keySelector(value);\n    } catch (err) {\n      this.error(err);\n      return;\n    }\n\n    this._group(value, key);\n  }\n\n  private _group(value: T, key: K) {\n    let groups = this.groups;\n\n    if (!groups) {\n      groups = this.groups = new Map<K, Subject<T | R>>();\n    }\n\n    let group = groups.get(key);\n\n    let element: R;\n    if (this.elementSelector) {\n      try {\n        element = this.elementSelector(value);\n      } catch (err) {\n        this.error(err);\n      }\n    } else {\n      element = <any>value;\n    }\n\n    if (!group) {\n      group = (this.subjectSelector ? this.subjectSelector() : new Subject<R>()) as Subject<T | R>;\n      groups.set(key, group);\n      const groupedObservable = new GroupedObservable(key, group, this);\n      this.destination.next(groupedObservable);\n      if (this.durationSelector) {\n        let duration: any;\n        try {\n          duration = this.durationSelector(new GroupedObservable<K, R>(key, <Subject<R>>group));\n        } catch (err) {\n          this.error(err);\n          return;\n        }\n        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n      }\n    }\n\n    if (!group.closed) {\n      group.next(element);\n    }\n  }\n\n  protected _error(err: any): void {\n    const groups = this.groups;\n    if (groups) {\n      groups.forEach((group, key) => {\n        group.error(err);\n      });\n\n      groups.clear();\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete(): void {\n    const groups = this.groups;\n    if (groups) {\n      groups.forEach((group, key) => {\n        group.complete();\n      });\n\n      groups.clear();\n    }\n    this.destination.complete();\n  }\n\n  removeGroup(key: K): void {\n    this.groups.delete(key);\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      this.attemptedToUnsubscribe = true;\n      if (this.count === 0) {\n        super.unsubscribe();\n      }\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass GroupDurationSubscriber<K, T> extends Subscriber<T> {\n  constructor(private key: K,\n              private group: Subject<T>,\n              private parent: GroupBySubscriber<any, K, T | any>) {\n    super(group);\n  }\n\n  protected _next(value: T): void {\n    this.complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { parent, key } = this;\n    this.key = this.parent = null;\n    if (parent) {\n      parent.removeGroup(key);\n    }\n  }\n}\n\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nexport class GroupedObservable<K, T> extends Observable<T> {\n  /** @deprecated Do not construct this type. Internal use only */\n  constructor(public key: K,\n              private groupSubject: Subject<T>,\n              private refCountSubscription?: RefCountSubscription) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    const subscription = new Subscription();\n    const { refCountSubscription, groupSubject } = this;\n    if (refCountSubscription && !refCountSubscription.closed) {\n      subscription.add(new InnerRefCountSubscription(refCountSubscription));\n    }\n    subscription.add(groupSubject.subscribe(subscriber));\n    return subscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass InnerRefCountSubscription extends Subscription {\n  constructor(private parent: RefCountSubscription) {\n    super();\n    parent.count++;\n  }\n\n  unsubscribe() {\n    const parent = this.parent;\n    if (!parent.closed && !this.closed) {\n      super.unsubscribe();\n      parent.count -= 1;\n      if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n        parent.unsubscribe();\n      }\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Notification } from '../Notification';\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n * Ensure values in subscribe are called just before browser repaint.\n * ```ts\n * import { interval } from 'rxjs';\n * import { observeOn } from 'rxjs/operators';\n *\n * const intervals = interval(10);                // Intervals are scheduled\n *                                                // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler),          // ...but we will observe on animationFrame\n * )                                              // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return function observeOnOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new ObserveOnOperator(scheduler, delay));\n  };\n}\n\nexport class ObserveOnOperator<T> implements Operator<T, T> {\n  constructor(private scheduler: SchedulerLike, private delay: number = 0) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ObserveOnSubscriber<T> extends Subscriber<T> {\n  /** @nocollapse */\n  static dispatch(this: SchedulerAction<ObserveOnMessage>, arg: ObserveOnMessage) {\n    const { notification, destination } = arg;\n    notification.observe(destination);\n    this.unsubscribe();\n  }\n\n  constructor(destination: Subscriber<T>,\n              private scheduler: SchedulerLike,\n              private delay: number = 0) {\n    super(destination);\n  }\n\n  private scheduleMessage(notification: Notification<any>): void {\n    const destination = this.destination as Subscription;\n    destination.add(this.scheduler.schedule(\n      ObserveOnSubscriber.dispatch,\n      this.delay,\n      new ObserveOnMessage(notification, this.destination)\n    ));\n  }\n\n  protected _next(value: T): void {\n    this.scheduleMessage(Notification.createNext(value));\n  }\n\n  protected _error(err: any): void {\n    this.scheduleMessage(Notification.createError(err));\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.scheduleMessage(Notification.createComplete());\n    this.unsubscribe();\n  }\n}\n\nexport class ObserveOnMessage {\n  constructor(public notification: Notification<any>,\n              public destination: PartialObserver<any>) {\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Observable } from '../Observable';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the *publish* operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval } from 'rxjs';\n * import { tap, publish, refCount } from 'rxjs/operators';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap((num) => console.log(`refCount ${num}`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap((num) => console.log(`publish ${num}`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the publish operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return function refCountOperatorFunction(source: ConnectableObservable<T>): Observable<T> {\n    return source.lift(new RefCountOperator(source));\n  } as MonoTypeOperatorFunction<T>;\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // )\n    // .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    clearInterval(id);\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\n\nexport class AsyncScheduler extends Scheduler {\n  public static delegate?: Scheduler;\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @deprecated internal use only\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @deprecated internal use only\n   */\n  public scheduled: any = undefined;\n\n  constructor(SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    super(SchedulerAction, () => {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    });\n  }\n\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return super.schedule(work, delay, state);\n    }\n  }\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","let nextHandle = 1;\nconst RESOLVED = (() => Promise.resolve())();\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    RESOLVED.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n","import { Immediate } from '../util/Immediate';\nimport { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsapAction<T> extends AsyncAction<T> {\n\n  constructor(protected scheduler: AsapScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: any, delay: number = 0): any {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(\n      scheduler.flush.bind(scheduler, null)\n    ));\n  }\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue is empty, cancel the requested microtask and\n    // set the scheduled flag to undefined so the next AsapAction will schedule\n    // its own.\n    if (scheduler.actions.length === 0) {\n      Immediate.clearImmediate(id);\n      scheduler.scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n\n    this.active = true;\n    this.scheduled = undefined;\n\n    const {actions} = this;\n    let error: any;\n    let index: number = -1;\n    let count: number = actions.length;\n    action = action || actions.shift();\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (++index < count && (action = actions.shift()));\n\n    this.active = false;\n\n    if (error) {\n      while (++index < count && (action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\nexport const asapScheduler = new AsapScheduler(AsapAction);\n\n/**\n * @deprecated renamed. Use {@link asapScheduler}\n */\nexport const asap = asapScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated renamed. Use {@link asyncScheduler}\n */\nexport const async = asyncScheduler;","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class QueueAction<T> extends AsyncAction<T> {\n\n  constructor(protected scheduler: QueueScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return (delay > 0 || this.closed) ?\n      super.execute(state, delay) :\n      this._execute(state, delay) ;\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Otherwise flush the scheduler starting with this action.\n    return scheduler.flush(this);\n  }\n}\n","import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\nexport const queueScheduler = new QueueScheduler(QueueAction);\n\n/**\n * @deprecated renamed. Use {@link queueScheduler}\n */\nexport const queue = queueScheduler;\n","export interface EmptyError extends Error {\n}\n\nexport interface EmptyErrorCtor {\n  new(): EmptyError;\n}\n\nconst EmptyErrorImpl = (() => {\n  function EmptyErrorImpl(this: any) {\n    Error.call(this);\n    this.message = 'no elements in sequence';\n    this.name = 'EmptyError';\n    return this;\n  }\n\n  EmptyErrorImpl.prototype = Object.create(Error.prototype);\n\n  return EmptyErrorImpl;\n})();\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = EmptyErrorImpl as any;","export interface ObjectUnsubscribedError extends Error {\n}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  new(): ObjectUnsubscribedError;\n}\n\nconst ObjectUnsubscribedErrorImpl = (() => {\n  function ObjectUnsubscribedErrorImpl(this: any) {\n    Error.call(this);\n    this.message = 'object unsubscribed';\n    this.name = 'ObjectUnsubscribedError';\n    return this;\n  }\n\n  ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);\n\n  return ObjectUnsubscribedErrorImpl;\n})();\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = ObjectUnsubscribedErrorImpl as any;","export interface TimeoutError extends Error {\n}\n\nexport interface TimeoutErrorCtor {\n  new(): TimeoutError;\n}\n\nconst TimeoutErrorImpl = (() => {\n  function TimeoutErrorImpl(this: any) {\n    Error.call(this);\n    this.message = 'Timeout has occurred';\n    this.name = 'TimeoutError';\n    return this;\n  }\n\n  TimeoutErrorImpl.prototype = Object.create(Error.prototype);\n\n  return TimeoutErrorImpl;\n})();\n\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link operators/timeout}\n *\n * @class TimeoutError\n */\nexport const TimeoutError: TimeoutErrorCtor = TimeoutErrorImpl as any;\n","import { isArray } from './isArray';\n\nexport function isNumeric(val: any): val is number | string {\n  // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n  // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n  // subtraction forces infinities to NaN\n  // adding 1 corrects loss of precision from parseFloat (#15100)\n  return !isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\n","export function not(pred: Function, thisArg: any): Function {\n  function notPred(): any {\n    return !((<any> notPred).pred.apply((<any> notPred).thisArg, arguments));\n  }\n  (<any> notPred).pred = pred;\n  (<any> notPred).thisArg = thisArg;\n  return notPred;\n}","import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class InnerSubscriber<T, R> extends Subscriber<R> {\n  private index = 0;\n\n  constructor(private parent: OuterSubscriber<T, R>, public outerValue: T, public outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n","import { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { Subscriber } from '../Subscriber';\nimport { subscribeTo } from './subscribeTo';\nimport { Observable } from '../Observable';\n\nexport function subscribeToResult<T, R>(\n  outerSubscriber: OuterSubscriber<T, R>,\n  result: any,\n  outerValue: undefined,\n  outerIndex: undefined,\n  innerSubscriber: InnerSubscriber<T, R>\n): Subscription | undefined;\n\nexport function subscribeToResult<T, R>(\n  outerSubscriber: OuterSubscriber<T, R>,\n  result: any,\n  outerValue?: T,\n  outerIndex?: number\n): Subscription | undefined;\n\nexport function subscribeToResult<T, R>(\n  outerSubscriber: OuterSubscriber<T, R>,\n  result: any,\n  outerValue?: T,\n  outerIndex?: number,\n  innerSubscriber: Subscriber<R> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex)\n): Subscription | undefined {\n  if (innerSubscriber.closed) {\n    return undefined;\n  }\n  if (result instanceof Observable) {\n    return result.subscribe(innerSubscriber);\n  }\n  return subscribeTo(result)(innerSubscriber) as Subscription;\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](audit.png)\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { audit } from 'rxjs/operators'\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nexport function audit<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T> {\n  return function auditOperatorFunction(source: Observable<T>) {\n    return source.lift(new AuditOperator(durationSelector));\n  };\n}\n\nclass AuditOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new AuditSubscriber<T, T>(subscriber, this.durationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass AuditSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n\n  private value?: T;\n  private hasValue: boolean = false;\n  private throttled?: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.value = value;\n    this.hasValue = true;\n    if (!this.throttled) {\n      let duration;\n      try {\n        const { durationSelector } = this;\n        duration = durationSelector(value);\n      } catch (err) {\n        return this.destination.error!(err);\n      }\n      const innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));\n      if (!innerSubscription || innerSubscription.closed) {\n        this.clearThrottle();\n      } else {\n        this.add(this.throttled = innerSubscription);\n      }\n    }\n  }\n\n  clearThrottle() {\n    const { value, hasValue, throttled } = this;\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = undefined;\n      throttled.unsubscribe();\n    }\n    if (hasValue) {\n      this.value = undefined;\n      this.hasValue = false;\n      this.destination.next!(value);\n    }\n  }\n\n  notifyNext(): void {\n    this.clearThrottle();\n  }\n\n  notifyComplete(): void {\n    this.clearThrottle();\n  }\n}\n","import { async } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source value, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * ![](auditTime.png)\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link SchedulerLike} for managing timers.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { auditTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(auditTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nexport function auditTime<T>(duration: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return audit(() => timer(duration, scheduler));\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * ![](buffer.png)\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * ## Example\n *\n * On every click, emit array of most recent interval events\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { buffer } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const intervalEvents = interval(1000);\n * const buffered = intervalEvents.pipe(buffer(clicks));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nexport function buffer<T>(closingNotifier: Observable<any>): OperatorFunction<T, T[]> {\n  return function bufferOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferOperator<T>(closingNotifier));\n  };\n}\n\nclass BufferOperator<T> implements Operator<T, T[]> {\n\n  constructor(private closingNotifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferSubscriber<T> extends SimpleOuterSubscriber<T, any> {\n  private buffer: T[] = [];\n\n  constructor(destination: Subscriber<T[]>, closingNotifier: Observable<any>) {\n    super(destination);\n    this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));\n  }\n\n  protected _next(value: T) {\n    this.buffer.push(value);\n  }\n\n  notifyNext(): void {\n    const buffer = this.buffer;\n    this.buffer = [];\n    this.destination.next!(buffer);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * ![](bufferCount.png)\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * ## Examples\n *\n * Emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferCount } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * On every click, emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferCount } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2, 1));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nexport function bufferCount<T>(bufferSize: number, startBufferEvery: number = null): OperatorFunction<T, T[]> {\n  return function bufferCountOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferCountOperator<T>(bufferSize, startBufferEvery));\n  };\n}\n\nclass BufferCountOperator<T> implements Operator<T, T[]> {\n  private subscriberClass: any;\n\n  constructor(private bufferSize: number, private startBufferEvery: number) {\n    if (!startBufferEvery || bufferSize === startBufferEvery) {\n      this.subscriberClass = BufferCountSubscriber;\n    } else {\n      this.subscriberClass = BufferSkipCountSubscriber;\n    }\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): TeardownLogic {\n    return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferCountSubscriber<T> extends Subscriber<T> {\n  private buffer: T[] = [];\n\n  constructor(destination: Subscriber<T[]>, private bufferSize: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const buffer = this.buffer;\n\n    buffer.push(value);\n\n    if (buffer.length == this.bufferSize) {\n      this.destination.next(buffer);\n      this.buffer = [];\n    }\n  }\n\n  protected _complete(): void {\n    const buffer = this.buffer;\n    if (buffer.length > 0) {\n      this.destination.next(buffer);\n    }\n    super._complete();\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferSkipCountSubscriber<T> extends Subscriber<T> {\n  private buffers: Array<T[]> = [];\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T[]>, private bufferSize: number, private startBufferEvery: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const { bufferSize, startBufferEvery, buffers, count } = this;\n\n    this.count++;\n    if (count % startBufferEvery === 0) {\n      buffers.push([]);\n    }\n\n    for (let i = buffers.length; i--; ) {\n      const buffer = buffers[i];\n      buffer.push(value);\n      if (buffer.length === bufferSize) {\n        buffers.splice(i, 1);\n        this.destination.next(buffer);\n      }\n    }\n  }\n\n  protected _complete(): void {\n    const { buffers, destination } = this;\n\n    while (buffers.length > 0) {\n      let buffer = buffers.shift();\n      if (buffer.length > 0) {\n        destination.next(buffer);\n      }\n    }\n    super._complete();\n  }\n\n}\n","import { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction, SchedulerAction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, maxBufferSize: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * ![](bufferTime.png)\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nexport function bufferTime<T>(bufferTimeSpan: number): OperatorFunction<T, T[]> {\n  let length: number = arguments.length;\n\n  let scheduler: SchedulerLike = async;\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  let bufferCreationInterval: number = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  let maxBufferSize: number = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferTimeOperator<T>(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nclass BufferTimeOperator<T> implements Operator<T, T[]> {\n  constructor(private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferTimeSubscriber(\n      subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler\n    ));\n  }\n}\n\nclass Context<T> {\n  buffer: T[] = [];\n  closeAction: Subscription;\n}\n\ninterface DispatchCreateArg<T> {\n  bufferTimeSpan: number;\n  bufferCreationInterval: number;\n  subscriber: BufferTimeSubscriber<T>;\n  scheduler: SchedulerLike;\n}\n\ninterface DispatchCloseArg<T> {\n  subscriber: BufferTimeSubscriber<T>;\n  context: Context<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferTimeSubscriber<T> extends Subscriber<T> {\n  private contexts: Array<Context<T>> = [];\n  private timespanOnly: boolean;\n\n  constructor(destination: Subscriber<T[]>,\n              private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    const context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n    if (this.timespanOnly) {\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      const closeState = { subscriber: this, context };\n      const creationState: DispatchCreateArg<T> = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n      this.add(context.closeAction = scheduler.schedule<DispatchCloseArg<T>>(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule<DispatchCreateArg<T>>(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n\n  protected _next(value: T) {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    let filledBufferContext: Context<T>;\n    for (let i = 0; i < len; i++) {\n      const context = contexts[i];\n      const buffer = context.buffer;\n      buffer.push(value);\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  }\n\n  protected _error(err: any) {\n    this.contexts.length = 0;\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts, destination } = this;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      destination.next(context.buffer);\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.contexts = null;\n  }\n\n  protected onBufferFull(context: Context<T>) {\n    this.closeContext(context);\n    const closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      const bufferTimeSpan = this.bufferTimeSpan;\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  openContext(): Context<T> {\n    const context: Context<T> = new Context<T>();\n    this.contexts.push(context);\n    return context;\n  }\n\n  closeContext(context: Context<T>) {\n    this.destination.next(context.buffer);\n    const contexts = this.contexts;\n\n    const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  }\n}\n\nfunction dispatchBufferTimeSpanOnly(this: SchedulerAction<any>, state: any) {\n  const subscriber: BufferTimeSubscriber<any> = state.subscriber;\n\n  const prevContext = state.context;\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation<T>(this: SchedulerAction<DispatchCreateArg<T>>, state: DispatchCreateArg<T>) {\n  const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n  const context = subscriber.openContext();\n  const action = <SchedulerAction<DispatchCreateArg<T>>>this;\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule<DispatchCloseArg<T>>(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose<T>(arg: DispatchCloseArg<T>) {\n  const { subscriber, context } = arg;\n  subscriber.closeContext(context);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction, SubscribableOrPromise } from '../types';\n\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * ![](bufferToggle.png)\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```ts\n * import { fromEvent, interval, EMPTY } from 'rxjs';\n * import { bufferToggle } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const buffered = clicks.pipe(bufferToggle(openings, i =>\n *   i % 2 ? interval(500) : EMPTY\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nexport function bufferToggle<T, O>(\n  openings: SubscribableOrPromise<O>,\n  closingSelector: (value: O) => SubscribableOrPromise<any>\n): OperatorFunction<T, T[]> {\n  return function bufferToggleOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferToggleOperator<T, O>(openings, closingSelector));\n  };\n}\n\nclass BufferToggleOperator<T, O> implements Operator<T, T[]> {\n\n  constructor(private openings: SubscribableOrPromise<O>,\n              private closingSelector: (value: O) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n  }\n}\n\ninterface BufferContext<T> {\n  buffer: T[];\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferToggleSubscriber<T, O> extends OuterSubscriber<T, O> {\n  private contexts: Array<BufferContext<T>> = [];\n\n  constructor(destination: Subscriber<T[]>,\n              openings: SubscribableOrPromise<O>,\n              private closingSelector: (value: O) => SubscribableOrPromise<any> | void) {\n    super(destination);\n    this.add(subscribeToResult(this, openings));\n  }\n\n  protected _next(value: T): void {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    for (let i = 0; i < len; i++) {\n      contexts[i].buffer.push(value);\n    }\n  }\n\n  protected _error(err: any): void {\n    const contexts = this.contexts;\n    while (contexts.length > 0) {\n      const context = contexts.shift()!;\n      context.subscription.unsubscribe();\n      context.buffer = null!;\n      context.subscription = null!;\n    }\n    this.contexts = null!;\n    super._error(err);\n  }\n\n  protected _complete(): void {\n    const contexts = this.contexts;\n    while (contexts.length > 0) {\n      const context = contexts.shift()!;\n      this.destination.next!(context.buffer);\n      context.subscription.unsubscribe();\n      context.buffer = null!;\n      context.subscription = null!;\n    }\n    this.contexts = null!;\n    super._complete();\n  }\n\n  notifyNext(outerValue: any, innerValue: O): void {\n    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, O>): void {\n    this.closeBuffer((<any> innerSub).context);\n  }\n\n  private openBuffer(value: O): void {\n    try {\n      const closingSelector = this.closingSelector;\n      const closingNotifier = closingSelector.call(this, value);\n      if (closingNotifier) {\n        this.trySubscribe(closingNotifier);\n      }\n    } catch (err) {\n      this._error(err);\n    }\n  }\n\n  private closeBuffer(context: BufferContext<T>): void {\n    const contexts = this.contexts;\n\n    if (contexts && context) {\n      const { buffer, subscription } = context;\n      this.destination.next!(buffer);\n      contexts.splice(contexts.indexOf(context), 1);\n      this.remove(subscription);\n      subscription.unsubscribe();\n    }\n  }\n\n  private trySubscribe(closingNotifier: any): void {\n    const contexts = this.contexts;\n\n    const buffer: Array<T> = [];\n    const subscription = new Subscription();\n    const context = { buffer, subscription };\n    contexts.push(context);\n\n    const innerSubscription = subscribeToResult(this, closingNotifier, context as any);\n\n    if (!innerSubscription || innerSubscription.closed) {\n      this.closeBuffer(context);\n    } else {\n      (innerSubscription as any).context = context;\n\n      this.add(innerSubscription);\n      subscription.add(innerSubscription);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { OperatorFunction } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * ![](bufferWhen.png)\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * ## Example\n *\n * Emit an array of the last clicks every [1-5] random seconds\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { bufferWhen } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferWhen(() =>\n *   interval(1000 + Math.random() * 4000)\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nexport function bufferWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, T[]> {\n  return function (source: Observable<T>) {\n    return source.lift(new BufferWhenOperator(closingSelector));\n  };\n}\n\nclass BufferWhenOperator<T> implements Operator<T, T[]> {\n\n  constructor(private closingSelector: () => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferWhenSubscriber<T> extends SimpleOuterSubscriber<T, any> {\n  private buffer?: T[];\n  private subscribing: boolean = false;\n  private closingSubscription?: Subscription;\n\n  constructor(destination: Subscriber<T[]>, private closingSelector: () => Observable<any>) {\n    super(destination);\n    this.openBuffer();\n  }\n\n  protected _next(value: T) {\n    this.buffer!.push(value);\n  }\n\n  protected _complete() {\n    const buffer = this.buffer;\n    if (buffer) {\n      this.destination.next!(buffer);\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.buffer = undefined;\n    this.subscribing = false;\n  }\n\n  notifyNext(): void {\n    this.openBuffer();\n  }\n\n  notifyComplete(): void {\n    if (this.subscribing) {\n      this.complete();\n    } else {\n      this.openBuffer();\n    }\n  }\n\n  openBuffer() {\n    let { closingSubscription } = this;\n\n    if (closingSubscription) {\n      this.remove(closingSubscription);\n      closingSubscription.unsubscribe();\n    }\n\n    const buffer = this.buffer;\n    if (this.buffer) {\n      this.destination.next!(buffer);\n    }\n\n    this.buffer = [];\n\n    let closingNotifier;\n    try {\n      const { closingSelector } = this;\n      closingNotifier = closingSelector();\n    } catch (err) {\n      return this.error(err);\n    }\n    closingSubscription = new Subscription();\n    this.closingSubscription = closingSubscription;\n    this.add(closingSubscription);\n    this.subscribing = true;\n    closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));\n    this.subscribing = false;\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\n\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function catchError<T, O extends ObservableInput<any>>(selector: (err: any, caught: Observable<T>) => O): OperatorFunction<T, T | ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * ![](catch.png)\n *\n * ## Examples\n * Continues with a different Observable when there's an error\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { map, catchError } from 'rxjs/operators';\n *\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *   \t   if (n === 4) {\n * \t       throw 'four!';\n *       }\n *\t     return n;\n *     }),\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V')),\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n * ```\n *\n * Retries the caught source Observable again in case of error, similar to retry() operator\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { map, catchError, take } from 'rxjs/operators';\n *\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *   \t   if (n === 4) {\n *   \t     throw 'four!';\n *       }\n * \t     return n;\n *     }),\n *     catchError((err, caught) => caught),\n *     take(30),\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n * ```\n *\n * Throws a new error when the source Observable throws an error\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { map, catchError } from 'rxjs/operators';\n *\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => {\n *       throw 'error in source. Details: ' + err;\n *     }),\n *   )\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n * ```\n *\n *  @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  return function catchErrorOperatorFunction(source: Observable<T>): Observable<T | ObservedValueOf<O>> {\n    const operator = new CatchOperator(selector);\n    const caught = source.lift(operator);\n    return (operator.caught = caught as Observable<T>);\n  };\n}\n\nclass CatchOperator<T, R> implements Operator<T, T | R> {\n  caught: Observable<T>;\n\n  constructor(private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass CatchSubscriber<T, R> extends SimpleOuterSubscriber<T, T | R> {\n  constructor(destination: Subscriber<any>,\n              private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>,\n              private caught: Observable<T>) {\n    super(destination);\n  }\n\n  // NOTE: overriding `error` instead of `_error` because we don't want\n  // to have this flag this subscriber as `isStopped`. We can mimic the\n  // behavior of the RetrySubscriber (from the `retry` operator), where\n  // we unsubscribe from our source chain, reset our Subscriber flags,\n  // then subscribe to the selector result.\n  error(err: any) {\n    if (!this.isStopped) {\n      let result: any;\n      try {\n        result = this.selector(err, this.caught);\n      } catch (err2) {\n        super.error(err2);\n        return;\n      }\n      this._unsubscribeAndRecycle();\n      const innerSubscriber = new SimpleInnerSubscriber(this);\n      this.add(innerSubscriber);\n      const innerSubscription = innerSubscribe(result, innerSubscriber);\n      // The returned subscription will usually be the subscriber that was\n      // passed. However, interop subscribers will be wrapped and for\n      // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n      if (innerSubscription !== innerSubscriber) {\n        this.add(innerSubscription);\n      }\n    }\n  }\n}\n","import { CombineLatestOperator } from '../observable/combineLatest';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, ObservableInput } from '../types';\n\nexport function combineAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function combineAll<T>(): OperatorFunction<any, T[]>;\nexport function combineAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function combineAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n/**\n * Flattens an Observable-of-Observables by applying {@link combineLatest} when the Observable-of-Observables completes.\n *\n * ![](combineAll.png)\n *\n * `combineAll` takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes,\n * it subscribes to all collected Observables and combines their values using the {@link combineLatest}</a> strategy, such that:\n *\n * * Every time an inner Observable emits, the output Observable emits\n * * When the returned observable emits, it emits all of the latest values by:\n *    * If a `project` function is provided, it is called with each recent value from each inner Observable in whatever order they\n *      arrived, and the result of the `project` function is what is emitted by the output Observable.\n *    * If there is no `project` function, an array of all the most recent values is emitted by the output Observable.\n *\n * ---\n *\n * ## Examples\n *\n * ### Map two click events to a finite interval Observable, then apply `combineAll`\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { map, combineAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(ev =>\n *      interval(Math.random() * 2000).pipe(take(3))\n *   ),\n *   take(2)\n * );\n * const result = higherOrder.pipe(\n *   combineAll()\n * );\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link mergeAll}\n *\n * @param {function(...values: Array<any>)} An optional function to map the most recent values from each inner Observable into a new result.\n * Takes each of the most recent values from each collected inner Observable as arguments, in order.\n * @return {Observable<T>}\n * @name combineAll\n */\nexport function combineAll<T, R>(project?: (...values: Array<any>) => R): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new CombineLatestOperator(project));\n}\n","\nimport { isArray } from '../util/isArray';\nimport { CombineLatestOperator } from '../observable/combineLatest';\nimport { from } from '../observable/from';\nimport { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction } from '../types';\n\nconst none = {};\n\n/* tslint:disable:max-line-length */\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, R>(array: ObservableInput<T>[]): OperatorFunction<T, Array<T>>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, TOther, R>(array: ObservableInput<TOther>[], project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * @deprecated Deprecated in favor of static {@link combineLatest}.\n */\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<any> |\n                                                    Array<ObservableInput<any>> |\n                                                    ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  let project: (...values: Array<any>) => R = null;\n  if (typeof observables[observables.length - 1] === 'function') {\n    project = <(...values: Array<any>) => R>observables.pop();\n  }\n\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n  if (observables.length === 1 && isArray(observables[0])) {\n    observables = (<any>observables[0]).slice();\n  }\n\n  return (source: Observable<T>) => source.lift.call(from([source, ...observables]), new CombineLatestOperator(project));\n}\n","import {  concat as concatStatic } from '../observable/concat';\nimport { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction, MonoTypeOperatorFunction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, T2>(v2: ObservableInput<T2>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T>(...observables: Array<ObservableInput<T> | SchedulerLike>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * @deprecated Deprecated in favor of static {@link concat}.\n */\nexport function concat<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike>): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift.call(concatStatic(source, ...observables));\n}\n","import { mergeMap } from './mergeMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function concatMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) =>  O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function concatMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function concatMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) =>  O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * ![](concatMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { concatMap, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMap(ev => interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional deprecated `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  return mergeMap(project, resultSelector, 1);\n}\n","import { concatMap } from './concatMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function concatMapTo<T, O extends ObservableInput<any>>(observable: O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated */\nexport function concatMapTo<T, O extends ObservableInput<any>>(observable: O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated */\nexport function concatMapTo<T, R, O extends ObservableInput<any>>(observable: O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](concatMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * ## Example\n * For each click event, tick every second from 0 to 3, with no concurrency\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { concatMapTo, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMapTo(interval(1000).pipe(take(4))),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\nexport function concatMapTo<T, R, O extends ObservableInput<any>>(\n  innerObservable: O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  return concatMap(() => innerObservable, resultSelector);\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Observer, OperatorFunction } from '../types';\nimport { Subscriber } from '../Subscriber';\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * ![](count.png)\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * ## Examples\n *\n * Counts how many seconds have passed before the first click happened\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { count, takeUntil } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const secondsBeforeClick = seconds.pipe(takeUntil(clicks));\n * const result = secondsBeforeClick.pipe(count());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Counts how many odd numbers are there between 1 and 7\n * ```ts\n * import { range } from 'rxjs';\n * import { count } from 'rxjs/operators';\n *\n * const numbers = range(1, 7);\n * const result = numbers.pipe(count(i => i % 2 === 1));\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // 4\n * ```\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\n\nexport function count<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, number> {\n  return (source: Observable<T>) => source.lift(new CountOperator(predicate, source));\n}\n\nclass CountOperator<T> implements Operator<T, number> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<number>, source: any): any {\n    return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass CountSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n  private index: number = 0;\n\n  constructor(destination: Observer<number>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.predicate) {\n      this._tryPredicate(value);\n    } else {\n      this.count++;\n    }\n  }\n\n  private _tryPredicate(value: T) {\n    let result: any;\n\n    try {\n      result = this.predicate(value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.count++;\n    }\n  }\n\n  protected _complete(): void {\n    this.destination.next(this.count);\n    this.destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * ![](debounce.png)\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { debounce } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounce(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nexport function debounce<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceOperator(durationSelector));\n}\n\nclass DebounceOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private value?: T;\n  private hasValue = false;\n  private durationSubscription?: Subscription;\n\n  constructor(destination: Subscriber<R>,\n              private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    try {\n      const result = this.durationSelector.call(this, value);\n\n      if (result) {\n        this._tryNext(value, result);\n      }\n    } catch (err) {\n      this.destination.error!(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.emitValue();\n    this.destination.complete!();\n  }\n\n  private _tryNext(value: T, duration: SubscribableOrPromise<any>): void {\n    let subscription = this.durationSubscription;\n    this.value = value;\n    this.hasValue = true;\n    if (subscription) {\n      subscription.unsubscribe();\n      this.remove(subscription);\n    }\n\n    subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));\n    if (subscription && !subscription.closed) {\n      this.add(this.durationSubscription = subscription);\n    }\n  }\n\n  notifyNext(): void {\n    this.emitValue();\n  }\n\n  notifyComplete(): void {\n    this.emitValue();\n  }\n\n  emitValue(): void {\n    if (this.hasValue) {\n      const value = this.value;\n      const subscription = this.durationSubscription;\n      if (subscription) {\n        this.durationSubscription = undefined;\n        subscription.unsubscribe();\n        this.remove(subscription);\n      }\n      // This must be done *before* passing the value\n      // along to the destination because it's possible for\n      // the value to synchronously re-enter this operator\n      // recursively if the duration selector Observable\n      // emits synchronously\n      this.value = undefined;\n      this.hasValue = false;\n      super._next(value!);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { debounceTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\n\nclass DebounceTimeOperator<T> implements Operator<T, T> {\n  constructor(private dueTime: number, private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceTimeSubscriber<T> extends Subscriber<T> {\n  private debouncedSubscription: Subscription = null;\n  private lastValue: T = null;\n  private hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private dueTime: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.clearDebounce();\n    this.lastValue = value;\n    this.hasValue = true;\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n  }\n\n  protected _complete() {\n    this.debouncedNext();\n    this.destination.complete();\n  }\n\n  debouncedNext(): void {\n    this.clearDebounce();\n\n    if (this.hasValue) {\n      const { lastValue } = this;\n      // This must be done *before* passing the value\n      // along to the destination because it's possible for\n      // the value to synchronously re-enter this operator\n      // recursively when scheduled with things like\n      // VirtualScheduler/TestScheduler.\n      this.lastValue = null;\n      this.hasValue = false;\n      this.destination.next(lastValue);\n    }\n  }\n\n  private clearDebounce(): void {\n    const debouncedSubscription = this.debouncedSubscription;\n\n    if (debouncedSubscription !== null) {\n      this.remove(debouncedSubscription);\n      debouncedSubscription.unsubscribe();\n      this.debouncedSubscription = null;\n    }\n  }\n}\n\nfunction dispatchNext(subscriber: DebounceTimeSubscriber<any>) {\n  subscriber.debouncedNext();\n}\n","export function isDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(+value);\n}\n","import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Notification } from '../Notification';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * ![](delay.png)\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * ## Examples\n * Delay each click by one second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { delay } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * Delay all clicks until a future date happens\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { delay } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nexport function delay<T>(delay: number|Date,\n                         scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  const absoluteDelay = isDate(delay);\n  const delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(<number>delay);\n  return (source: Observable<T>) => source.lift(new DelayOperator(delayFor, scheduler));\n}\n\nclass DelayOperator<T> implements Operator<T, T> {\n  constructor(private delay: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n  }\n}\n\ninterface DelayState<T> {\n  source: DelaySubscriber<T>;\n  destination: PartialObserver<T>;\n  scheduler: SchedulerLike;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DelaySubscriber<T> extends Subscriber<T> {\n  private queue: Array<DelayMessage<T>> = [];\n  private active: boolean = false;\n  private errored: boolean = false;\n\n  private static dispatch<T>(this: SchedulerAction<DelayState<T>>, state: DelayState<T>): void {\n    const source = state.source;\n    const queue = source.queue;\n    const scheduler = state.scheduler;\n    const destination = state.destination;\n\n    while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n\n    if (queue.length > 0) {\n      const delay = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay);\n    } else {\n      this.unsubscribe();\n      source.active = false;\n    }\n  }\n\n  constructor(destination: Subscriber<T>,\n              private delay: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n  }\n\n  private _schedule(scheduler: SchedulerLike): void {\n    this.active = true;\n    const destination = this.destination as Subscription;\n    destination.add(scheduler.schedule<DelayState<T>>(DelaySubscriber.dispatch, this.delay, {\n      source: this, destination: this.destination, scheduler: scheduler\n    }));\n  }\n\n  private scheduleNotification(notification: Notification<T>): void {\n    if (this.errored === true) {\n      return;\n    }\n\n    const scheduler = this.scheduler;\n    const message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  }\n\n  protected _next(value: T) {\n    this.scheduleNotification(Notification.createNext(value));\n  }\n\n  protected _error(err: any) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete() {\n    this.scheduleNotification(Notification.createComplete());\n    this.unsubscribe();\n  }\n}\n\nclass DelayMessage<T> {\n  constructor(public readonly time: number,\n              public readonly notification: Notification<T>) {\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated In future versions, empty notifiers will no longer re-emit the source value on the output observable. */\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<never>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<any>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;\n/* tslint:disable:max-line-length */\n\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * ![](delayWhen.png)\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n * The completion of the notifier triggering the emission of the source value\n * is deprecated behavior and will be removed in future versions.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * ## Example\n * Delay each click by a random amount of time, between 0 and 5 seconds\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { delayWhen } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(\n *   delayWhen(event => interval(Math.random() * 5000)),\n * );\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delay}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param {function(value: T, index: number): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<any>,\n                             subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T> {\n  if (subscriptionDelay) {\n    return (source: Observable<T>) =>\n      new SubscriptionDelayObservable(source, subscriptionDelay)\n        .lift(new DelayWhenOperator(delayDurationSelector));\n  }\n  return (source: Observable<T>) => source.lift(new DelayWhenOperator(delayDurationSelector));\n}\n\nclass DelayWhenOperator<T> implements Operator<T, T> {\n  constructor(private delayDurationSelector: (value: T, index: number) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DelayWhenSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private completed: boolean = false;\n  private delayNotifierSubscriptions: Array<Subscription> = [];\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private delayDurationSelector: (value: T, index: number) => Observable<any>) {\n    super(destination);\n  }\n\n  notifyNext(outerValue: T, _innerValue: any,\n             _outerIndex: number, _innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next!(outerValue);\n    this.removeSubscription(innerSub);\n    this.tryComplete();\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this._error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    const value = this.removeSubscription(innerSub);\n    if (value) {\n      this.destination.next!(value);\n    }\n    this.tryComplete();\n  }\n\n  protected _next(value: T): void {\n    const index = this.index++;\n    try {\n      const delayNotifier = this.delayDurationSelector(value, index);\n      if (delayNotifier) {\n        this.tryDelay(delayNotifier, value);\n      }\n    } catch (err) {\n      this.destination.error!(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.completed = true;\n    this.tryComplete();\n    this.unsubscribe();\n  }\n\n  private removeSubscription(subscription: InnerSubscriber<T, R>): T {\n    subscription.unsubscribe();\n\n    const subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n    if (subscriptionIdx !== -1) {\n      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n    }\n\n    return subscription.outerValue;\n  }\n\n  private tryDelay(delayNotifier: Observable<any>, value: T): void {\n    const notifierSubscription = subscribeToResult(this, delayNotifier, value);\n\n    if (notifierSubscription && !notifierSubscription.closed) {\n      const destination = this.destination as Subscription;\n      destination.add(notifierSubscription);\n      this.delayNotifierSubscriptions.push(notifierSubscription);\n    }\n  }\n\n  private tryComplete(): void {\n    if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n      this.destination.complete!();\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SubscriptionDelayObservable<T> extends Observable<T> {\n  constructor(public source: Observable<T>, private subscriptionDelay: Observable<any>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SubscriptionDelaySubscriber<T> extends Subscriber<T> {\n  private sourceSubscribed: boolean = false;\n\n  constructor(private parent: Subscriber<T>, private source: Observable<T>) {\n    super();\n  }\n\n  protected _next(unused: any) {\n    this.subscribeToSource();\n  }\n\n  protected _error(err: any) {\n    this.unsubscribe();\n    this.parent.error(err);\n  }\n\n  protected _complete() {\n    this.unsubscribe();\n    this.subscribeToSource();\n  }\n\n  private subscribeToSource(): void {\n    if (!this.sourceSubscribed) {\n      this.sourceSubscribed = true;\n      this.unsubscribe();\n      this.source.subscribe(this.parent);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { OperatorFunction } from '../types';\n\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * ![](dematerialize.png)\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * ## Example\n * Convert an Observable of Notifications to an actual Observable\n * ```ts\n * import { of, Notification } from 'rxjs';\n * import { dematerialize } from 'rxjs/operators';\n *\n * const notifA = new Notification('N', 'A');\n * const notifB = new Notification('N', 'B');\n * const notifE = new Notification('E', undefined,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * const materialized = of(notifA, notifB, notifE);\n * const upperCase = materialized.pipe(dematerialize());\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n * ```\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nexport function dematerialize<T>(): OperatorFunction<Notification<T>, T> {\n  return function dematerializeOperatorFunction(source: Observable<Notification<T>>) {\n    return source.lift(new DeMaterializeOperator());\n  };\n}\n\nclass DeMaterializeOperator<T extends Notification<any>, R> implements Operator<T, R> {\n  call(subscriber: Subscriber<any>, source: any): any {\n    return source.subscribe(new DeMaterializeSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DeMaterializeSubscriber<T extends Notification<any>> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    value.observe(this.destination);\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * ## Examples\n * A simple example with numbers\n * ```ts\n * import { of } from 'rxjs';\n * import { distinct } from 'rxjs/operators';\n *\n * of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1).pipe(\n *     distinct(),\n *   )\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n * ```\n *\n * An example using a keySelector function\n * ```typescript\n * import { of } from 'rxjs';\n * import { distinct } from 'rxjs/operators';\n *\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *   ).pipe(\n *     distinct((p: Person) => p.name),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * ```\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nexport function distinct<T, K>(keySelector?: (value: T) => K,\n                               flushes?: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DistinctOperator(keySelector, flushes));\n}\n\nclass DistinctOperator<T, K> implements Operator<T, T> {\n  constructor(private keySelector?: (value: T) => K, private flushes?: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class DistinctSubscriber<T, K> extends SimpleOuterSubscriber<T, T> {\n  private values = new Set<K>();\n\n  constructor(destination: Subscriber<T>, private keySelector?: (value: T) => K, flushes?: Observable<any>) {\n    super(destination);\n\n    if (flushes) {\n      this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(this)));\n    }\n  }\n\n  notifyNext(): void {\n    this.values.clear();\n  }\n\n  notifyError(error: any): void {\n    this._error(error);\n  }\n\n  protected _next(value: T): void {\n    if (this.keySelector) {\n      this._useKeySelector(value);\n    } else {\n      this._finalizeNext(value, value);\n    }\n  }\n\n  private _useKeySelector(value: T): void {\n    let key: K;\n    const { destination } = this;\n    try {\n      key = this.keySelector!(value);\n    } catch (err) {\n      destination.error!(err);\n      return;\n    }\n    this._finalizeNext(key, value);\n  }\n\n  private _finalizeNext(key: K|T, value: T) {\n    const { values } = this;\n    if (!values.has(<K>key)) {\n      values.add(<K>key);\n      this.destination.next!(value);\n    }\n  }\n\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function distinctUntilChanged<T>(compare?: (x: T, y: T) => boolean): MonoTypeOperatorFunction<T>;\nexport function distinctUntilChanged<T, K>(compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * ## Example\n * A simple example with numbers\n * ```ts\n * import { of } from 'rxjs';\n * import { distinctUntilChanged } from 'rxjs/operators';\n *\n * of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4).pipe(\n *     distinctUntilChanged(),\n *   )\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n * ```\n *\n * An example using a compare function\n * ```typescript\n * import { of } from 'rxjs';\n * import { distinctUntilChanged } from 'rxjs/operators';\n *\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'},\n *   ).pipe(\n *     distinctUntilChanged((p: Person, q: Person) => p.name === q.name),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nexport function distinctUntilChanged<T, K>(compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DistinctUntilChangedOperator<T, K>(compare, keySelector));\n}\n\nclass DistinctUntilChangedOperator<T, K> implements Operator<T, T> {\n  constructor(private compare: (x: K, y: K) => boolean,\n              private keySelector: (x: T) => K) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DistinctUntilChangedSubscriber<T, K> extends Subscriber<T> {\n  private key: K;\n  private hasKey: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              compare: (x: K, y: K) => boolean,\n              private keySelector: (x: T) => K) {\n    super(destination);\n    if (typeof compare === 'function') {\n      this.compare = compare;\n    }\n  }\n\n  private compare(x: any, y: any): boolean {\n    return x === y;\n  }\n\n  protected _next(value: T): void {\n    let key: any;\n    try {\n      const { keySelector } = this;\n      key = keySelector ? keySelector(value) : value;\n    } catch (err) {\n      return this.destination.error(err);\n    }\n    let result = false;\n    if (this.hasKey) {\n      try {\n        const { compare } = this;\n        result = compare(this.key, key);\n      } catch (err) {\n        return this.destination.error(err);\n      }\n    } else {\n      this.hasKey = true;\n    }\n    if (!result) {\n      this.key = key;\n      this.destination.next(value);\n    }\n  }\n}\n","import { distinctUntilChanged } from './distinctUntilChanged';\nimport { MonoTypeOperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function distinctUntilKeyChanged<T>(key: keyof T): MonoTypeOperatorFunction<T>;\nexport function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * ## Examples\n * An example comparing the name of persons\n * ```typescript\n * import { of } from 'rxjs';\n * import { distinctUntilKeyChanged } from 'rxjs/operators';\n *\n *  interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'},\n *   ).pipe(\n *     distinctUntilKeyChanged('name'),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n * ```\n *\n * An example comparing the first letters of the name\n * ```typescript\n * import { of } from 'rxjs';\n * import { distinctUntilKeyChanged } from 'rxjs/operators';\n *\n * interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo1'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo2'},\n *     { age: 6, name: 'Foo3'},\n *   ).pipe(\n *     distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3)),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\nexport function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare?: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T> {\n  return distinctUntilChanged((x: T, y: T) => compare ? compare(x[key], y[key]) : x[key] === y[key]);\n}\n","import { EmptyError } from '../util/EmptyError';\nimport { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic, MonoTypeOperatorFunction } from '../types';\n\n/**\n * If the source observable completes without emitting a value, it will emit\n * an error. The error will be created at that time by the optional\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\n *\n * ![](throwIfEmpty.png)\n *\n * ## Example\n * ```ts\n * import { fromEvent, timer } from 'rxjs';\n * import { throwIfEmpty, takeUntil } from 'rxjs/operators';\n *\n * const click$ = fromEvent(document, 'click');\n *\n * click$.pipe(\n *   takeUntil(timer(1000)),\n *   throwIfEmpty(\n *     () => new Error('the document was not clicked within 1 second')\n *   ),\n * )\n * .subscribe({\n *   next() { console.log('The button was clicked'); },\n *   error(err) { console.error(err); }\n * });\n * ```\n *\n * @param errorFactory A factory function called to produce the\n * error to be thrown when the source observable completes without emitting a\n * value.\n */\nexport function throwIfEmpty <T>(errorFactory: (() => any) = defaultErrorFactory): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    return source.lift(new ThrowIfEmptyOperator(errorFactory));\n  };\n}\n\nclass ThrowIfEmptyOperator<T> implements Operator<T, T> {\n  constructor(private errorFactory: () => any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));\n  }\n}\n\nclass ThrowIfEmptySubscriber<T> extends Subscriber<T> {\n  private hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>, private errorFactory: () => any) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.hasValue = true;\n    this.destination.next(value);\n  }\n\n  protected _complete() {\n    if (!this.hasValue) {\n      let err: any;\n      try {\n        err = this.errorFactory();\n      } catch (e) {\n        err = e;\n      }\n      this.destination.error(err);\n    } else {\n        return this.destination.complete();\n    }\n  }\n}\n\nfunction defaultErrorFactory() {\n  return new EmptyError();\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n * Take the first 5 seconds of an infinite 1-second interval Observable\n * ```ts\n * import { interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nclass TakeOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const total = this.total;\n    const count = ++this.count;\n    if (count <= total) {\n      this.destination.next(value);\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { filter } from './filter';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { take } from './take';\n\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * ![](elementAt.png)\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * ## Example\n * Emit only the third click event\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { elementAt } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(elementAt(2));\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n * ```\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nexport function elementAt<T>(index: number, defaultValue?: T): MonoTypeOperatorFunction<T> {\n  if (index < 0) { throw new ArgumentOutOfRangeError(); }\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) => source.pipe(\n    filter((v, i) => i === index),\n    take(1),\n    hasDefaultValue\n      ? defaultIfEmpty(defaultValue)\n      : throwIfEmpty(() => new ArgumentOutOfRangeError()),\n  );\n}\n","import { Observable } from '../Observable';\nimport { concat } from '../observable/concat';\nimport { of } from '../observable/of';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T>(scheduler: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A>(v1: A, scheduler: SchedulerLike): OperatorFunction<T, T | A>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A, B>(v1: A, v2: B, scheduler: SchedulerLike): OperatorFunction<T, T | A | B>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A, B, C>(v1: A, v2: B, v3: C, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A, B, C, D>(v1: A, v2: B, v3: C, v4: D, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C | D>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A, B, C, D, E>(v1: A, v2: B, v3: C, v4: D, v5: E, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C | D | E>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A, B, C, D, E, F>(v1: A, v2: B, v3: C, v4: D, v5: E, v6: F, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C | D | E | F>;\n\nexport function endWith<T, A>(v1: A): OperatorFunction<T, T | A>;\nexport function endWith<T, A, B>(v1: A, v2: B): OperatorFunction<T, T | A | B>;\nexport function endWith<T, A, B, C>(v1: A, v2: B, v3: C): OperatorFunction<T, T | A | B | C>;\nexport function endWith<T, A, B, C, D>(v1: A, v2: B, v3: C, v4: D): OperatorFunction<T, T | A | B | C | D>;\nexport function endWith<T, A, B, C, D, E>(v1: A, v2: B, v3: C, v4: D, v5: E): OperatorFunction<T, T | A | B | C | D | E>;\nexport function endWith<T, A, B, C, D, E, F>(v1: A, v2: B, v3: C, v4: D, v5: E, v6: F): OperatorFunction<T, T | A | B | C | D | E | F>;\nexport function endWith<T, Z = T>(...array: Z[]): OperatorFunction<T, T | Z>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, Z = T>(...array: Array<Z | SchedulerLike>): OperatorFunction<T, T | Z>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the items you specify as arguments after it finishes emitting\n * items emitted by the source Observable.\n *\n * ![](endWith.png)\n *\n * ## Example\n * ### After the source observable completes, appends an emission and then completes too.\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { endWith } from 'rxjs/operators';\n *\n * of('hi', 'how are you?', 'sorry, I have to go now').pipe(\n *   endWith('goodbye!'),\n * )\n * .subscribe(word => console.log(word));\n * // result:\n * // 'hi'\n * // 'how are you?'\n * // 'sorry, I have to go now'\n * // 'goodbye!'\n * ```\n *\n * @param {...T} values - Items you want the modified Observable to emit last.\n * @param {SchedulerLike} [scheduler] - A {@link SchedulerLike} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items emitted by the source Observable\n *  and then emits the items in the specified Iterable.\n * @method endWith\n * @owner Observable\n */\nexport function endWith<T>(...array: Array<T | SchedulerLike>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => concat(source, of(...array)) as Observable<T>;\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Observer, OperatorFunction } from '../types';\n\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * ## Example\n * A simple example emitting true if all elements are less than 5, false otherwise\n * ```ts\n * import { of } from 'rxjs';\n * import { every } from 'rxjs/operators';\n *\n *  of(1, 2, 3, 4, 5, 6).pipe(\n *     every(x => x < 5),\n * )\n * .subscribe(x => console.log(x)); // -> false\n * ```\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nexport function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                         thisArg?: any): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new EveryOperator(predicate, thisArg, source));\n}\n\nclass EveryOperator<T> implements Operator<T, boolean> {\n  constructor(private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private thisArg?: any,\n              private source?: Observable<T>) {\n  }\n\n  call(observer: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass EverySubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(destination: Observer<boolean>,\n              private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private thisArg: any,\n              private source?: Observable<T>) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  private notifyComplete(everyValueMatch: boolean): void {\n    this.destination.next(everyValueMatch);\n    this.destination.complete();\n  }\n\n  protected _next(value: T): void {\n    let result = false;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (!result) {\n      this.notifyComplete(false);\n    }\n  }\n\n  protected _complete(): void {\n    this.notifyComplete(true);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\nexport function exhaust<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport function exhaust<R>(): OperatorFunction<any, R>;\n\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * ![](exhaust.png)\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * ## Example\n * Run a finite timer for each click, only if there is no currently active timer\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { exhaust, map, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map((ev) => interval(1000).pipe(take(5))),\n * );\n * const result = higherOrder.pipe(exhaust());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nexport function exhaust<T>(): OperatorFunction<any, T> {\n  return (source: Observable<T>) => source.lift(new SwitchFirstOperator<T>());\n}\n\nclass SwitchFirstOperator<T> implements Operator<T, T> {\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SwitchFirstSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchFirstSubscriber<T> extends SimpleOuterSubscriber<T, T> {\n  private hasCompleted: boolean = false;\n  private hasSubscription: boolean = false;\n\n  constructor(destination: Subscriber<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSubscription) {\n      this.hasSubscription = true;\n      this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete!();\n    }\n  }\n\n  notifyComplete(): void {\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete!();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function exhaustMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported. Use inner map instead. */\nexport function exhaustMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported. Use inner map instead. */\nexport function exhaustMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * ![](exhaustMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * ## Example\n * Run a finite timer for each click, only if there is no currently active timer\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { exhaustMap, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   exhaustMap(ev => interval(1000).pipe(take(5)))\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nexport function exhaustMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) => source.pipe(\n      exhaustMap((a, i) => from(project(a, i)).pipe(\n        map((b: any, ii: any) => resultSelector(a, b, i, ii)),\n      )),\n    );\n  }\n  return (source: Observable<T>) =>\n    source.lift(new ExhaustMapOperator(project));\n}\n\nclass ExhaustMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ExhaustMapSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private hasSubscription = false;\n  private hasCompleted = false;\n  private index = 0;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  }\n\n  private tryNext(value: T): void {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error!(err);\n      return;\n    }\n    this.hasSubscription = true;\n    this._innerSub(result);\n  }\n\n  private _innerSub(result: ObservableInput<R>): void {\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    const innerSubscription = innerSubscribe(result, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (innerSubscription !== innerSubscriber) {\n      destination.add(innerSubscription);\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete!();\n    }\n    this.unsubscribe();\n  }\n\n  notifyNext(innerValue: R): void {\n    this.destination.next!(innerValue);\n  }\n\n  notifyError(err: any): void {\n    this.destination.error!(err);\n  }\n\n  notifyComplete(): void {\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete!();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, OperatorFunction, ObservableInput, SchedulerLike } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function expand<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, R>;\nexport function expand<T>(project: (value: T, index: number) => ObservableInput<T>, concurrent?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * ![](expand.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * ## Example\n * Start emitting the powers of two on every click, at most 10 of them\n * ```ts\n * import { fromEvent, of } from 'rxjs';\n * import { expand, mapTo, delay, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const powersOfTwo = clicks.pipe(\n *   mapTo(1),\n *   expand(x => of(2 * x).pipe(delay(1000))),\n *   take(10),\n * );\n * powersOfTwo.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nexport function expand<T, R>(project: (value: T, index: number) => ObservableInput<R>,\n                             concurrent: number = Number.POSITIVE_INFINITY,\n                             scheduler?: SchedulerLike): OperatorFunction<T, R> {\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n\n  return (source: Observable<T>) => source.lift(new ExpandOperator(project, concurrent, scheduler));\n}\n\nexport class ExpandOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number,\n              private scheduler?: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n  }\n}\n\ninterface DispatchArg<T, R> {\n  subscriber: ExpandSubscriber<T, R>;\n  result: ObservableInput<R>;\n  value: any;\n  index: number;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ExpandSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private index: number = 0;\n  private active: number = 0;\n  private hasCompleted: boolean = false;\n  private buffer?: any[];\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number,\n              private scheduler?: SchedulerLike) {\n    super(destination);\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      this.buffer = [];\n    }\n  }\n\n  private static dispatch<T, R>(arg: DispatchArg<T, R>): void {\n    const {subscriber, result, value, index} = arg;\n    subscriber.subscribeToProjection(result, value, index);\n  }\n\n  protected _next(value: any): void {\n    const destination = this.destination;\n\n    if (destination.closed) {\n      this._complete();\n      return;\n    }\n\n    const index = this.index++;\n    if (this.active < this.concurrent) {\n      destination.next!(value);\n      try {\n        const { project } = this;\n        const result = project(value, index);\n        if (!this.scheduler) {\n          this.subscribeToProjection(result, value, index);\n        } else {\n          const state: DispatchArg<T, R> = { subscriber: this, result, value, index };\n          const destination = this.destination as Subscription;\n          destination.add(this.scheduler.schedule<DispatchArg<T, R>>(ExpandSubscriber.dispatch as any, 0, state));\n        }\n      } catch (e) {\n        destination.error!(e);\n      }\n    } else {\n      this.buffer!.push(value);\n    }\n  }\n\n  private subscribeToProjection(result: any, value: T, index: number): void {\n    this.active++;\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete!();\n    }\n    this.unsubscribe();\n  }\n\n  notifyNext(innerValue: R): void {\n    this._next(innerValue);\n  }\n\n  notifyComplete(): void {\n    const buffer = this.buffer;\n    this.active--;\n    if (buffer && buffer.length > 0) {\n      this._next(buffer.shift());\n    }\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete!();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new FinallyOperator(callback));\n}\n\nclass FinallyOperator<T> implements Operator<T, T> {\n  constructor(private callback: () => void) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FinallySubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<T>, callback: () => void) {\n    super(destination);\n    this.add(new Subscription(callback));\n  }\n}\n","import {Observable} from '../Observable';\nimport {Operator} from '../Operator';\nimport {Subscriber} from '../Subscriber';\nimport {OperatorFunction} from '../types';\n\nexport function find<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S,\n                                     thisArg?: any): OperatorFunction<T, S | undefined>;\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                        thisArg?: any): OperatorFunction<T, T | undefined>;\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * ![](find.png)\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * ## Example\n * Find and emit the first click that happens on a DIV element\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { find } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(find(ev => ev.target.tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                        thisArg?: any): OperatorFunction<T, T | undefined> {\n  if (typeof predicate !== 'function') {\n    throw new TypeError('predicate is not a function');\n  }\n  return (source: Observable<T>) => source.lift(new FindValueOperator(predicate, source, false, thisArg)) as Observable<T | undefined>;\n}\n\nexport class FindValueOperator<T> implements Operator<T, T | number | undefined> {\n  constructor(private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private source: Observable<T>,\n              private yieldIndex: boolean,\n              private thisArg?: any) {\n  }\n\n  call(observer: Subscriber<T>, source: any): any {\n    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class FindValueSubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private source: Observable<T>,\n              private yieldIndex: boolean,\n              private thisArg?: any) {\n    super(destination);\n  }\n\n  private notifyComplete(value: any): void {\n    const destination = this.destination;\n\n    destination.next(value);\n    destination.complete();\n    this.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    const {predicate, thisArg} = this;\n    const index = this.index++;\n    try {\n      const result = predicate.call(thisArg || this, value, index, this.source);\n      if (result) {\n        this.notifyComplete(this.yieldIndex ? index : value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.notifyComplete(this.yieldIndex ? -1 : undefined);\n  }\n}\n","import { Observable } from '../Observable';\nimport { FindValueOperator } from '../operators/find';\nimport { OperatorFunction } from '../types';\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * ![](findIndex.png)\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * ## Example\n * Emit the index of first click that happens on a DIV element\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { findIndex } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(findIndex(ev => ev.target.tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nexport function findIndex<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                             thisArg?: any): OperatorFunction<T, number> {\n  return (source: Observable<T>) => source.lift(new FindValueOperator(predicate, source, true, thisArg)) as Observable<any>;\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction } from '../../internal/types';\nimport { filter } from './filter';\nimport { take } from './take';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { identity } from '../util/identity';\n\n/* tslint:disable:max-line-length */\nexport function first<T, D = T>(\n  predicate?: null,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\nexport function first<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function first<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n/* tslint:enable:max-line-length */\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * ![](first.png)\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a deprecated `resultSelector` function to produce the output\n * value from the input value, and a `defaultValue` to emit in case the source\n * completes before it is able to emit a valid value. Throws an error if\n * `defaultValue` was not provided and a matching element is not found.\n *\n * ## Examples\n * Emit only the first click that happens on the DOM\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { first } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Emits the first click that happens on a DIV\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { first } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first(ev => ev.target.tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nexport function first<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) => source.pipe(\n    predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n    take(1),\n    hasDefaultValue ? defaultIfEmpty<T | D>(defaultValue) : throwIfEmpty(() => new EmptyError()),\n  );\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\n\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * ![](ignoreElements.png)\n *\n * ## Examples\n * ### Ignores emitted values, reacts to observable's completion.\n * ```ts\n * import { of } from 'rxjs';\n * import { ignoreElements } from 'rxjs/operators';\n *\n * of('you', 'talking', 'to', 'me').pipe(\n *   ignoreElements(),\n * )\n * .subscribe(\n *   word => console.log(word),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'the end'\n * ```\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nexport function ignoreElements(): OperatorFunction<any, never> {\n  return function ignoreElementsOperatorFunction(source: Observable<any>) {\n    return source.lift(new IgnoreElementsOperator());\n  };\n}\n\nclass IgnoreElementsOperator<T, R> implements Operator<T, R> {\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass IgnoreElementsSubscriber<T> extends Subscriber<T> {\n  protected _next(unused: T): void {\n    // Do nothing\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Emits false if the input observable emits any values, or emits true if the\n * input observable completes without emitting any values.\n *\n * <span class=\"informal\">Tells whether any values are emitted by an observable</span>\n *\n * ![](isEmpty.png)\n *\n * `isEmpty` transforms an Observable that emits values into an Observable that\n * emits a single boolean value representing whether or not any values were\n * emitted by the source Observable. As soon as the source Observable emits a\n * value, `isEmpty` will emit a `false` and complete.  If the source Observable\n * completes having not emitted anything, `isEmpty` will emit a `true` and\n * complete.\n *\n * A similar effect could be achieved with {@link count}, but `isEmpty` can emit\n * a `false` value sooner.\n *\n * ## Examples\n *\n * Emit `false` for a non-empty Observable\n * ```javascript\n * import { Subject } from 'rxjs';\n * import { isEmpty } from 'rxjs/operators';\n *\n * const source = new Subject<string>();\n * const result = source.pipe(isEmpty());\n * source.subscribe(x => console.log(x));\n * result.subscribe(x => console.log(x));\n * source.next('a');\n * source.next('b');\n * source.next('c');\n * source.complete();\n *\n * // Results in:\n * // a\n * // false\n * // b\n * // c\n * ```\n *\n * Emit `true` for an empty Observable\n * ```javascript\n * import { EMPTY } from 'rxjs';\n * import { isEmpty } from 'rxjs/operators';\n *\n * const result = EMPTY.pipe(isEmpty());\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // true\n * ```\n *\n * @see {@link count}\n * @see {@link EMPTY}\n *\n * @return {OperatorFunction<T, boolean>} An Observable of a boolean value indicating whether observable was empty or not\n * @method isEmpty\n * @owner Observable\n */\n\nexport function isEmpty<T>(): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new IsEmptyOperator());\n}\n\nclass IsEmptyOperator implements Operator<any, boolean> {\n  call (observer: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new IsEmptySubscriber(observer));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass IsEmptySubscriber extends Subscriber<any> {\n  constructor(destination: Subscriber<boolean>) {\n    super(destination);\n  }\n\n  private notifyComplete(isEmpty: boolean): void {\n    const destination = this.destination;\n\n    destination.next(isEmpty);\n    destination.complete();\n  }\n\n  protected _next(value: boolean) {\n    this.notifyComplete(false);\n  }\n\n  protected _complete() {\n    this.notifyComplete(true);\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction } from '../../internal/types';\nimport { filter } from './filter';\nimport { takeLast } from './takeLast';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { identity } from '../util/identity';\n\n/* tslint:disable:max-line-length */\nexport function last<T, D = T>(\n  predicate?: null,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\nexport function last<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function last<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * ![](last.png)\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} [predicate] - The condition any source emitted item has to satisfy.\n * @param {any} [defaultValue] - An optional default value to provide if last\n * predicate isn't met or no values were emitted.\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n */\nexport function last<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) => source.pipe(\n    predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n    takeLast(1),\n    hasDefaultValue ? defaultIfEmpty<T | D>(defaultValue) : throwIfEmpty(() => new EmptyError()),\n  );\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n * Map every click to the string 'Hi'\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { mapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MapToOperator(value));\n}\n\nclass MapToOperator<T, R> implements Operator<T, R> {\n\n  value: R;\n\n  constructor(value: R) {\n    this.value = value;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapToSubscriber<T, R> extends Subscriber<T> {\n\n  value: R;\n\n  constructor(destination: Subscriber<R>, value: R) {\n    super(destination);\n    this.value = value;\n  }\n\n  protected _next(x: T) {\n    this.destination.next(this.value);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { OperatorFunction } from '../types';\n\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * ![](materialize.png)\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * ## Example\n * Convert a faulty Observable to an Observable of Notifications\n * ```ts\n * import { of } from 'rxjs';\n * import { materialize, map } from 'rxjs/operators';\n *\n * const letters = of('a', 'b', 13, 'd');\n * const upperCase = letters.pipe(map(x => x.toUpperCase()));\n * const materialized = upperCase.pipe(materialize());\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1, hasValue: false}\n * ```\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nexport function materialize<T>(): OperatorFunction<T, Notification<T>> {\n  return function materializeOperatorFunction(source: Observable<T>) {\n    return source.lift(new MaterializeOperator());\n  };\n}\n\nclass MaterializeOperator<T> implements Operator<T, Notification<T>> {\n  call(subscriber: Subscriber<Notification<T>>, source: any): any {\n    return source.subscribe(new MaterializeSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MaterializeSubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<Notification<T>>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.destination.next(Notification.createNext(value));\n  }\n\n  protected _error(err: any) {\n    const destination = this.destination;\n    destination.next(Notification.createError(err));\n    destination.complete();\n  }\n\n  protected _complete() {\n    const destination = this.destination;\n    destination.next(Notification.createComplete());\n    destination.complete();\n  }\n}\n","import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\n\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * ![](max.png)\n *\n * ## Examples\n * Get the maximal value of a series of numbers\n * ```ts\n * import { of } from 'rxjs';\n * import { max } from 'rxjs/operators';\n *\n * of(5, 4, 7, 2, 8).pipe(\n *   max(),\n * )\n * .subscribe(x => console.log(x)); // -> 8\n * ```\n *\n * Use a comparer function to get the maximal item\n * ```typescript\n * import { of } from 'rxjs';\n * import { max } from 'rxjs/operators';\n *\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * of<Person>(\n *   {age: 7, name: 'Foo'},\n *   {age: 5, name: 'Bar'},\n *   {age: 9, name: 'Beer'},\n * ).pipe(\n *   max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1),\n * )\n * .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * ```\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\nexport function max<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  const max: (x: T, y: T) => T = (typeof comparer === 'function')\n    ? (x, y) => comparer(x, y) > 0 ? x : y\n    : (x, y) => x > y ? x : y;\n\n  return reduce(max);\n}\n","import { merge as mergeStatic } from '../observable/merge';\nimport { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction, MonoTypeOperatorFunction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T>(concurrent?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2>(v2: ObservableInput<T2>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2>(v2: ObservableInput<T2>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T>(...observables: Array<ObservableInput<T> | SchedulerLike | number>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike | number>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * @deprecated Deprecated in favor of static {@link merge}.\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike | number>): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift.call(mergeStatic(source, ...observables));\n}\n","import { Observable } from '../Observable';\nimport { OperatorFunction, ObservedValueOf } from '../../internal/types';\nimport { mergeMap } from './mergeMap';\nimport { ObservableInput } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function mergeMapTo<T, O extends ObservableInput<any>>(innerObservable: O, concurrent?: number): OperatorFunction<any, ObservedValueOf<O>>;\n/** @deprecated */\nexport function mergeMapTo<T, R, O extends ObservableInput<any>>(innerObservable: O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * ![](mergeMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * ## Example\n * For each click event, start an interval Observable ticking every 1 second\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { mergeMapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(mergeMapTo(interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable`\n * @method mergeMapTo\n * @owner Observable\n */\nexport function mergeMapTo<T, R, O extends ObservableInput<any>>(\n  innerObservable: O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Number.POSITIVE_INFINITY\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  if (typeof resultSelector === 'function') {\n    return mergeMap(() => innerObservable, resultSelector, concurrent);\n  }\n  if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n  return mergeMap(() => innerObservable, concurrent);\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * ## Example\n * Count the number of click events\n * ```ts\n * import { fromEvent, of } from 'rxjs';\n * import { mapTo, mergeScan } from 'rxjs/operators';\n *\n * const click$ = fromEvent(document, 'click');\n * const one$ = click$.pipe(mapTo(1));\n * const seed = 0;\n * const count$ = one$.pipe(\n *   mergeScan((acc, one) => of(acc + one), seed),\n * );\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * // 1\n * // 2\n * // 3\n * // 4\n * // ...and so on for each click\n * ```\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nexport function mergeScan<T, R>(accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n                                seed: R,\n                                concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MergeScanOperator(accumulator, seed, concurrent));\n}\n\nexport class MergeScanOperator<T, R> implements Operator<T, R> {\n  constructor(private accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n              private seed: R,\n              private concurrent: number) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeScanSubscriber(\n      subscriber, this.accumulator, this.seed, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeScanSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private hasValue: boolean = false;\n  private hasCompleted: boolean = false;\n  private buffer: Observable<any>[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n              private acc: R,\n              private concurrent: number) {\n    super(destination);\n  }\n\n  protected _next(value: any): void {\n    if (this.active < this.concurrent) {\n      const index = this.index++;\n      const destination = this.destination;\n      let ish;\n      try {\n        const { accumulator } = this;\n        ish = accumulator(this.acc, value, index);\n      } catch (e) {\n        return destination.error!(e);\n      }\n      this.active++;\n      this._innerSub(ish);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  private _innerSub(ish: any): void {\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    const innerSubscription = innerSubscribe(ish, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (innerSubscription !== innerSubscriber) {\n      destination.add(innerSubscription);\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      if (this.hasValue === false) {\n        this.destination.next!(this.acc);\n      }\n      this.destination.complete!();\n    }\n    this.unsubscribe();\n  }\n\n  notifyNext(innerValue: R): void {\n    const { destination } = this;\n    this.acc = innerValue;\n    this.hasValue = true;\n    destination.next!(innerValue);\n  }\n\n  notifyComplete(): void {\n    const buffer = this.buffer;\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      if (this.hasValue === false) {\n        this.destination.next!(this.acc);\n      }\n      this.destination.complete!();\n    }\n  }\n}\n","import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\n\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * ![](min.png)\n *\n * ## Examples\n * Get the minimal value of a series of numbers\n * ```ts\n * import { of } from 'rxjs';\n * import { min } from 'rxjs/operators';\n *\n * of(5, 4, 7, 2, 8).pipe(\n *   min(),\n * )\n * .subscribe(x => console.log(x)); // -> 2\n * ```\n *\n * Use a comparer function to get the minimal item\n * ```typescript\n * import { of } from 'rxjs';\n * import { min } from 'rxjs/operators';\n *\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * of<Person>(\n *   {age: 7, name: 'Foo'},\n *   {age: 5, name: 'Bar'},\n *   {age: 9, name: 'Beer'},\n * ).pipe(\n *   min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1),\n * )\n * .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * ```\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\nexport function min<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  const min: (x: T, y: T) => T = (typeof comparer === 'function')\n    ? (x, y) => comparer(x, y) < 0 ? x : y\n    : (x, y) => x < y ? x : y;\n  return reduce(min);\n}\n","import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable, connectableObservableDescriptor } from '../observable/ConnectableObservable';\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservedValueOf, ObservableInput } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function multicast<T>(subject: Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T, O extends ObservableInput<any>>(subject: Subject<T>, selector: (shared: Observable<T>) => O): UnaryFunction<Observable<T>, ConnectableObservable<ObservedValueOf<O>>>;\nexport function multicast<T>(subjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T, O extends ObservableInput<any>>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * ![](multicast.png)\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nexport function multicast<T, R>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\n                                selector?: (source: Observable<T>) => Observable<R>): OperatorFunction<T, R> {\n  return function multicastOperatorFunction(source: Observable<T>): Observable<R> {\n    let subjectFactory: () => Subject<T>;\n    if (typeof subjectOrSubjectFactory === 'function') {\n      subjectFactory = <() => Subject<T>>subjectOrSubjectFactory;\n    } else {\n      subjectFactory = function subjectFactory() {\n        return <Subject<T>>subjectOrSubjectFactory;\n      };\n    }\n\n    if (typeof selector === 'function') {\n      return source.lift(new MulticastOperator(subjectFactory, selector));\n    }\n\n    const connectable: any = Object.create(source, connectableObservableDescriptor);\n    connectable.source = source;\n    connectable.subjectFactory = subjectFactory;\n\n    return <ConnectableObservable<R>> connectable;\n  };\n}\n\nexport class MulticastOperator<T, R> implements Operator<T, R> {\n  constructor(private subjectFactory: () => Subject<T>,\n              private selector: (source: Observable<T>) => Observable<R>) {\n  }\n  call(subscriber: Subscriber<R>, source: any): any {\n    const { selector } = this;\n    const subject = this.subjectFactory();\n    const subscription = selector(subject).subscribe(subscriber);\n    subscription.add(source.subscribe(subject));\n    return subscription;\n  }\n}\n","import { Observable } from '../Observable';\nimport { from } from '../observable/from';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { isArray } from '../util/isArray';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNext<T>(): OperatorFunction<T, T>;\nexport function onErrorResumeNext<T, T2>(v: ObservableInput<T2>): OperatorFunction<T, T | T2>;\nexport function onErrorResumeNext<T, T2, T3>(v: ObservableInput<T2>, v2: ObservableInput<T3>): OperatorFunction<T, T | T2 | T3>;\nexport function onErrorResumeNext<T, T2, T3, T4>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>): OperatorFunction<T, T | T2 | T3 | T4>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5, T6>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>, v5: ObservableInput<T6>): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5, T6, T7>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>, v5: ObservableInput<T6>, v6: ObservableInput<T7>): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6 | T7>;\nexport function onErrorResumeNext<T, R>(...observables: Array<ObservableInput<any>>): OperatorFunction<T, T | R>;\nexport function onErrorResumeNext<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link Observable#subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catchError} instead.\n *\n *\n * ## Example\n * Subscribe to the next Observable after map fails\n * ```ts\n * import { of } from 'rxjs';\n * import { onErrorResumeNext, map } from 'rxjs/operators';\n *\n * of(1, 2, 3, 0).pipe(\n *   map(x => {\n *       if (x === 0) { throw Error(); }\n *        return 10 / x;\n *   }),\n *   onErrorResumeNext(of(1, 2, 3)),\n * )\n * .subscribe(\n *   val => console.log(val),\n *   err => console.log(err),          // Will never be called.\n *   () => console.log('that\\'s it!')\n * );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\n\nexport function onErrorResumeNext<T, R>(...nextSources: Array<ObservableInput<any> |\n                                                       Array<ObservableInput<any>>>): OperatorFunction<T, R> {\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = <Array<Observable<any>>>nextSources[0];\n  }\n\n  return (source: Observable<T>) => source.lift(new OnErrorResumeNextOperator<T, R>(nextSources));\n}\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNextStatic<R>(v: ObservableInput<R>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\n\nexport function onErrorResumeNextStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport function onErrorResumeNextStatic<R>(array: ObservableInput<any>[]): Observable<R>;\n/* tslint:enable:max-line-length */\n\nexport function onErrorResumeNextStatic<T, R>(...nextSources: Array<ObservableInput<any> |\n  Array<ObservableInput<any>> |\n  ((...values: Array<any>) => R)>): Observable<R> {\n  let source: ObservableInput<any>|undefined = undefined;\n\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = nextSources[0] as ObservableInput<any>[];\n  }\n  // TODO: resolve issue with passing no arguments.\n  source = nextSources.shift()!;\n\n  return from(source).lift(new OnErrorResumeNextOperator<T, R>(nextSources));\n}\n\nclass OnErrorResumeNextOperator<T, R> implements Operator<T, R> {\n  constructor(private nextSources: Array<ObservableInput<any>>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n  }\n}\n\nclass OnErrorResumeNextSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  constructor(protected destination: Subscriber<T>,\n              private nextSources: Array<ObservableInput<any>>) {\n    super(destination);\n  }\n\n  notifyError(): void {\n    this.subscribeToNextSource();\n  }\n\n  notifyComplete(): void {\n    this.subscribeToNextSource();\n  }\n\n  protected _error(err: any): void {\n    this.subscribeToNextSource();\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.subscribeToNextSource();\n    this.unsubscribe();\n  }\n\n  private subscribeToNextSource(): void {\n    const next = this.nextSources.shift();\n    if (!!next) {\n      const innerSubscriber = new SimpleInnerSubscriber(this);\n      const destination = this.destination as Subscription;\n      destination.add(innerSubscriber);\n      const innerSubscription = innerSubscribe(next, innerSubscriber);\n      // The returned subscription will usually be the subscriber that was\n      // passed. However, interop subscribers will be wrapped and for\n      // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n      if (innerSubscription !== innerSubscriber) {\n        destination.add(innerSubscription);\n      }\n    } else {\n      this.destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\n\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * ![](pairwise.png)\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * ## Example\n * On every click (starting from the second), emit the relative distance to the previous click\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { pairwise, map } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const pairs = clicks.pipe(pairwise());\n * const distance = pairs.pipe(\n *   map(pair => {\n *     const x0 = pair[0].clientX;\n *     const y0 = pair[0].clientY;\n *     const x1 = pair[1].clientX;\n *     const y1 = pair[1].clientY;\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n *   }),\n * );\n * distance.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nexport function pairwise<T>(): OperatorFunction<T, [T, T]> {\n  return (source: Observable<T>) => source.lift(new PairwiseOperator());\n}\n\nclass PairwiseOperator<T> implements Operator<T, [T, T]> {\n  call(subscriber: Subscriber<[T, T]>, source: any): any {\n    return source.subscribe(new PairwiseSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass PairwiseSubscriber<T> extends Subscriber<T> {\n  private prev: T;\n  private hasPrev: boolean = false;\n\n  constructor(destination: Subscriber<[T, T]>) {\n    super(destination);\n  }\n\n  _next(value: T): void {\n    let pair: [T, T] | undefined;\n\n    if (this.hasPrev) {\n      pair = [this.prev, value];\n    } else {\n      this.hasPrev = true;\n    }\n\n    this.prev = value;\n\n    if (pair) {\n      this.destination.next(pair);\n    }\n  }\n}\n","import { not } from '../util/not';\nimport { filter } from './filter';\nimport { Observable } from '../Observable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * ![](partition.png)\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * ## Example\n * Partition click events into those on DIV elements and those elsewhere\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { partition } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const parts = clicks.pipe(partition(ev => ev.target.tagName === 'DIV'));\n * const clicksOnDivs = parts[0];\n * const clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n * ```\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n * @deprecated use `partition` static creation function instead\n */\nexport function partition<T>(predicate: (value: T, index: number) => boolean,\n                             thisArg?: any): UnaryFunction<Observable<T>, [Observable<T>, Observable<T>]> {\n  return (source: Observable<T>) => [\n    filter(predicate, thisArg)(source),\n    filter(not(predicate, thisArg) as any)(source)\n  ] as [Observable<T>, Observable<T>];\n}\n","import { Observable } from '../Observable';\nimport { map } from './map';\nimport { OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function pluck<T, K1 extends keyof T>(k1: K1): OperatorFunction<T, T[K1]>;\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): OperatorFunction<T, T[K1][K2]>;\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(k1: K1, k2: K2, k3: K3): OperatorFunction<T, T[K1][K2][K3]>;\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(k1: K1, k2: K2, k3: K3, k4: K4): OperatorFunction<T, T[K1][K2][K3][K4]>;\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\nexport function pluck<T, R>(...properties: string[]): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * ![](pluck.png)\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * ## Example\n * Map every click to the tagName of the clicked target element\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { pluck } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const tagNames = clicks.pipe(pluck('target', 'tagName'));\n * tagNames.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nexport function pluck<T, R>(...properties: string[]): OperatorFunction<T, R> {\n  const length = properties.length;\n  if (length === 0) {\n    throw new Error('list of properties cannot be empty.');\n  }\n  return (source: Observable<T>) => map(plucker(properties, length))(source as any);\n}\n\nfunction plucker(props: string[], length: number): (x: string) => any {\n  const mapper = (x: string) => {\n    let currentProp = x;\n    for (let i = 0; i < length; i++) {\n      const p = currentProp != null ? currentProp[props[i]] : undefined;\n      if (p !== void 0) {\n        currentProp = p;\n      } else {\n        return undefined;\n      }\n    }\n    return currentProp;\n  };\n\n  return mapper;\n}\n","import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function publish<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function publish<T, O extends ObservableInput<any>>(selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\nexport function publish<T>(selector: MonoTypeOperatorFunction<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <span class=\"informal\">Makes a cold Observable hot</span>\n *\n * ![](publish.png)\n *\n * ## Examples\n * Make source$ hot by applying publish operator, then merge each inner observable into a single one\n * and subscribe.\n * ```ts\n * import { of, zip, interval, merge } from \"rxjs\";\n * import { map, publish, tap } from \"rxjs/operators\";\n *\n * const source$ = zip(interval(2000), of(1, 2, 3, 4, 5, 6, 7, 8, 9)).pipe(\n *   map(values => values[1])\n * );\n *\n * source$\n *   .pipe(\n *     publish(multicasted$ =>\n *       merge(\n *         multicasted$.pipe(tap(x => console.log('Stream 1:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 2:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 3:', x))),\n *       )\n *     )\n *   )\n *   .subscribe();\n *\n * // Results every two seconds\n * // Stream 1: 1\n * // Stream 2: 1\n * // Stream 3: 1\n * // ...\n * // Stream 1: 9\n * // Stream 2: 9\n * // Stream 3: 9\n * ```\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n *\n *\n */\nexport function publish<T, R>(selector?: OperatorFunction<T, R>): MonoTypeOperatorFunction<T> | OperatorFunction<T, R> {\n  return selector ?\n    multicast(() => new Subject<T>(), selector) :\n    multicast(new Subject<T>());\n}\n","import { Observable } from '../Observable';\nimport { BehaviorSubject } from '../BehaviorSubject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nexport function publishBehavior<T>(value: T):  UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  return (source: Observable<T>) => multicast(new BehaviorSubject<T>(value))(source) as ConnectableObservable<T>;\n}\n","import { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Returns a connectable observable sequence that shares a single subscription to the\n * underlying sequence containing only the last notification.\n *\n * ![](publishLast.png)\n *\n * Similar to {@link publish}, but it waits until the source observable completes and stores\n * the last emitted value.\n * Similarly to {@link publishReplay} and {@link publishBehavior}, this keeps storing the last\n * value even if it has no more subscribers. If subsequent subscriptions happen, they will\n * immediately get that last stored value and complete.\n *\n * ## Example\n *\n * ```ts\n * import { interval } from 'rxjs';\n * import { publishLast, tap, take } from 'rxjs/operators';\n *\n * const connectable =\n *   interval(1000)\n *     .pipe(\n *       tap(x => console.log(\"side effect\", x)),\n *       take(3),\n *       publishLast());\n *\n * connectable.subscribe(\n *   x => console.log(  \"Sub. A\", x),\n *   err => console.log(\"Sub. A Error\", err),\n *   () => console.log( \"Sub. A Complete\"));\n *\n * connectable.subscribe(\n *   x => console.log(  \"Sub. B\", x),\n *   err => console.log(\"Sub. B Error\", err),\n *   () => console.log( \"Sub. B Complete\"));\n *\n * connectable.connect();\n *\n * // Results:\n * //    \"side effect 0\"\n * //    \"side effect 1\"\n * //    \"side effect 2\"\n * //    \"Sub. A 2\"\n * //    \"Sub. B 2\"\n * //    \"Sub. A Complete\"\n * //    \"Sub. B Complete\"\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link publish}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @return {ConnectableObservable} An observable sequence that contains the elements of a\n * sequence produced by multicasting the source sequence.\n * @method publishLast\n * @owner Observable\n */\n\nexport function publishLast<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  return (source: Observable<T>) => multicast(new AsyncSubject<T>())(source);\n}\n","import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction, MonoTypeOperatorFunction, OperatorFunction, SchedulerLike, ObservableInput, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function publishReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport function publishReplay<T, O extends ObservableInput<any>>(bufferSize?: number, windowTime?: number, selector?: (shared: Observable<T>) => O, scheduler?: SchedulerLike): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\nexport function publishReplay<T, R>(bufferSize?: number,\n                                    windowTime?: number,\n                                    selectorOrScheduler?: SchedulerLike | OperatorFunction<T, R>,\n                                    scheduler?: SchedulerLike): UnaryFunction<Observable<T>, ConnectableObservable<R>> {\n\n  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n    scheduler = selectorOrScheduler;\n  }\n\n  const selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n  const subject = new ReplaySubject<T>(bufferSize, windowTime, scheduler);\n\n  return (source: Observable<T>) => multicast(() => subject, selector)(source) as ConnectableObservable<R>;\n}\n","import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { MonoTypeOperatorFunction, OperatorFunction } from '../types';\nimport { race as raceStatic } from '../observable/race';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Deprecated in favor of static race. */\nexport function race<T>(observables: Array<Observable<T>>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static race. */\nexport function race<T, R>(observables: Array<Observable<T>>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static race. */\nexport function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static race. */\nexport function race<T, R>(...observables: Array<Observable<any> | Array<Observable<any>>>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit a next,\n * error or complete notification from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n * @deprecated Deprecated in favor of static {@link race}.\n */\nexport function race<T>(...observables: (Observable<T> | Observable<T>[])[]): MonoTypeOperatorFunction<T> {\n  return function raceOperatorFunction(source: Observable<T>) {\n    // if the only argument is an array, it was most likely called with\n    // `pair([obs1, obs2, ...])`\n    if (observables.length === 1 && isArray(observables[0])) {\n      observables = observables[0] as Observable<T>[];\n    }\n\n    return source.lift.call(raceStatic(source, ...(observables as Observable<T>[])));\n  };\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { empty } from '../observable/empty';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that will resubscribe to the source stream when the source stream completes, at most count times.\n *\n * <span class=\"informal\">Repeats all values emitted on the source. It's like {@link retry}, but for non error cases.</span>\n *\n * ![](repeat.png)\n *\n * Similar to {@link retry}, this operator repeats the stream of items emitted by the source for non error cases.\n * Repeat can be useful for creating observables that are meant to have some repeated pattern or rhythm.\n *\n * Note: `repeat(0)` returns an empty observable and `repeat()` will repeat forever\n *\n * ## Example\n * Repeat a message stream\n * ```ts\n * import { of } from 'rxjs';\n * import { repeat, delay } from 'rxjs/operators';\n *\n * const source = of('Repeat message');\n * const example = source.pipe(repeat(3));\n * example.subscribe(x => console.log(x));\n *\n * // Results\n * // Repeat message\n * // Repeat message\n * // Repeat message\n * ```\n *\n * Repeat 3 values, 2 times\n * ```ts\n * import { interval } from 'rxjs';\n * import { repeat, take } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(take(3), repeat(2));\n * example.subscribe(x => console.log(x));\n *\n * // Results every second\n * // 0\n * // 1\n * // 2\n * // 0\n * // 1\n * // 2\n * ```\n *\n * @see {@link repeatWhen}\n * @see {@link retry}\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that will resubscribe to the source stream when the source stream completes\n * , at most count times.\n * @method repeat\n * @owner Observable\n */\nexport function repeat<T>(count: number = -1): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return empty();\n    } else if (count < 0) {\n      return source.lift(new RepeatOperator(-1, source));\n    } else {\n      return source.lift(new RepeatOperator(count - 1, source));\n    }\n  };\n}\n\nclass RepeatOperator<T> implements Operator<T, T> {\n  constructor(private count: number,\n              private source: Observable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RepeatSubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>,\n              private count: number,\n              private source: Observable<T>) {\n    super(destination);\n  }\n  complete() {\n    if (!this.isStopped) {\n      const { source, count } = this;\n      if (count === 0) {\n        return super.complete();\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * ![](repeatWhen.png)\n *\n * ## Example\n * Repeat a message stream on click\n * ```ts\n * import { of, fromEvent } from 'rxjs';\n * import { repeatWhen } from 'rxjs/operators';\n *\n * const source = of('Repeat message');\n * const documentClick$ = fromEvent(document, 'click');\n *\n * source.pipe(repeatWhen(() => documentClick$)\n * ).subscribe(data => console.log(data))\n * ```\n * @see {@link repeat}\n * @see {@link retry}\n * @see {@link retryWhen}\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nexport function repeatWhen<T>(notifier: (notifications: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RepeatWhenOperator(notifier));\n}\n\nclass RepeatWhenOperator<T> implements Operator<T, T> {\n  constructor(protected notifier: (notifications: Observable<any>) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RepeatWhenSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n\n  private notifications?: Subject<any>;\n  private retries?: Observable<any>;\n  private retriesSubscription?: Subscription;\n  private sourceIsBeingSubscribedTo: boolean = true;\n\n  constructor(destination: Subscriber<R>,\n              private notifier: (notifications: Observable<any>) => Observable<any>,\n              private source: Observable<T>) {\n    super(destination);\n  }\n\n  notifyNext(): void {\n    this.sourceIsBeingSubscribedTo = true;\n    this.source.subscribe(this);\n  }\n\n  notifyComplete(): void {\n    if (this.sourceIsBeingSubscribedTo === false) {\n      return super.complete();\n    }\n  }\n\n  complete() {\n    this.sourceIsBeingSubscribedTo = false;\n\n    if (!this.isStopped) {\n      if (!this.retries) {\n        this.subscribeToRetries();\n      }\n      if (!this.retriesSubscription || this.retriesSubscription.closed) {\n        return super.complete();\n      }\n\n      this._unsubscribeAndRecycle();\n      this.notifications!.next(undefined);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { notifications, retriesSubscription } = this;\n    if (notifications) {\n      notifications.unsubscribe();\n      this.notifications = undefined;\n    }\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = undefined;\n    }\n    this.retries = undefined;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _unsubscribe } = this;\n\n    this._unsubscribe = null!;\n    super._unsubscribeAndRecycle();\n    this._unsubscribe = _unsubscribe;\n\n    return this;\n  }\n\n  private subscribeToRetries() {\n    this.notifications = new Subject();\n    let retries;\n    try {\n      const { notifier } = this;\n      retries = notifier(this.notifications);\n    } catch (e) {\n      return super.complete();\n    }\n    this.retries = retries;\n    this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * ![](retry.png)\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n *\n * ## Example\n * ```ts\n * import { interval, of, throwError } from 'rxjs';\n * import { mergeMap, retry } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   mergeMap(val => {\n *     if(val > 5){\n *       return throwError('Error!');\n *     }\n *     return of(val);\n *   }),\n *   //retry 2 times on error\n *   retry(2)\n * );\n *\n * const subscribe = example.subscribe({\n *   next: val => console.log(val),\n *   error: val => console.log(`${val}: Retried 2 times then quit!`)\n * });\n *\n * // Output:\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // \"Error!: Retried 2 times then quit!\"\n * ```\n *\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nexport function retry<T>(count: number = -1): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RetryOperator(count, source));\n}\n\nclass RetryOperator<T> implements Operator<T, T> {\n  constructor(private count: number,\n              private source: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RetrySubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>,\n              private count: number,\n              private source: Observable<T>) {\n    super(destination);\n  }\n  error(err: any) {\n    if (!this.isStopped) {\n      const { source, count } = this;\n      if (count === 0) {\n        return super.error(err);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * ![](retryWhen.png)\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nexport function retryWhen<T>(notifier: (errors: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RetryWhenOperator(notifier, source));\n}\n\nclass RetryWhenOperator<T> implements Operator<T, T> {\n  constructor(protected notifier: (errors: Observable<any>) => Observable<any>,\n              protected source: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RetryWhenSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n\n  private errors?: Subject<any>;\n  private retries?: Observable<any>;\n  private retriesSubscription?: Subscription;\n\n  constructor(destination: Subscriber<R>,\n              private notifier: (errors: Observable<any>) => Observable<any>,\n              private source: Observable<T>) {\n    super(destination);\n  }\n\n  error(err: any) {\n    if (!this.isStopped) {\n\n      let errors = this.errors;\n      let retries: any = this.retries;\n      let retriesSubscription = this.retriesSubscription;\n\n      if (!retries) {\n        errors = new Subject();\n        try {\n          const { notifier } = this;\n          retries = notifier(errors);\n        } catch (e) {\n          return super.error(e);\n        }\n        retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));\n      } else {\n        this.errors = undefined;\n        this.retriesSubscription = undefined;\n      }\n\n      this._unsubscribeAndRecycle();\n\n      this.errors = errors;\n      this.retries = retries;\n      this.retriesSubscription = retriesSubscription;\n\n      errors!.next(err);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { errors, retriesSubscription } = this;\n    if (errors) {\n      errors.unsubscribe();\n      this.errors = undefined;\n    }\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = undefined;\n    }\n    this.retries = undefined;\n  }\n\n  notifyNext(): void {\n    const { _unsubscribe } = this;\n\n    this._unsubscribe = null!;\n    this._unsubscribeAndRecycle();\n    this._unsubscribe = _unsubscribe;\n\n    this.source.subscribe(this);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * ![](sample.png)\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * ## Example\n * On every click, sample the most recent \"seconds\" timer\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { sample } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = seconds.pipe(sample(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nexport function sample<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SampleOperator(notifier));\n}\n\nclass SampleOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    const sampleSubscriber = new SampleSubscriber(subscriber);\n    const subscription = source.subscribe(sampleSubscriber);\n    subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));\n    return subscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SampleSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private value?: T;\n  private hasValue: boolean = false;\n\n  protected _next(value: T) {\n    this.value = value;\n    this.hasValue = true;\n  }\n\n  notifyNext(): void {\n    this.emitValue();\n  }\n\n  notifyComplete(): void {\n    this.emitValue();\n  }\n\n  emitValue() {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next!(this.value!);\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * ![](sampleTime.png)\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * ## Example\n * Every second, emit the most recent click at most once\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { sampleTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(sampleTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nexport function sampleTime<T>(period: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SampleTimeOperator(period, scheduler));\n}\n\nclass SampleTimeOperator<T> implements Operator<T, T> {\n  constructor(private period: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SampleTimeSubscriber<T> extends Subscriber<T> {\n  lastValue: T;\n  hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private period: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period }));\n  }\n\n  protected _next(value: T) {\n    this.lastValue = value;\n    this.hasValue = true;\n  }\n\n  notifyNext() {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.lastValue);\n    }\n  }\n}\n\nfunction dispatchNotification<T>(this: SchedulerAction<any>, state: any) {\n  let { subscriber, period } = state;\n  subscriber.notifyNext();\n  this.schedule(state, period);\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n\nimport { Observer, OperatorFunction } from '../types';\n\n/**\n * Compares all values of two observables in sequence using an optional comparator function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * ![](sequenceEqual.png)\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * ## Example\n * figure out if the Konami code matches\n * ```ts\n * import { from, fromEvent } from 'rxjs';\n * import { sequenceEqual, bufferCount, mergeMap, map } from 'rxjs/operators';\n *\n * const codes = from([\n *   'ArrowUp',\n *   'ArrowUp',\n *   'ArrowDown',\n *   'ArrowDown',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'KeyB',\n *   'KeyA',\n *   'Enter', // no start key, clearly.\n * ]);\n *\n * const keys = fromEvent(document, 'keyup').pipe(map(e => e.code));\n * const matches = keys.pipe(\n *   bufferCount(11, 1),\n *   mergeMap(\n *     last11 => from(last11).pipe(sequenceEqual(codes)),\n *   ),\n * );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparator] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nexport function sequenceEqual<T>(compareTo: Observable<T>,\n                                 comparator?: (a: T, b: T) => boolean): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new SequenceEqualOperator(compareTo, comparator));\n}\n\nexport class SequenceEqualOperator<T> implements Operator<T, boolean> {\n  constructor(private compareTo: Observable<T>,\n              private comparator: (a: T, b: T) => boolean) {\n  }\n\n  call(subscriber: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SequenceEqualSubscriber<T, R> extends Subscriber<T> {\n  private _a: T[] = [];\n  private _b: T[] = [];\n  private _oneComplete = false;\n\n  constructor(destination: Observer<R>,\n              private compareTo: Observable<T>,\n              private comparator: (a: T, b: T) => boolean) {\n    super(destination);\n    (this.destination as Subscription).add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n  }\n\n  protected _next(value: T): void {\n    if (this._oneComplete && this._b.length === 0) {\n      this.emit(false);\n    } else {\n      this._a.push(value);\n      this.checkValues();\n    }\n  }\n\n  public _complete(): void {\n    if (this._oneComplete) {\n      this.emit(this._a.length === 0 && this._b.length === 0);\n    } else {\n      this._oneComplete = true;\n    }\n    this.unsubscribe();\n  }\n\n  checkValues() {\n    const { _a, _b, comparator } = this;\n    while (_a.length > 0 && _b.length > 0) {\n      let a = _a.shift();\n      let b = _b.shift();\n      let areEqual = false;\n      try {\n        areEqual = comparator ? comparator(a, b) : a === b;\n      } catch (e) {\n        this.destination.error(e);\n      }\n      if (!areEqual) {\n        this.emit(false);\n      }\n    }\n  }\n\n  emit(value: boolean) {\n    const { destination } = this;\n    destination.next(value);\n    destination.complete();\n  }\n\n  nextB(value: T) {\n    if (this._oneComplete && this._a.length === 0) {\n      this.emit(false);\n    } else {\n      this._b.push(value);\n      this.checkValues();\n    }\n  }\n\n  completeB() {\n    if (this._oneComplete) {\n      this.emit(this._a.length === 0 && this._b.length === 0);\n    } else {\n      this._oneComplete = true;\n    }\n  }\n}\n\nclass SequenceEqualCompareToSubscriber<T, R> extends Subscriber<T> {\n  constructor(destination: Observer<R>, private parent: SequenceEqualSubscriber<T, R>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.parent.nextB(value);\n  }\n\n  protected _error(err: any): void {\n    this.parent.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.completeB();\n    this.unsubscribe();\n  }\n}\n","import { Observable } from '../Observable';\nimport { multicast } from './multicast';\nimport { refCount } from './refCount';\nimport { Subject } from '../Subject';\n\nimport { MonoTypeOperatorFunction } from '../types';\n\nfunction shareSubjectFactory() {\n  return new Subject();\n}\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * ![](share.png)\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nexport function share<T>(): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => refCount()(multicast(shareSubjectFactory)(source)) as Observable<T>;\n}\n","import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { Subscriber } from '../Subscriber';\n\nexport interface ShareReplayConfig {\n  bufferSize?: number;\n  windowTime?: number;\n  refCount: boolean;\n  scheduler?: SchedulerLike;\n}\n\n/**\n * Share source and replay specified number of emissions on subscription.\n *\n * This operator is a specialization of `replay` that connects to a source observable\n * and multicasts through a `ReplaySubject` constructed with the specified arguments.\n * A successfully completed source will stay cached in the `shareReplayed observable` forever,\n * but an errored source can be retried.\n *\n * ## Why use shareReplay?\n * You generally want to use `shareReplay` when you have side-effects or taxing computations\n * that you do not wish to be executed amongst multiple subscribers.\n * It may also be valuable in situations where you know you will have late subscribers to\n * a stream that need access to previously emitted values.\n * This ability to replay values on subscription is what differentiates {@link share} and `shareReplay`.\n *\n * ![](shareReplay.png)\n *\n * ## Example\n * ```ts\n * import { interval } from 'rxjs';\n * import { shareReplay, take } from 'rxjs/operators';\n *\n * const obs$ = interval(1000);\n * const shared$ = obs$.pipe(\n *   take(4),\n *   shareReplay(3)\n * );\n * shared$.subscribe(x => console.log('source A: ', x));\n * shared$.subscribe(y => console.log('source B: ', y));\n *\n * ```\n *\n * @see {@link publish}\n * @see {@link share}\n * @see {@link publishReplay}\n *\n * @param {Number} [bufferSize=Number.POSITIVE_INFINITY] Maximum element count of the replay buffer.\n * @param {Number} [windowTime=Number.POSITIVE_INFINITY] Maximum time length of the replay buffer in milliseconds.\n * @param {Scheduler} [scheduler] Scheduler where connected observers within the selector function\n * will be invoked on.\n * @return {Observable} An observable sequence that contains the elements of a sequence produced\n * by multicasting the source sequence within a selector function.\n * @method shareReplay\n * @owner Observable\n */\nexport function shareReplay<T>(\n  config: ShareReplayConfig\n): MonoTypeOperatorFunction<T>;\nexport function shareReplay<T>(\n  bufferSize?: number,\n  windowTime?: number,\n  scheduler?: SchedulerLike\n): MonoTypeOperatorFunction<T>;\nexport function shareReplay<T>(\n  configOrBufferSize?: ShareReplayConfig | number,\n  windowTime?: number,\n  scheduler?: SchedulerLike\n): MonoTypeOperatorFunction<T> {\n  let config: ShareReplayConfig;\n  if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n    config = configOrBufferSize as ShareReplayConfig;\n  } else {\n    config = {\n      bufferSize: configOrBufferSize as number | undefined,\n      windowTime,\n      refCount: false,\n      scheduler,\n    };\n  }\n  return (source: Observable<T>) => source.lift(shareReplayOperator(config));\n}\n\nfunction shareReplayOperator<T>({\n  bufferSize = Number.POSITIVE_INFINITY,\n  windowTime = Number.POSITIVE_INFINITY,\n  refCount: useRefCount,\n  scheduler,\n}: ShareReplayConfig) {\n  let subject: ReplaySubject<T> | undefined;\n  let refCount = 0;\n  let subscription: Subscription | undefined;\n  let hasError = false;\n  let isComplete = false;\n\n  return function shareReplayOperation(\n    this: Subscriber<T>,\n    source: Observable<T>\n  ) {\n    refCount++;\n    let innerSub: Subscription;\n    if (!subject || hasError) {\n      hasError = false;\n      subject = new ReplaySubject<T>(bufferSize, windowTime, scheduler);\n      innerSub = subject.subscribe(this);\n      subscription = source.subscribe({\n        next(value) {\n          subject.next(value);\n        },\n        error(err) {\n          hasError = true;\n          subject.error(err);\n        },\n        complete() {\n          isComplete = true;\n          subscription = undefined;\n          subject.complete();\n        },\n      });\n\n      // Here we need to check to see if the source synchronously completed. Although\n      // we're setting `subscription = undefined` in the completion handler, if the source\n      // is synchronous, that will happen *before* subscription is set by the return of\n      // the `subscribe` call.\n      if (isComplete) {\n        subscription = undefined;\n      }\n    } else {\n      innerSub = subject.subscribe(this);\n    }\n\n    this.add(() => {\n      refCount--;\n      innerSub.unsubscribe();\n      innerSub = undefined;\n      if (subscription && !isComplete && useRefCount && refCount === 0) {\n        subscription.unsubscribe();\n        subscription = undefined;\n        subject = undefined;\n      }\n    });\n  };\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\n\nimport { Observer, MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * items, notify of an IllegalArgumentException or NoSuchElementException respectively. If the source Observable\n * emits items but none match the specified predicate then `undefined` is emitted.\n *\n * <span class=\"informal\">Like {@link first}, but emit with error notification if there is more than one value.</span>\n * ![](single.png)\n *\n * ## Example\n * emits 'error'\n * ```ts\n * import { range } from 'rxjs';\n * import { single } from 'rxjs/operators';\n *\n * const numbers = range(1,5).pipe(single());\n * numbers.subscribe(x => console.log('never get called'), e => console.log('error'));\n * // result\n * // 'error'\n * ```\n *\n * emits 'undefined'\n * ```ts\n * import { range } from 'rxjs';\n * import { single } from 'rxjs/operators';\n *\n * const numbers = range(1,5).pipe(single(x => x === 10));\n * numbers.subscribe(x => console.log(x));\n * // result\n * // 'undefined'\n * ```\n *\n * @see {@link first}\n * @see {@link find}\n * @see {@link findIndex}\n * @see {@link elementAt}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate or `undefined` when no items match.\n *\n * @method single\n * @owner Observable\n */\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SingleOperator(predicate, source));\n}\n\nclass SingleOperator<T> implements Operator<T, T> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SingleSubscriber<T> extends Subscriber<T> {\n  private seenValue: boolean = false;\n  private singleValue: T;\n  private index: number = 0;\n\n  constructor(destination: Observer<T>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n    super(destination);\n  }\n\n  private applySingleValue(value: T): void {\n    if (this.seenValue) {\n      this.destination.error('Sequence contains more than one element');\n    } else {\n      this.seenValue = true;\n      this.singleValue = value;\n    }\n  }\n\n  protected _next(value: T): void {\n    const index = this.index++;\n\n    if (this.predicate) {\n      this.tryNext(value, index);\n    } else {\n      this.applySingleValue(value);\n    }\n  }\n\n  private tryNext(value: T, index: number): void {\n    try {\n      if (this.predicate(value, index, this.source)) {\n        this.applySingleValue(value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n\n    if (this.index > 0) {\n      destination.next(this.seenValue ? this.singleValue : undefined);\n      destination.complete();\n    } else {\n      destination.error(new EmptyError);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * ![](skip.png)\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nexport function skip<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipOperator(count));\n}\n\nclass SkipOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipSubscriber<T> extends Subscriber<T> {\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(x: T) {\n    if (++this.count > this.total) {\n      this.destination.next(x);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * ![](skipLast.png)\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * ## Example\n * Skip the last 2 values of an Observable with many values\n * ```ts\n * import { range } from 'rxjs';\n * import { skipLast } from 'rxjs/operators';\n *\n * const many = range(1, 5);\n * const skipLastTwo = many.pipe(skipLast(2));\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nexport function skipLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipLastOperator(count));\n}\n\nclass SkipLastOperator<T> implements Operator<T, T> {\n  constructor(private _skipCount: number) {\n    if (this._skipCount < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    if (this._skipCount === 0) {\n      // If we don't want to skip any values then just subscribe\n      // to Subscriber without any further logic.\n      return source.subscribe(new Subscriber(subscriber));\n    } else {\n      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipLastSubscriber<T> extends Subscriber<T> {\n  private _ring: T[];\n  private _count: number = 0;\n\n  constructor(destination: Subscriber<T>, private _skipCount: number) {\n    super(destination);\n    this._ring = new Array<T>(_skipCount);\n  }\n\n  protected _next(value: T): void {\n    const skipCount = this._skipCount;\n    const count = this._count++;\n\n    if (count < skipCount) {\n      this._ring[count] = value;\n    } else {\n      const currentIndex = count % skipCount;\n      const ring = this._ring;\n      const oldValue = ring[currentIndex];\n\n      ring[currentIndex] = value;\n      this.destination.next(oldValue);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic, ObservableInput } from '../types';\nimport { Subscription } from '../Subscription';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * The `skipUntil` operator causes the observable stream to skip the emission of values until the passed in observable emits the first value.\n * This can be particularly useful in combination with user interactions, responses of http requests or waiting for specific times to pass by.\n *\n * ![](skipUntil.png)\n *\n * Internally the `skipUntil` operator subscribes to the passed in observable (in the following called *notifier*) in order to recognize the emission\n * of its first value. When this happens, the operator unsubscribes from the *notifier* and starts emitting the values of the *source*\n * observable. It will never let the *source* observable emit any values if the *notifier* completes or throws an error without emitting\n * a value before.\n *\n * ## Example\n *\n * In the following example, all emitted values of the interval observable are skipped until the user clicks anywhere within the page.\n *\n * ```ts\n * import { interval, fromEvent } from 'rxjs';\n * import { skipUntil } from 'rxjs/operators';\n *\n * const intervalObservable = interval(1000);\n * const click = fromEvent(document, 'click');\n *\n * const emitAfterClick = intervalObservable.pipe(\n *   skipUntil(click)\n * );\n * // clicked at 4.6s. output: 5...6...7...8........ or\n * // clicked at 7.3s. output: 8...9...10..11.......\n * const subscribe = emitAfterClick.subscribe(value => console.log(value));\n * ```\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nexport function skipUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipUntilOperator(notifier));\n}\n\nclass SkipUntilOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(destination: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipUntilSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n\n  private hasValue: boolean = false;\n  private innerSubscription?: Subscription;\n\n  constructor(destination: Subscriber<R>, notifier: ObservableInput<any>) {\n    super(destination);\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    this.add(innerSubscriber);\n    this.innerSubscription = innerSubscriber;\n    const innerSubscription = innerSubscribe(notifier, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (innerSubscription !== innerSubscriber) {\n      this.add(innerSubscription);\n      this.innerSubscription = innerSubscription;\n    }\n  }\n\n  protected _next(value: T) {\n    if (this.hasValue) {\n      super._next(value);\n    }\n  }\n\n  notifyNext(): void {\n    this.hasValue = true;\n    if (this.innerSubscription) {\n      this.innerSubscription.unsubscribe();\n    }\n  }\n\n  notifyComplete() {\n    /* do nothing */\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * ![](skipWhile.png)\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipWhileOperator(predicate));\n}\n\nclass SkipWhileOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipWhileSubscriber<T> extends Subscriber<T> {\n  private skipping: boolean = true;\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const destination = this.destination;\n    if (this.skipping) {\n      this.tryCallPredicate(value);\n    }\n\n    if (!this.skipping) {\n      destination.next(value);\n    }\n  }\n\n  private tryCallPredicate(value: T): void {\n    try {\n      const result = this.predicate(value, this.index++);\n      this.skipping = Boolean(result);\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { concat } from '../observable/concat';\nimport { isScheduler } from '../util/isScheduler';\nimport { MonoTypeOperatorFunction, OperatorFunction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T>(scheduler: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D>(v1: D, scheduler: SchedulerLike): OperatorFunction<T, T | D>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D, E>(v1: D, v2: E, scheduler: SchedulerLike): OperatorFunction<T, T | D | E>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D, E, F>(v1: D, v2: E, v3: F, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D, E, F, G>(v1: D, v2:  E, v3: F, v4: G, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F | G>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D, E, F, G, H>(v1: D, v2: E, v3: F, v4: G, v5: H, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F | G | H>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D, E, F, G, H, I>(v1: D, v2: E, v3: F, v4: G, v5: H, v6: I, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F | G | H | I>;\n\nexport function startWith<T, D>(v1: D): OperatorFunction<T, T | D>;\nexport function startWith<T, D, E>(v1: D, v2: E): OperatorFunction<T, T | D | E>;\nexport function startWith<T, D, E, F>(v1: D, v2: E, v3: F): OperatorFunction<T, T | D | E | F>;\nexport function startWith<T, D, E, F, G>(v1: D, v2:  E, v3: F, v4: G): OperatorFunction<T, T | D | E | F | G>;\nexport function startWith<T, D, E, F, G, H>(v1: D, v2: E, v3: F, v4: G, v5: H): OperatorFunction<T, T | D | E | F | G | H>;\nexport function startWith<T, D, E, F, G, H, I>(v1: D, v2: E, v3: F, v4: G, v5: H, v6: I): OperatorFunction<T, T | D | E | F | G | H | I>;\nexport function startWith<T, D = T>(...array: D[]): OperatorFunction<T, T | D>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D = T>(...array: Array<D | SchedulerLike>): OperatorFunction<T, T | D>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <span class=\"informal\">First emits its arguments in order, and then any\n * emissions from the source.</span>\n *\n * ![](startWith.png)\n *\n * ## Examples\n *\n * Start the chain of emissions with `\"first\"`, `\"second\"`\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { startWith } from 'rxjs/operators';\n *\n * of(\"from source\")\n *   .pipe(startWith(\"first\", \"second\"))\n *   .subscribe(x => console.log(x));\n *\n * // results:\n * //   \"first\"\n * //   \"second\"\n * //   \"from source\"\n * ```\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {SchedulerLike} [scheduler] - A {@link SchedulerLike} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nexport function startWith<T, D>(...array: Array<T | SchedulerLike>): OperatorFunction<T, T | D> {\n  const scheduler = array[array.length - 1] as SchedulerLike;\n  if (isScheduler(scheduler)) {\n    // deprecated path\n    array.pop();\n    return (source: Observable<T>) => concat(array as T[], source, scheduler);\n  } else {\n    return (source: Observable<T>) => concat(array as T[], source);\n  }\n}\n","import { SchedulerLike, SchedulerAction } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { asap } from '../scheduler/asap';\nimport { isNumeric } from '../util/isNumeric';\n\nexport interface DispatchArg<T> {\n  source: Observable<T>;\n  subscriber: Subscriber<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class SubscribeOnObservable<T> extends Observable<T> {\n  /** @nocollapse */\n  static create<T>(source: Observable<T>, delay: number = 0, scheduler: SchedulerLike = asap): Observable<T> {\n    return new SubscribeOnObservable(source, delay, scheduler);\n  }\n\n  /** @nocollapse */\n  static dispatch<T>(this: SchedulerAction<T>, arg: DispatchArg<T>): Subscription {\n    const { source, subscriber } = arg;\n    return this.add(source.subscribe(subscriber));\n  }\n\n  constructor(public source: Observable<T>,\n              private delayTime: number = 0,\n              private scheduler: SchedulerLike = asap) {\n    super();\n    if (!isNumeric(delayTime) || delayTime < 0) {\n      this.delayTime = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n      this.scheduler = asap;\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    const delay = this.delayTime;\n    const source = this.source;\n    const scheduler = this.scheduler;\n\n    return scheduler.schedule<DispatchArg<any>>(SubscribeOnObservable.dispatch, delay, {\n      source, subscriber\n    });\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { SubscribeOnObservable } from '../observable/SubscribeOnObservable';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n * Given the following code:\n * ```javascript\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3, 4);\n * const b = of(5, 6, 7, 8, 9);\n * merge(a, b).subscribe(console.log);\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n * This will result in the output of `1 2 3 4 5 6 7 8 9`.\n *\n * But if we instead us the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emited by Observable `a`:\n * ```javascript\n * import { of, merge, asyncScheduler } from 'rxjs';\n * import { subscribeOn } from 'rxjs/operators';\n *\n * const a = of(1, 2, 3, 4).pipe(subscribeOn(asyncScheduler));\n * const b = of(5, 6, 7, 8, 9);\n * merge(a, b).subscribe(console.log);\n * ```\n *\n * The output will instead be `5 6 7 8 9 1 2 3 4`.\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param {SchedulerLike} scheduler - The {@link SchedulerLike} to perform subscription actions on.\n * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified {@link SchedulerLike}.\n .\n * @method subscribeOn\n * @owner Observable\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return function subscribeOnOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new SubscribeOnOperator<T>(scheduler, delay));\n  };\n}\n\nclass SubscribeOnOperator<T> implements Operator<T, T> {\n  constructor(private scheduler: SchedulerLike,\n              private delay: number) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return new SubscribeOnObservable<T>(\n      source, this.delay, this.scheduler\n    ).subscribe(subscriber);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport function switchMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n * Generate new Observable according to source Observable values\n * ```typescript\n * import { of } from 'rxjs';\n * import { switchMap } from 'rxjs/operators';\n *\n * const switched = of(1, 2, 3).pipe(switchMap((x: number) => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // ... and so on\n * ```\n *\n * Rerun an interval Observable on every click event\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { switchMap } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap((ev) => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional deprecated `resultSelector`) to each item\n * emitted by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  if (typeof resultSelector === 'function') {\n    return (source: Observable<T>) => source.pipe(\n      switchMap((a, i) => from(project(a, i)).pipe(\n        map((b, ii) => resultSelector(a, b, i, ii))\n      ))\n    );\n  }\n  return (source: Observable<T>) => source.lift(new SwitchMapOperator(project));\n}\n\nclass SwitchMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchMapSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private index = 0;\n  private innerSubscription?: Subscription;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (error) {\n      this.destination.error!(error);\n      return;\n    }\n    this._innerSub(result);\n  }\n\n  private _innerSub(result: ObservableInput<R>) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    this.innerSubscription = innerSubscribe(result, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (this.innerSubscription !== innerSubscriber) {\n      destination.add(this.innerSubscription);\n    }\n  }\n\n  protected _complete(): void {\n    const {innerSubscription} = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n    this.unsubscribe();\n  }\n\n  protected _unsubscribe() {\n    this.innerSubscription = undefined;\n  }\n\n  notifyComplete(): void {\n    this.innerSubscription = undefined;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n\n  notifyNext(innerValue: R): void {\n      this.destination.next!(innerValue);\n  }\n}\n","import {OperatorFunction, ObservableInput} from '../types';\nimport { switchMap } from './switchMap';\nimport { identity } from '../util/identity';\n\nexport function switchAll<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport function switchAll<R>(): OperatorFunction<any, R>;\n\n/**\n * Converts a higher-order Observable into a first-order Observable\n * producing values only from the most recent observable sequence\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](switchAll.png)\n *\n * `switchAll` subscribes to a source that is an observable of observables, also known as a\n * \"higher-order observable\" (or `Observable<Observable<T>>`). It subscribes to the most recently\n * provided \"inner observable\" emitted by the source, unsubscribing from any previously subscribed\n * to inner observable, such that only the most recent inner observable may be subscribed to at\n * any point in time. The resulting observable returned by `switchAll` will only complete if the\n * source observable completes, *and* any currently subscribed to inner observable also has completed,\n * if there are any.\n *\n * ## Examples\n * Spawn a new interval observable for each click event, but for every new\n * click, cancel the previous interval and subscribe to the new one.\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { switchAll, map, tap } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click').pipe(tap(() => console.log('click')));\n * const source = clicks.pipe(map((ev) => interval(1000)));\n *\n * source.pipe(\n *   switchAll()\n * ).subscribe(x => console.log(x));\n *\n * // Output\n * // click\n * // 1\n * // 2\n * // 3\n * // 4\n * // ...\n * // click\n * // 1\n * // 2\n * // 3\n * // ...\n * // click\n * // ...\n * ```\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link mergeAll}\n */\n\nexport function switchAll<T>(): OperatorFunction<ObservableInput<T>, T> {\n  return switchMap(identity);\n}\n","import { ObservableInput, OperatorFunction } from '../types';\nimport { switchMap } from './switchMap';\n\n/* tslint:disable:max-line-length */\nexport function switchMapTo<R>(observable: ObservableInput<R>): OperatorFunction<any, R>;\n/** @deprecated resultSelector is no longer supported. Switch to using switchMap with an inner map */\nexport function switchMapTo<T, R>(observable: ObservableInput<R>, resultSelector: undefined): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported. Switch to using switchMap with an inner map */\nexport function switchMapTo<T, I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switchMap} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](switchMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * ## Example\n * Rerun an interval Observable on every click event\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { switchMapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMapTo(interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through the deprecated `resultSelector`)\n * every time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nexport function switchMapTo<T, I, R>(\n  innerObservable: ObservableInput<I>,\n  resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, I|R> {\n  return resultSelector ? switchMap(() => innerObservable, resultSelector) : switchMap(() => innerObservable);\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S, inclusive: false): OperatorFunction<T, S>;\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive?: boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * ![](takeWhile.png)\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * ## Example\n * Emit click events only while the clientX property is greater than 200\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { takeWhile } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(takeWhile(ev => ev.clientX > 200));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @param {boolean} inclusive When set to `true` the value that caused\n * `predicate` to return `false` will also be emitted.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nexport function takeWhile<T>(\n    predicate: (value: T, index: number) => boolean,\n    inclusive = false): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) =>\n             source.lift(new TakeWhileOperator(predicate, inclusive));\n}\n\nclass TakeWhileOperator<T> implements Operator<T, T> {\n  constructor(\n      private predicate: (value: T, index: number) => boolean,\n      private inclusive: boolean) {}\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n        new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeWhileSubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(\n      destination: Subscriber<T>,\n      private predicate: (value: T, index: number) => boolean,\n      private inclusive: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const destination = this.destination;\n    let result: boolean;\n    try {\n      result = this.predicate(value, this.index++);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n    this.nextOrComplete(value, result);\n  }\n\n  private nextOrComplete(value: T, predicateResult: boolean): void {\n    const destination = this.destination;\n    if (Boolean(predicateResult)) {\n      destination.next(value);\n    } else {\n      if (this.inclusive) {\n        destination.next(value);\n      }\n      destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, TeardownLogic } from '../types';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Use an observer instead of a complete callback */\nexport function tap<T>(next: null | undefined, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of an error callback */\nexport function tap<T>(next: null | undefined, error: (error: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of a complete callback */\nexport function tap<T>(next: (value: T) => void, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * ![](do.png)\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `tap` is not subscribed, the side effects specified by the\n * Observer will never happen. `tap` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * ## Example\n * Map every click to the clientX position of that click, while also logging the click event\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { tap, map } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(\n *   tap(ev => console.log(ev)),\n *   map(ev => ev.clientX),\n * );\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n * @see {@link Observable#subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nexport function tap<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n                       error?: (e: any) => void,\n                       complete?: () => void): MonoTypeOperatorFunction<T> {\n  return function tapOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nclass DoOperator<T> implements Operator<T, T> {\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              private error?: (e: any) => void,\n              private complete?: () => void) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nclass TapSubscriber<T> extends Subscriber<T> {\n  private _context: any;\n\n  private _tapNext: ((value: T) => void) = noop;\n\n  private _tapError: ((err: any) => void) = noop;\n\n  private _tapComplete: (() => void) = noop;\n\n  constructor(destination: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n      super(destination);\n      this._tapError = error || noop;\n      this._tapComplete = complete || noop;\n      if (isFunction(observerOrNext)) {\n        this._context = this;\n        this._tapNext = observerOrNext;\n      } else if (observerOrNext) {\n        this._context = observerOrNext;\n        this._tapNext = observerOrNext.next || noop;\n        this._tapError = observerOrNext.error || noop;\n        this._tapComplete = observerOrNext.complete || noop;\n      }\n    }\n\n  _next(value: T) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(value);\n  }\n\n  _error(err: any) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.error(err);\n  }\n\n  _complete() {\n    try {\n      this._tapComplete.call(this._context, );\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    return this.destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\nexport interface ThrottleConfig {\n  leading?: boolean;\n  trailing?: boolean;\n}\n\nexport const defaultThrottleConfig: ThrottleConfig = {\n  leading: true,\n  trailing: false\n};\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](throttle.png)\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * ## Example\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { throttle } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttle(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\nexport function throttle<T>(durationSelector: (value: T) => SubscribableOrPromise<any>,\n                            config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing));\n}\n\nclass ThrottleOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private _throttled?: Subscription;\n  private _sendValue?: T;\n  private _hasValue = false;\n\n  constructor(protected destination: Subscriber<T>,\n              private durationSelector: (value: T) => SubscribableOrPromise<number>,\n              private _leading: boolean,\n              private _trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this._hasValue = true;\n    this._sendValue = value;\n\n    if (!this._throttled) {\n      if (this._leading) {\n        this.send();\n      } else {\n        this.throttle(value);\n      }\n    }\n  }\n\n  private send() {\n    const { _hasValue, _sendValue } = this;\n    if (_hasValue) {\n      this.destination.next(_sendValue);\n      this.throttle(_sendValue!);\n    }\n    this._hasValue = false;\n    this._sendValue = undefined;\n  }\n\n  private throttle(value: T): void {\n    const duration = this.tryDurationSelector(value);\n    if (!!duration) {\n      this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));\n    }\n  }\n\n  private tryDurationSelector(value: T): SubscribableOrPromise<any> | null {\n    try {\n      return this.durationSelector(value);\n    } catch (err) {\n      this.destination.error(err);\n      return null;\n    }\n  }\n\n  private throttlingDone() {\n    const { _throttled, _trailing } = this;\n    if (_throttled) {\n      _throttled.unsubscribe();\n    }\n    this._throttled = undefined;\n\n    if (_trailing) {\n      this.send();\n    }\n  }\n\n  notifyNext(): void {\n    this.throttlingDone();\n  }\n\n  notifyComplete(): void {\n    this.throttlingDone();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { ThrottleConfig, defaultThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * ![](throttleTime.png)\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link SchedulerLike} for managing timers.\n *\n * ## Examples\n *\n * #### Limit click rate\n *\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { throttleTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttleTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * #### Double Click\n *\n * The following example only emits clicks which happen within a subsequent\n * delay of 400ms of the previous click. This for example can emulate a double\n * click. It makes use of the `trailing` parameter of the throttle configuration.\n *\n * ```ts\n * import { fromEvent, asyncScheduler } from 'rxjs';\n * import { throttleTime, withLatestFrom } from 'rxjs/operators';\n *\n * // defaultThottleConfig = { leading: true, trailing: false }\n * const throttleConfig = {\n *   leading: false,\n *   trailing: true\n * }\n *\n * const click = fromEvent(document, 'click');\n * const doubleClick = click.pipe(\n *   throttleTime(400, asyncScheduler, throttleConfig)\n * );\n *\n * doubleClick.subscribe((throttleValue: Event) => {\n *   console.log(`Double-clicked! Timestamp: ${throttleValue.timeStamp}`);\n * });\n * ```\n *\n * If you enable the `leading` parameter in this example, the output would be the primary click and\n * the double click, but restricts additional clicks within 400ms.\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the throttling.\n * @param {Object} config a configuration object to define `leading` and\n * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nexport function throttleTime<T>(duration: number,\n                                scheduler: SchedulerLike = async,\n                                config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n}\n\nclass ThrottleTimeOperator<T> implements Operator<T, T> {\n  constructor(private duration: number,\n              private scheduler: SchedulerLike,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleTimeSubscriber<T> extends Subscriber<T> {\n  private throttled: Subscription;\n  private _hasTrailingValue: boolean = false;\n  private _trailingValue: T = null;\n\n  constructor(destination: Subscriber<T>,\n              private duration: number,\n              private scheduler: SchedulerLike,\n              private leading: boolean,\n              private trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    if (this.throttled) {\n      if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    } else {\n      this.add(this.throttled = this.scheduler.schedule<DispatchArg<T>>(dispatchNext, this.duration, { subscriber: this }));\n      if (this.leading) {\n        this.destination.next(value);\n      } else if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    }\n  }\n\n  protected _complete() {\n    if (this._hasTrailingValue) {\n      this.destination.next(this._trailingValue);\n      this.destination.complete();\n    } else {\n      this.destination.complete();\n    }\n  }\n\n  clearThrottle() {\n    const throttled = this.throttled;\n    if (throttled) {\n      if (this.trailing && this._hasTrailingValue) {\n        this.destination.next(this._trailingValue);\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n      }\n      throttled.unsubscribe();\n      this.remove(throttled);\n      this.throttled = null;\n    }\n  }\n}\n\ninterface DispatchArg<T> {\n  subscriber: ThrottleTimeSubscriber<T>;\n}\n\nfunction dispatchNext<T>(arg: DispatchArg<T>) {\n  const { subscriber } = arg;\n  subscriber.clearThrottle();\n}\n","\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { SchedulerLike, OperatorFunction } from '../types';\nimport { scan } from './scan';\nimport { defer } from '../observable/defer';\nimport { map } from './map';\n\n/**\n *\n * Emits an object containing the current value, and the time that has\n * passed between emitting the current value and the previous value, which is\n * calculated by using the provided `scheduler`'s `now()` method to retrieve\n * the current time at each emission, then calculating the difference. The `scheduler`\n * defaults to {@link asyncScheduler}, so by default, the `interval` will be in\n * milliseconds.\n *\n * <span class=\"informal\">Convert an Observable that emits items into one that\n * emits indications of the amount of time elapsed between those emissions.</span>\n *\n * ![](timeinterval.png)\n *\n * ## Examples\n * Emit inteval between current value with the last value\n *\n * ```ts\n * const seconds = interval(1000);\n *\n * seconds.pipe(timeInterval())\n * .subscribe(\n *     value => console.log(value),\n *     err => console.log(err),\n * );\n *\n * seconds.pipe(timeout(900))\n * .subscribe(\n *     value => console.log(value),\n *     err => console.log(err),\n * );\n *\n * // NOTE: The values will never be this precise,\n * // intervals created with `interval` or `setInterval`\n * // are non-deterministic.\n *\n * // {value: 0, interval: 1000}\n * // {value: 1, interval: 1000}\n * // {value: 2, interval: 1000}\n * ```\n *\n * @param {SchedulerLike} [scheduler] Scheduler used to get the current time.\n * @return {Observable<{ interval: number, value: T }>} Observable that emit infomation about value and interval\n * @method timeInterval\n */\nexport function timeInterval<T>(scheduler: SchedulerLike = async): OperatorFunction<T, TimeInterval<T>> {\n  return (source: Observable<T>) => defer(() => {\n    return source.pipe(\n      // TODO(benlesh): correct these typings.\n      scan(\n        ({ current }, value) => ({ value, current: scheduler.now(), last: current }),\n        { current: scheduler.now(), value: undefined,  last: undefined }\n      ) as any,\n      map<any, TimeInterval<T>>(({ current, last, value }) => new TimeInterval(value, current - last)),\n    );\n  });\n}\n\n// TODO(benlesh): make this an interface, export the interface, but not the implemented class,\n// there's no reason users should be manually creating this type.\n\n/**\n * @deprecated exposed API, use as interface only.\n */\nexport class TimeInterval<T> {\n  constructor(public value: T, public interval: number) {}\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { isDate } from '../util/isDate';\nimport { ObservableInput, OperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function timeoutWith<T, R>(due: number | Date, withObservable: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * ![](timeoutWith.png)\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * ## Example\n * Add fallback observable\n * ```ts\n * import { interval } from 'rxjs';\n * import { timeoutWith } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n * const minutes = interval(60 * 1000);\n *\n * seconds.pipe(timeoutWith(900, minutes))\n *   .subscribe(\n *     value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                  // since first value of `seconds` will not arrive fast enough.\n *     err => console.log(err),     // Would be called after 900ms in case of `timeout`,\n *                                  // but here will never be called.\n *   );\n * ```\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {SchedulerLike} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\nexport function timeoutWith<T, R>(due: number | Date,\n                                  withObservable: ObservableInput<R>,\n                                  scheduler: SchedulerLike = async): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => {\n    let absoluteTimeout = isDate(due);\n    let waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(<number>due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nclass TimeoutWithOperator<T> implements Operator<T, T> {\n  constructor(private waitFor: number,\n              private absoluteTimeout: boolean,\n              private withObservable: ObservableInput<any>,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TimeoutWithSubscriber(\n      subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TimeoutWithSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n\n  private action?: SchedulerAction<TimeoutWithSubscriber<T, R>>;\n\n  constructor(destination: Subscriber<T>,\n              private absoluteTimeout: boolean,\n              private waitFor: number,\n              private withObservable: ObservableInput<any>,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    this.scheduleTimeout();\n  }\n\n  private static dispatchTimeout<T, R>(subscriber: TimeoutWithSubscriber<T, R>): void {\n    const { withObservable } = subscriber;\n    subscriber._unsubscribeAndRecycle();\n    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));\n  }\n\n  private scheduleTimeout(): void {\n    const { action } = this;\n    if (action) {\n      // Recycle the action if we've already scheduled one. All the production\n      // Scheduler Actions mutate their state/delay time and return themeselves.\n      // VirtualActions are immutable, so they create and return a clone. In this\n      // case, we need to set the action reference to the most recent VirtualAction,\n      // to ensure that's the one we clone from next time.\n      this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> action.schedule(this, this.waitFor));\n    } else {\n      this.add(this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> this.scheduler.schedule<TimeoutWithSubscriber<T, R>>(\n        TimeoutWithSubscriber.dispatchTimeout as any, this.waitFor, this\n      )));\n    }\n  }\n\n  protected _next(value: T): void {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n    super._next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.action = undefined;\n    this.scheduler = null!;\n    this.withObservable = null!;\n  }\n}\n","import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TimeoutError } from '../util/TimeoutError';\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\nimport { timeoutWith } from './timeoutWith';\nimport { throwError } from '../observable/throwError';\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * ## Examples\n * Check if ticks are emitted within certain timespan\n * ```ts\n * import { interval } from 'rxjs';\n * import { timeout } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n *\n * seconds.pipe(timeout(1100))      // Let's use bigger timespan to be safe,\n *                                  // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err),     // Will never be called.\n * );\n *\n * seconds.pipe(timeout(900))\n * .subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err),     // Will emit error before even first value is emitted,\n *                                  // since it did not arrive within 900ms period.\n * );\n * ```\n *\n * Use Date to check if Observable completed\n * ```ts\n * import { interval } from 'rxjs';\n * import { timeout } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n *\n * seconds.pipe(\n *   timeout(new Date(\"December 17, 2020 03:24:00\")),\n * )\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err)      // On December 17, 2020 at 03:24:00 it will emit an error,\n *                                  // since Observable did not complete by then.\n * );\n * ```\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {SchedulerLike} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nexport function timeout<T>(due: number | Date,\n                           scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return timeoutWith(due, throwError(new TimeoutError()), scheduler);\n}\n","\nimport { async } from '../scheduler/async';\nimport { OperatorFunction, SchedulerLike, Timestamp as TimestampInterface } from '../types';\nimport { map } from './map';\n\n/**\n * Attaches a timestamp to each item emitted by an observable indicating when it was emitted\n *\n * The `timestamp` operator maps the *source* observable stream to an object of type\n * `{value: T, timestamp: R}`. The properties are generically typed. The `value` property contains the value\n * and type of the *source* observable. The `timestamp` is generated by the schedulers `now` function. By\n * default it uses the *async* scheduler which simply returns `Date.now()` (milliseconds since 1970/01/01\n * 00:00:00:000) and therefore is of type `number`.\n *\n * ![](timestamp.png)\n *\n * ## Example\n *\n * In this example there is a timestamp attached to the documents click event.\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { timestamp } from 'rxjs/operators';\n *\n * const clickWithTimestamp = fromEvent(document, 'click').pipe(\n *   timestamp()\n * );\n *\n * // Emits data of type {value: MouseEvent, timestamp: number}\n * clickWithTimestamp.subscribe(data => {\n *   console.log(data);\n * });\n * ```\n *\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nexport function timestamp<T>(scheduler: SchedulerLike = async): OperatorFunction<T, Timestamp<T>> {\n  return map((value: T) => new Timestamp(value, scheduler.now()));\n  // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));\n}\n\nexport class Timestamp<T> implements TimestampInterface<T> {\n  constructor(public value: T, public timestamp: number) {\n  }\n}\n","import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\nimport { Subject } from '../Subject';\nimport { Subscriber } from '../Subscriber';\nimport { Operator } from '../Operator';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * ![](window.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * ## Example\n * In every window of 1 second each, emit at most 2 click events\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { window, mergeAll, map, take } from 'rxjs/operators';\n *\n *  const clicks = fromEvent(document, 'click');\n *  const sec = interval(1000);\n *  const result = clicks.pipe(\n *      window(sec),\n *      map(win => win.pipe(take(2))), // each window has at most 2 emissions\n *      mergeAll(),              // flatten the Observable-of-Observables\n *  );\n *  result.subscribe(x => console.log(x));\n * ```\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nexport function window<T>(windowBoundaries: Observable<any>): OperatorFunction<T, Observable<T>> {\n  return function windowOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowOperator(windowBoundaries));\n  };\n}\n\nclass WindowOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowBoundaries: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    const windowSubscriber = new WindowSubscriber(subscriber);\n    const sourceSubscription = source.subscribe(windowSubscriber);\n    if (!sourceSubscription.closed) {\n      windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));\n    }\n    return sourceSubscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowSubscriber<T> extends SimpleOuterSubscriber<T, any> {\n\n  private window: Subject<T> = new Subject<T>();\n\n  constructor(destination: Subscriber<Observable<T>>) {\n    super(destination);\n    destination.next(this.window);\n  }\n\n  notifyNext(): void {\n    this.openWindow();\n  }\n\n  notifyError(error: any): void {\n    this._error(error);\n  }\n\n  notifyComplete(): void {\n    this._complete();\n  }\n\n  protected _next(value: T): void {\n    this.window.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.window.error(err);\n    this.destination.error!(err);\n  }\n\n  protected _complete(): void {\n    this.window.complete();\n    this.destination.complete!();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.window = null!;\n  }\n\n  private openWindow(): void  {\n    const prevWindow = this.window;\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n    const destination = this.destination;\n    const newWindow = this.window = new Subject<T>();\n    destination.next!(newWindow);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowCount.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * ## Examples\n * Ignore every 3rd click event, starting from the first one\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowCount, map, mergeAll, skip } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(3),\n *   map(win => win.pipe(skip(1))), // skip first of every 3 clicks\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Ignore every 3rd click event, starting from the third one\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowCount, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(2, 3),\n *   mergeAll(),              // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nexport function windowCount<T>(windowSize: number,\n                               startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\n  return function windowCountOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowCountOperator<T>(windowSize, startWindowEvery));\n  };\n}\n\nclass WindowCountOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowSize: number,\n              private startWindowEvery: number) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowCountSubscriber<T> extends Subscriber<T> {\n  private windows: Subject<T>[] = [ new Subject<T>() ];\n  private count: number = 0;\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowSize: number,\n              private startWindowEvery: number) {\n    super(destination);\n    destination.next(this.windows[0]);\n  }\n\n  protected _next(value: T) {\n    const startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n    const destination = this.destination;\n    const windowSize = this.windowSize;\n    const windows = this.windows;\n    const len = windows.length;\n\n    for (let i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n    const c = this.count - windowSize + 1;\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      const window = new Subject<T>();\n      windows.push(window);\n      destination.next(window);\n    }\n  }\n\n  protected _error(err: any) {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete() {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  protected _unsubscribe() {\n    this.count = 0;\n    this.windows = null;\n  }\n}\n","import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction, SchedulerLike, SchedulerAction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowTime.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * ## Examples\n * In every window of 1 second each, emit at most 2 click events\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000),\n *   map(win => win.pipe(take(2))), // each window has at most 2 emissions\n *   mergeAll(),                    // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000),\n *   map(win => win.pipe(take(2))), // each window has at most 2 emissions\n *   mergeAll(),                    // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Same as example above but with maxWindowCount instead of take\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000, 2), // each window has still at most 2 emissions\n *   mergeAll(),                // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param {number} windowTimeSpan The amount of time to fill each window.\n * @param {number} [windowCreationInterval] The interval at which to start new\n * windows.\n * @param {number} [maxWindowSize=Number.POSITIVE_INFINITY] Max number of\n * values each window can emit before completion.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowTime\n * @owner Observable\n */\nexport function windowTime<T>(windowTimeSpan: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              maxWindowSize: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\n\nexport function windowTime<T>(windowTimeSpan: number): OperatorFunction<T, Observable<T>> {\n  let scheduler: SchedulerLike = async;\n  let windowCreationInterval: number = null;\n  let maxWindowSize: number = Number.POSITIVE_INFINITY;\n\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = Number(arguments[2]);\n  }\n\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = Number(arguments[1]);\n  }\n\n  return function windowTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowTimeOperator<T>(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\n\nclass WindowTimeOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowTimeSpan: number,\n              private windowCreationInterval: number | null,\n              private maxWindowSize: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowTimeSubscriber(\n      subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler\n    ));\n  }\n}\n\ninterface CreationState<T> {\n  windowTimeSpan: number;\n  windowCreationInterval: number;\n  subscriber: WindowTimeSubscriber<T>;\n  scheduler: SchedulerLike;\n}\n\ninterface TimeSpanOnlyState<T> {\n    window: CountedSubject<T>;\n    windowTimeSpan: number;\n    subscriber: WindowTimeSubscriber<T>;\n  }\n\ninterface CloseWindowContext<T> {\n  action: SchedulerAction<CreationState<T>>;\n  subscription: Subscription;\n}\n\ninterface CloseState<T> {\n  subscriber: WindowTimeSubscriber<T>;\n  window: CountedSubject<T>;\n  context: CloseWindowContext<T>;\n}\n\nclass CountedSubject<T> extends Subject<T> {\n  private _numberOfNextedValues: number = 0;\n\n  next(value?: T): void {\n    this._numberOfNextedValues++;\n    super.next(value);\n  }\n\n  get numberOfNextedValues(): number {\n    return this._numberOfNextedValues;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowTimeSubscriber<T> extends Subscriber<T> {\n  private windows: CountedSubject<T>[] = [];\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowTimeSpan: number,\n              private windowCreationInterval: number | null,\n              private maxWindowSize: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n\n    const window = this.openWindow();\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      const closeState: CloseState<T> = { subscriber: this, window, context: <any>null };\n      const creationState: CreationState<T> = { windowTimeSpan, windowCreationInterval, subscriber: this, scheduler };\n      this.add(scheduler.schedule<CloseState<T>>(dispatchWindowClose, windowTimeSpan, closeState));\n      this.add(scheduler.schedule<CreationState<T>>(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      const timeSpanOnlyState: TimeSpanOnlyState<T> = { subscriber: this, window, windowTimeSpan };\n      this.add(scheduler.schedule<TimeSpanOnlyState<T>>(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  protected _next(value: T): void {\n    const windows = this.windows;\n    const len = windows.length;\n    for (let i = 0; i < len; i++) {\n      const window = windows[i];\n      if (!window.closed) {\n        window.next(value);\n        if (window.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window);\n        }\n      }\n    }\n  }\n\n  protected _error(err: any): void {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete(): void {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      const window = windows.shift();\n      if (!window.closed) {\n        window.complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  public openWindow(): CountedSubject<T> {\n    const window = new CountedSubject<T>();\n    this.windows.push(window);\n    const destination = this.destination;\n    destination.next(window);\n    return window;\n  }\n\n  public closeWindow(window: CountedSubject<T>): void {\n    window.complete();\n    const windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  }\n}\n\nfunction dispatchWindowTimeSpanOnly<T>(this: SchedulerAction<TimeSpanOnlyState<T>>, state: TimeSpanOnlyState<T>): void {\n  const { subscriber, windowTimeSpan, window } = state;\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\nfunction dispatchWindowCreation<T>(this: SchedulerAction<CreationState<T>>, state: CreationState<T>): void {\n  const { windowTimeSpan, subscriber, scheduler, windowCreationInterval } = state;\n  const window = subscriber.openWindow();\n  const action = this;\n  let context: CloseWindowContext<T> = { action, subscription: <any>null };\n  const timeSpanState: CloseState<T> = { subscriber, window, context };\n  context.subscription = scheduler.schedule<CloseState<T>>(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose<T>(state: CloseState<T>): void {\n  const { subscriber, window, context } = state;\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n  subscriber.closeWindow(window);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowToggle.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * ## Example\n * Every other second, emit the click events from the next 500ms\n * ```ts\n * import { fromEvent, interval, EMPTY } from 'rxjs';\n * import { windowToggle, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const result = clicks.pipe(\n *   windowToggle(openings, i => i % 2 ? interval(500) : EMPTY),\n *   mergeAll()\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nexport function windowToggle<T, O>(openings: Observable<O>,\n                                   closingSelector: (openValue: O) => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return (source: Observable<T>) => source.lift(new WindowToggleOperator<T, O>(openings, closingSelector));\n}\n\nclass WindowToggleOperator<T, O> implements Operator<T, Observable<T>> {\n\n  constructor(private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowToggleSubscriber(\n      subscriber, this.openings, this.closingSelector\n    ));\n  }\n}\n\ninterface WindowContext<T> {\n  window: Subject<T>;\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowToggleSubscriber<T, O> extends OuterSubscriber<T, any> {\n  private contexts: WindowContext<T>[] = [];\n  private openSubscription: Subscription;\n\n  constructor(destination: Subscriber<Observable<T>>,\n              private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n    super(destination);\n    this.add(this.openSubscription = subscribeToResult(this, openings, openings as any));\n  }\n\n  protected _next(value: T) {\n    const { contexts } = this;\n    if (contexts) {\n      const len = contexts.length;\n      for (let i = 0; i < len; i++) {\n        contexts[i].window.next(value);\n      }\n    }\n  }\n\n  protected _error(err: any) {\n\n    const { contexts } = this;\n    this.contexts = null;\n\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.error(err);\n        context.subscription.unsubscribe();\n      }\n    }\n\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.complete();\n        context.subscription.unsubscribe();\n      }\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.unsubscribe();\n        context.subscription.unsubscribe();\n      }\n    }\n  }\n\n  notifyNext(outerValue: any, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n\n    if (outerValue === this.openings) {\n      let closingNotifier;\n      try {\n        const { closingSelector } = this;\n        closingNotifier = closingSelector(innerValue);\n      } catch (e) {\n        return this.error(e);\n      }\n\n      const window = new Subject<T>();\n      const subscription = new Subscription();\n      const context = { window, subscription };\n      this.contexts.push(context);\n      const innerSubscription = subscribeToResult(this, closingNotifier, context as any);\n\n      if (innerSubscription.closed) {\n        this.closeWindow(this.contexts.length - 1);\n      } else {\n        (<any>innerSubscription).context = context;\n        subscription.add(innerSubscription);\n      }\n\n      this.destination.next(window);\n    } else {\n      this.closeWindow(this.contexts.indexOf(outerValue));\n    }\n  }\n\n  notifyError(err: any): void {\n    this.error(err);\n  }\n\n  notifyComplete(inner: Subscription): void {\n    if (inner !== this.openSubscription) {\n      this.closeWindow(this.contexts.indexOf((<any> inner).context));\n    }\n  }\n\n  private closeWindow(index: number): void {\n    if (index === -1) {\n      return;\n    }\n\n    const { contexts } = this;\n    const context = contexts[index];\n    const { window, subscription } = context;\n    contexts.splice(index, 1);\n    window.complete();\n    subscription.unsubscribe();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowWhen.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * ## Example\n * Emit only the first two clicks events in every window of [1-5] random seconds\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { windowWhen, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\n *   map(win => win.pipe(take(2))),     // each window has at most 2 emissions\n *   mergeAll()                         // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nexport function windowWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return function windowWhenOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowOperator<T>(closingSelector));\n  };\n}\n\nclass WindowOperator<T> implements Operator<T, Observable<T>> {\n  constructor(private closingSelector: () => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowSubscriber<T> extends OuterSubscriber<T, any> {\n  private window?: Subject<T>;\n  private closingNotification?: Subscription;\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private closingSelector: () => Observable<any>) {\n    super(destination);\n    this.openWindow();\n  }\n\n  notifyNext(_outerValue: T, _innerValue: any,\n             _outerIndex: number, _innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow(innerSub);\n  }\n\n  notifyError(error: any): void {\n    this._error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow(innerSub);\n  }\n\n  protected _next(value: T): void {\n    this.window!.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.window!.error(err);\n    this.destination.error(err);\n    this.unsubscribeClosingNotification();\n  }\n\n  protected _complete(): void {\n    this.window!.complete();\n    this.destination.complete();\n    this.unsubscribeClosingNotification();\n  }\n\n  private unsubscribeClosingNotification(): void {\n    if (this.closingNotification) {\n      this.closingNotification.unsubscribe();\n    }\n  }\n\n  private openWindow(innerSub: InnerSubscriber<T, any> | null = null): void {\n    if (innerSub) {\n      this.remove(innerSub);\n      innerSub.unsubscribe();\n    }\n\n    const prevWindow = this.window;\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n\n    const window = this.window = new Subject<T>();\n    this.destination.next(window);\n\n    let closingNotifier;\n    try {\n      const { closingSelector } = this;\n      closingNotifier = closingSelector();\n    } catch (e) {\n      this.destination.error(e);\n      this.window.error(e);\n      return;\n    }\n    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function withLatestFrom<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, R>(source2: O2, project: (v1: T, v2: ObservedValueOf<O2>) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, R>(v2: O2, v3: O3, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, R>(v2: O2, v3: O3, v4: O4, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, R>(v2: O2, v3: O3, v4: O4, v5: O5, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>, R>(v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>, v6: ObservedValueOf<O6>) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>>(source2: O2): OperatorFunction<T, [T, ObservedValueOf<O2>]>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v2: O2, v3: O3): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v2: O2, v3: O3, v4: O4): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v2: O2, v3: O3, v4: O4, v5: O5): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v2: O2, v3: O3, v4: O4, v5: O5, v6: O6): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\nexport function withLatestFrom<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R>;\nexport function withLatestFrom<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, R>;\nexport function withLatestFrom<T, R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): OperatorFunction<T, R>;\n\n/* tslint:enable:max-line-length */\n\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * ![](withLatestFrom.png)\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * ## Example\n * On every click event, emit an array with the latest timer event plus the click event\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { withLatestFrom } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const result = clicks.pipe(withLatestFrom(timer));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.pipe(withLatestFrom(b, c), map(([a1, b1, c1]) => a1 + b1 + c1))`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nexport function withLatestFrom<T, R>(...args: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    let project: any;\n    if (typeof args[args.length - 1] === 'function') {\n      project = args.pop();\n    }\n    const observables = <Observable<any>[]>args;\n    return source.lift(new WithLatestFromOperator(observables, project));\n  };\n}\n\nclass WithLatestFromOperator<T, R> implements Operator<T, R> {\n  constructor(private observables: Observable<any>[],\n              private project?: (...values: any[]) => Observable<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WithLatestFromSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private values: any[];\n  private toRespond: number[] = [];\n\n  constructor(destination: Subscriber<R>,\n              private observables: Observable<any>[],\n              private project?: (...values: any[]) => Observable<R>) {\n    super(destination);\n    const len = observables.length;\n    this.values = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      this.toRespond.push(i);\n    }\n\n    for (let i = 0; i < len; i++) {\n      let observable = observables[i];\n      this.add(subscribeToResult<T, R>(this, observable, undefined, i));\n    }\n  }\n\n  notifyNext(_outerValue: T, innerValue: R,\n             outerIndex: number): void {\n    this.values[outerIndex] = innerValue;\n    const toRespond = this.toRespond;\n    if (toRespond.length > 0) {\n      const found = toRespond.indexOf(outerIndex);\n      if (found !== -1) {\n        toRespond.splice(found, 1);\n      }\n    }\n  }\n\n  notifyComplete() {\n    // noop\n  }\n\n  protected _next(value: T) {\n    if (this.toRespond.length === 0) {\n      const args = [value, ...this.values];\n      if (this.project) {\n        this._tryProject(args);\n      } else {\n        this.destination.next!(args);\n      }\n    }\n  }\n\n  private _tryProject(args: any[]) {\n    let result: any;\n    try {\n      result = this.project!.apply(this, args);\n    } catch (err) {\n      this.destination.error!(err);\n      return;\n    }\n    this.destination.next!(result);\n  }\n}\n","import { zip as zipStatic } from '../observable/zip';\nimport { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, R>(array: Array<ObservableInput<T>>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, TOther, R>(array: Array<ObservableInput<TOther>>, project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * @deprecated Deprecated in favor of static {@link zip}.\n */\nexport function zip<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  return function zipOperatorFunction(source: Observable<T>) {\n    return source.lift.call(zipStatic<R>(source, ...observables));\n  };\n}","import { ZipOperator } from '../observable/zip';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, ObservableInput } from '../types';\n\nexport function zipAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function zipAll<T>(): OperatorFunction<any, T[]>;\nexport function zipAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function zipAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n\nexport function zipAll<T, R>(project?: (...values: Array<any>) => R): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new ZipOperator(project));\n}\n"],"names":["__importDefault","this","mod","__esModule","Object","defineProperty","exports","value","BBI","binary_parser_1","require","generic_filehandle_1","rxjs_1","operators_1","abortable_promise_cache_1","quick_lru_1","blockView_1","BIG_WIG_MAGIC","BIG_BED_MAGIC","getParsers","isBE","le","headerParser","Parser","endianess","int32","uint16","uint64","uint32","array","length","type","totalSummaryParser","double","chromTreeParser","isLeafNode","uint8","skip","options","headerCache","default","cache","maxSize","fill","params","signal","_getHeader","filehandle","renameRefSeqs","path","url","s","bbi","RemoteFile","Error","LocalFile","opts","get","JSON","stringify","_getMainHeader","header","_readChromTree","chroms","requestSize","read","Buffer","alloc","buffer","isBigEndian","_isBigEndian","ret","parse","result","fileType","magic","asOffset","totalSummaryOffset","autoSql","slice","indexOf","toString","tail","totalSummary","readInt32LE","readInt32BE","refsByNumber","refsByName","chromTreeOffset","unzoomedDataOffset","data","p","keySize","leafNodeParser","string","stripNull","nonleafNodeParser","bptReadNode","currentOffset","offset","cnt","n","leafRet","key","refId","refSize","refRec","name","id","nextNodes","nonleafRet","childOffset","push","Promise","all","getHeader","unzoomedIndexOffset","zoomLevels","uncompressBufSize","nzl","cirLen","dataOffset","BlockView","refName","start","end","scale","chrName","basesPerSpan","getView","view","Observable","observer","readWigData","getFeatureStream","ob","pipe","reduce","acc","curr","concat","toPromise","BigBed","filterUndef","bbi_1","ts","filter","t","readIndicesCache","args","_readIndices","getUnzoomedView","extHeaderOffset","count","len","blocklen","extParser","int16","indices","i","readIndices","locs","map","index","field","blockSize","valSize","bpt","int8","choice","tag","choices","nodeOffset","node","leafkeys","localeCompare","lastOffset","keys","undefined","searchExtraIndexBlocks","blocks","res","block","readFeatures","x","merge","f","rest","split","BigWig","fileSize","basesPerPx","maxLevel","zh","reductionLevel","indexLength","indexOffset","unzip_1","range_1","util_1","cirTreeOffset","cirTreeLength","isCompressed","blockType","featureCache","requestData","assign","summaryParser","float","leafParser","bigBedParser","zeroTerminated","bigWigParser","chrId","complete","request","cirTreePromise","cirBlockSize","readUInt32BE","readUInt32LE","blocksToFetch","outstanding","cirFobRecur2","cirBlockData","level","filterFeats","l","blockOffset","recurOffsets","cirFobRecur","e","error","b","startChrom","startBase","endChrom","endBase","cirFobStartFetch","off","fr","max","min","resultBuffer","contains","maxCirBlockSpan","spans","blockSpan","union","getRanges","startOffset","features","currOffset","byteLength","items","elt","chromId","feats","maxScore","minScore","score","sumData","validCnt","summary","coordFilter","uniqueId","bytes","results","itemSpan","itemStep","blockStart","blockGroupsToFetch","groupBlocks","checkAbortSignal","blockGroup","forEach","resultData","unzip","next","parseSummaryBlock","parseBigWigBlock","parseBigBedBlock","console","warn","range","bigwig_1","enumerable","bigbed_1","Range","arg1","arg2","ranges","arguments","pos","r","join","s1","sort","rangeOrder","oranges","current","nxt","arg","s0","r0","r1","l0","l1","i0","i1","or","lapMin","Math","lapMax","tot","rl","ri","tmpa","tmpb","a","pako_1","input","from","inflate","abortBreakPoint","AbortError","message","code","aborted","DOMException","resolve","b0","b1","lastBlock","lastBlockEnd","blockGroups","AnimationFrameAction","_super","scheduler","work","_this","tslib_1","delay","requestAsyncId","call","requestAnimationFrame","cancelAnimationFrame","AsyncAction","AnimationFrameScheduler","active","actions","action","AsyncScheduler","animationFrameScheduler","VirtualTimeScheduler","SchedulerAction","maxFrames","Number","prototype","flush","_a","frame","VirtualAction","schedule","state","recycleAsyncId","isObservable","obj","bindCallback","callbackFunc","resultSelector","isScheduler","subject","context","subscriber","AsyncSubject","handler","_i","innerArgs","err","canReportError","dispatch","dispatchNext","bindNodeCallback","dispatchError","sources","first_1","isArray","isObject","pop","forkJoinInternal","values","Array","completed","_loop_1","source","hasValue","emitted","fromEventPattern","addHandler","removeHandler","retValue","generate","initialStateOrOptions","condition","iterate","resultSelectorOrObservable","initialState","identity","conditionResult","trueResult","period","async","counter","never","first","remainder","subscribe","pairs","subscription","closed","partition","predicate","thisArg","subscribeTo","using","resourceFactory","observableFactory","resource","EMPTY","_subscribe","thrownError","hasCompleted","hasNext","BehaviorSubject","_value","configurable","getValue","NotificationKind","Notification","kind","observe","do","accept","nextOrObserver","toObservable","of","throwError","OuterSubscriber","notifyNext","notifyError","notifyComplete","ReplaySubject","bufferSize","windowTime","nextInfiniteTimeWindow","_events","nextTimeWindow","_getNow","_infiniteTimeWindow","SubjectSubscription","queue","now","_trimBufferThenGetEvents","_bufferSize","_windowTime","spliceCount","time","eventsCount","ReplayEvent","SubjectSubscriber","destination","Subject","rxSubscriberSymbol","lift","AnonymousSubject","operator","observers","copy","hasError","unsubscribe","isStopped","_trySubscribe","asObservable","observable","subscriberIndex","ConnectableObservable","subjectFactory","getSubject","_subject","connect","connection","_connection","refCount","connectableObservableDescriptor","_refCount","writable","connectableProto","_isComplete","ConnectableSubscriber","connectable","_error","_complete","_unsubscribe","observables","CombineLatestOperator","CombineLatestSubscriber","_next","NONE","toRespond","oldVal","innerValue","defer","empty","RaceOperator","RaceSubscriber","hasFirst","subscriptions","outerIndex","dueTime","periodOrScheduler","ZipOperator","ZipSubscriber","create","iterators","StaticArrayIterator","StaticIterator","iterator","notifyInactive","checkIterators","shouldComplete","_tryresultSelector","apply","done","ZipBufferIterator","parent","isComplete","concatAll","groupBy","keySelector","elementSelector","durationSelector","subjectSelector","GroupByOperator","GroupBySubscriber","_group","groups","element","group","groupedObservable","duration","removeGroup","attemptedToUnsubscribe","Subscriber","GroupDurationSubscriber","GroupedObservable","refCountSubscription","groupSubject","InnerRefCountSubscription","ObserveOnOperator","notification","ObserveOnSubscriber","scheduleMessage","RefCountOperator","refCounter","RefCountSubscriber","sharedConnection","setInterval","clearInterval","execute","pending","_execute","errored","errorValue","Action","Scheduler","nextHandle","RESOLVED","findAndClearHandle","handle","activeHandles","cb","AsapAction","Immediate","AsapScheduler","asapScheduler","asyncScheduler","QueueAction","QueueScheduler","queueScheduler","EmptyErrorImpl","ObjectUnsubscribedErrorImpl","TimeoutErrorImpl","isNumeric","val","not","pred","notPred","InnerSubscriber","outerValue","innerSubscriber","audit","AuditOperator","AuditSubscriber","throttled","innerSubscription","innerSubscribe","SimpleInnerSubscriber","clearThrottle","remove","closingNotifier","BufferOperator","BufferSubscriber","startBufferEvery","BufferCountOperator","BufferCountSubscriber","BufferSkipCountSubscriber","buffers","bufferTime","bufferTimeSpan","bufferCreationInterval","maxBufferSize","BufferTimeOperator","Context","BufferTimeSubscriber","closeState","add","dispatchBufferClose","contexts","context_1","filledBufferContext","onBufferFull","closeContext","closeAction","timeSpanOnlyState","openContext","dispatchBufferTimeSpanOnly","prevContext","dispatchBufferCreation","bufferToggle","openings","closingSelector","BufferToggleOperator","BufferToggleSubscriber","context_2","closeBuffer","trySubscribe","Subscription","subscribeToResult","bufferWhen","BufferWhenOperator","BufferWhenSubscriber","subscribing","closingSubscription","catchError","selector","CatchOperator","CatchSubscriber","caught","err2","_unsubscribeAndRecycle","combineAll","project","concatMap","concatMapTo","innerObservable","CountOperator","CountSubscriber","debounce","DebounceOperator","DebounceSubscriber","emitValue","_tryNext","DebounceTimeOperator","DebounceTimeSubscriber","clearDebounce","debouncedNext","lastValue","debouncedSubscription","isDate","DelayOperator","DelaySubscriber","delay_1","_schedule","DelayMessage","scheduleNotification","delayWhen","delayDurationSelector","subscriptionDelay","SubscriptionDelayObservable","DelayWhenOperator","DelayWhenSubscriber","removeSubscription","innerSub","delayNotifier","tryComplete","subscriptionIdx","delayNotifierSubscriptions","tryDelay","notifierSubscription","SubscriptionDelaySubscriber","subscribeToSource","sourceSubscribed","dematerialize","DeMaterializeOperator","DeMaterializeSubscriber","distinct","flushes","DistinctOperator","DistinctSubscriber","_finalizeNext","distinctUntilChanged","compare","DistinctUntilChangedOperator","DistinctUntilChangedSubscriber","hasKey","distinctUntilKeyChanged","errorFactory","defaultErrorFactory","ThrowIfEmptyOperator","ThrowIfEmptySubscriber","take","TakeOperator","total","TakeSubscriber","elementAt","defaultValue","v","hasDefaultValue","defaultIfEmpty","every","EveryOperator","EverySubscriber","everyValueMatch","exhaust","SwitchFirstOperator","SwitchFirstSubscriber","hasSubscription","exhaustMap","ExhaustMapOperator","ExhaustMapSubscriber","_innerSub","concurrent","ExpandOperator","ExpandSubscriber","subscribeToProjection","finalize","callback","FinallyOperator","FinallySubscriber","find","FindValueOperator","FindValueSubscriber","yieldIndex","findIndex","ignoreElements","IgnoreElementsOperator","IgnoreElementsSubscriber","isEmpty","IsEmptyOperator","IsEmptySubscriber","last","mapTo","MapToOperator","MapToSubscriber","materialize","MaterializeOperator","MaterializeSubscriber","comparer","y","accumulator","seed","MergeScanOperator","MergeScanSubscriber","ish","multicast","subjectOrSubjectFactory","MulticastOperator","nextSources","OnErrorResumeNextOperator","OnErrorResumeNextSubscriber","subscribeToNextSource","shift","pairwise","PairwiseOperator","PairwiseSubscriber","pair","hasPrev","prev","plucker","props","currentProp","publish","publishBehavior","publishLast","publishReplay","selectorOrScheduler","RepeatOperator","RepeatSubscriber","repeatWhen","notifier","RepeatWhenOperator","RepeatWhenSubscriber","sourceIsBeingSubscribedTo","retries","retriesSubscription","notifications","subscribeToRetries","RetryOperator","RetrySubscriber","retryWhen","RetryWhenOperator","RetryWhenSubscriber","errors","sample","SampleOperator","sampleSubscriber","SampleSubscriber","SampleTimeOperator","SampleTimeSubscriber","dispatchNotification","sequenceEqual","compareTo","comparator","SequenceEqualOperator","SequenceEqualSubscriber","_oneComplete","checkValues","_c","_b","areEqual","nextB","completeB","SequenceEqualCompareToSubscriber","shareSubjectFactory","share","shareReplay","configOrBufferSize","config","shareReplayOperator","useRefCount","single","SingleOperator","SingleSubscriber","applySingleValue","seenValue","SkipOperator","SkipSubscriber","skipLast","SkipLastOperator","_skipCount","SkipLastSubscriber","_count","skipCount","currentIndex","ring","_ring","oldValue","skipUntil","SkipUntilOperator","SkipUntilSubscriber","skipWhile","SkipWhileOperator","SkipWhileSubscriber","skipping","SubscribeOnObservable","delayTime","asap","SubscribeOnOperator","switchMap","SwitchMapOperator","SwitchMapSubscriber","switchAll","switchMapTo","inclusive","TakeWhileOperator","TakeWhileSubscriber","nextOrComplete","tap","DoOperator","TapSubscriber","observerOrNext","noop","_tapComplete","_tapError","isFunction","_context","_tapNext","defaultThrottleConfig","leading","trailing","ThrottleOperator","ThrottleSubscriber","_leading","_hasValue","send","_sendValue","throttle","_throttled","_trailing","throttlingDone","ThrottleTimeOperator","ThrottleTimeSubscriber","_trailingValue","_hasTrailingValue","TimeInterval","interval","TimeoutWithOperator","withObservable","waitFor","TimeoutWithSubscriber","scheduleTimeout","timestamp","window","windowBoundaries","WindowOperator","windowSubscriber","WindowSubscriber","sourceSubscription","openWindow","prevWindow","startWindowEvery","WindowCountOperator","windowSize","WindowCountSubscriber","windows","c","windowTimeSpan","windowCreationInterval","maxWindowSize","POSITIVE_INFINITY","WindowTimeOperator","CountedSubject","WindowTimeSubscriber","dispatchWindowClose","window_1","window_2","closeWindow","dispatchWindowTimeSpanOnly","dispatchWindowCreation","timeSpanState","windowToggle","WindowToggleOperator","WindowToggleSubscriber","context_3","w","context_4","inner","windowWhen","closingNotification","WithLatestFromOperator","WithLatestFromSubscriber","found","zipAll"],"sourceRoot":""}